<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Proper BVH Motion Viewer</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            background: linear-gradient(135deg, #667eea, #764ba2); 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; 
            color: white;
        }
        #container { width: 100vw; height: 100vh; }
        #controls { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(0,0,0,0.95);
            padding: 25px;
            border-radius: 15px;
            min-width: 400px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 100;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        h3 { 
            margin-top: 0; 
            color: #f093fb; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            text-align: center;
        }
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }
        .loading { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .success { background: rgba(76, 175, 80, 0.2); color: #4CAF50; }
        .error { background: rgba(244, 67, 54, 0.2); color: #f44336; }
        .info { background: rgba(33, 150, 243, 0.2); color: #2196F3; }
        
        .sequence-info {
            background: rgba(240, 147, 251, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #f093fb;
            font-size: 14px;
        }
        .current-phase {
            font-size: 18px;
            font-weight: bold;
            color: #4facfe;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin: 15px 0;
            padding: 15px;
            background: rgba(79, 172, 254, 0.1);
            border-radius: 10px;
            text-align: center;
            min-height: 20px;
        }
        .transition-indicator {
            background: linear-gradient(90deg, #f093fb, #f5576c);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
        }
        .style-indicator {
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
        }
        button { 
            width: 100%;
            margin: 8px 0; 
            padding: 15px 20px; 
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white; 
            border: none; 
            border-radius: 10px; 
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 14px;
        }
        button:hover { 
            background: linear-gradient(45deg, #f5576c, #f093fb);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        select { 
            width: 100%;
            margin: 8px 0; 
            padding: 12px; 
            background: #2a2a2a; 
            color: white; 
            border: 1px solid #555;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f093fb, #4facfe);
            border-radius: 5px;
            transition: width 0.1s ease;
            width: 0%;
        }
        .stats {
            font-size: 13px;
            color: #ccc;
            margin: 15px 0;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .bvh-info {
            font-size: 12px;
            color: #aaa;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .debug-log {
            font-family: monospace;
            font-size: 11px;
            max-height: 120px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            padding: 8px;
            border-radius: 5px;
            margin: 10px 0;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h3>üé≠ Proper BVH Motion Viewer</h3>
        
        <div id="status" class="status loading">Initializing viewer...</div>
        
        <div>
            <label>Transition Sequence:</label>
            <select id="sequenceSelect" onchange="loadBVHSequence()">
                <option value="emotional_journey">üé≠ Emotional Journey</option>
                <option value="character_styles">ü§ñ Character Styles</option>
                <option value="movement_energy">‚ö° Movement Energy</option>
            </select>
        </div>
        
        <div class="current-phase" id="currentPhase">Loading BVH...</div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="sequenceInfo" class="sequence-info">
            <strong>Loading sequence information...</strong>
        </div>
        
        <div>
            <button onclick="toggleAnimation()">‚èØÔ∏è <span id="playButtonText">Pause</span></button>
            <button onclick="resetAnimation()">üîÑ Reset</button>
            <button onclick="toggleAutoRotate()">üåÄ <span id="rotateButtonText">Auto Rotate: ON</span></button>
            <button onclick="changeSpeed()">‚ö° Speed: <span id="speedDisplay">1x</span></button>
        </div>
        
        <div class="bvh-info" id="bvhInfo">
            <strong>BVH Status:</strong> Waiting to load...
        </div>
        
        <div class="stats" id="statsInfo">
            <strong>Motion Stats:</strong><br>
            Frame: <span id="frameCount">0</span> / <span id="totalFrames">0</span><br>
            Duration: <span id="currentTime">0.0</span>s / <span id="totalTime">0.0</span>s<br>
            Phase: <span id="currentPhaseText">None</span>
        </div>
        
        <div class="debug-log" id="debugLog">
            <strong>Debug Log:</strong><br>
        </div>
    </div>

    <script src="./three.min.js"></script>
    <script>
        let scene, camera, renderer, clock;
        let skeleton = null;
        let animationFrame = 0;
        let totalFrames = 370;
        let isAnimating = true;
        let autoRotate = true;
        let animationSpeed = 1;
        let currentSequence = 'emotional_journey';
        let bvhData = null;
        let jointHierarchy = [];
        let isRealBVHData = false;
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const debugLog = document.getElementById('debugLog');
            debugLog.innerHTML += `[${timestamp}] ${message}<br>`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateStatus(message, type = 'loading') {
            document.getElementById('status').className = `status ${type}`;
            document.getElementById('status').textContent = message;
            log(message, type);
        }
        
        // BVH sequence definitions
        const bvhSequences = {
            emotional_journey: {
                name: 'Emotional Journey',
                description: 'Proper BVH: Neutral ‚Üí Elated ‚Üí Angry ‚Üí Depressed ‚Üí Neutral',
                file: 'emotional_journey_transitions.bvh',
                timeline: [
                    {type: 'style', name: 'Neutral', start: 0, duration: 50},
                    {type: 'transition', name: 'Neutral ‚Üí Elated', start: 50, duration: 30},
                    {type: 'style', name: 'Elated', start: 80, duration: 50},
                    {type: 'transition', name: 'Elated ‚Üí Angry', start: 130, duration: 30},
                    {type: 'style', name: 'Angry', start: 160, duration: 50},
                    {type: 'transition', name: 'Angry ‚Üí Depressed', start: 210, duration: 30},
                    {type: 'style', name: 'Depressed', start: 240, duration: 50},
                    {type: 'transition', name: 'Depressed ‚Üí Neutral', start: 290, duration: 30},
                    {type: 'style', name: 'Neutral', start: 320, duration: 50}
                ]
            },
            character_styles: {
                name: 'Character Styles',
                description: 'Proper BVH: Neutral ‚Üí Robot ‚Üí Zombie ‚Üí Drunk ‚Üí Neutral',
                file: 'character_styles_transitions.bvh',
                timeline: [
                    {type: 'style', name: 'Neutral', start: 0, duration: 50},
                    {type: 'transition', name: 'Neutral ‚Üí Robot', start: 50, duration: 30},
                    {type: 'style', name: 'Robot', start: 80, duration: 50},
                    {type: 'transition', name: 'Robot ‚Üí Zombie', start: 130, duration: 30},
                    {type: 'style', name: 'Zombie', start: 160, duration: 50},
                    {type: 'transition', name: 'Zombie ‚Üí Drunk', start: 210, duration: 30},
                    {type: 'style', name: 'Drunk', start: 240, duration: 50},
                    {type: 'transition', name: 'Drunk ‚Üí Neutral', start: 290, duration: 30},
                    {type: 'style', name: 'Neutral', start: 320, duration: 50}
                ]
            },
            movement_energy: {
                name: 'Movement Energy',
                description: 'Proper BVH: Tiptoe ‚Üí Skip ‚Üí March ‚Üí Crouched ‚Üí Proud',
                file: 'movement_energy_transitions.bvh',
                timeline: [
                    {type: 'style', name: 'Tiptoe', start: 0, duration: 50},
                    {type: 'transition', name: 'Tiptoe ‚Üí Skip', start: 50, duration: 30},
                    {type: 'style', name: 'Skip', start: 80, duration: 50},
                    {type: 'transition', name: 'Skip ‚Üí March', start: 130, duration: 30},
                    {type: 'style', name: 'March', start: 160, duration: 50},
                    {type: 'transition', name: 'March ‚Üí Crouched', start: 210, duration: 30},
                    {type: 'style', name: 'Crouched', start: 240, duration: 50},
                    {type: 'transition', name: 'Crouched ‚Üí Proud', start: 290, duration: 30},
                    {type: 'style', name: 'Proud', start: 320, duration: 50}
                ]
            }
        };

        function init() {
            try {
                updateStatus('Checking Three.js library...', 'loading');
                
                if (typeof THREE === 'undefined') {
                    updateStatus('‚ùå Three.js library not found', 'error');
                    return;
                }
                
                updateStatus('‚úÖ Three.js loaded successfully', 'success');
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f0f23);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(2, 1.5, 3);
                camera.lookAt(0, 1, 0);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(renderer.domElement);
                
                updateStatus('‚úÖ 3D scene created', 'success');
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(8, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Add colored lights for atmosphere
                const pinkLight = new THREE.PointLight(0xf093fb, 0.5, 10);
                pinkLight.position.set(-3, 2, 3);
                scene.add(pinkLight);
                
                const blueLight = new THREE.PointLight(0x4facfe, 0.5, 10);
                blueLight.position.set(3, 2, -3);
                scene.add(blueLight);
                
                // Add grid
                const grid = new THREE.GridHelper(4, 4, 0x666666, 0x333333);
                scene.add(grid);
                
                // Add orbit controls
                addOrbitControls();
                
                // Initialize clock
                clock = new THREE.Clock();
                
                updateStatus('‚úÖ Scene setup complete', 'success');
                
                // Start render loop
                animate();
                
                // Load initial BVH sequence
                loadBVHSequence();
                
            } catch (error) {
                updateStatus(`‚ùå Initialization failed: ${error.message}`, 'error');
                log(`Initialization error: ${error.stack}`, 'error');
            }
        }
        
        function addOrbitControls() {
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', function(event) {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', function() {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', function(event) {
                if (!mouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 1, 0);
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
        }
        
        async function loadBVHSequence() {
            const select = document.getElementById('sequenceSelect');
            currentSequence = select.value;
            const sequence = bvhSequences[currentSequence];
            
            updateStatus(`üîÑ Loading ${sequence.name}...`, 'loading');
            
            // Update UI
            document.getElementById('sequenceInfo').innerHTML = `
                <strong>${sequence.name}</strong><br>
                ${sequence.description}<br>
                <small>File: ${sequence.file}</small>
            `;
            
            try {
                log(`Attempting to fetch: ${sequence.file}`, 'info');
                
                const response = await fetch(sequence.file);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const bvhText = await response.text();
                log(`BVH file loaded: ${bvhText.length} characters`, 'success');
                
                // Parse BVH data properly
                bvhData = parseProperBVH(bvhText);
                if (!bvhData) {
                    throw new Error("Failed to parse BVH data");
                }
                
                totalFrames = bvhData.numFrames;
                isRealBVHData = true;
                
                document.getElementById('bvhInfo').innerHTML = `
                    <strong>‚úÖ Proper BVH Data Loaded:</strong><br>
                    ‚Ä¢ File: ${sequence.file}<br>
                    ‚Ä¢ Joints: ${bvhData.joints.length}<br>
                    ‚Ä¢ Frames: ${totalFrames}<br>
                    ‚Ä¢ Channels: ${bvhData.totalChannels}<br>
                    ‚Ä¢ Duration: ${(totalFrames / 30).toFixed(1)}s
                `;
                
                document.getElementById('totalFrames').textContent = totalFrames;
                document.getElementById('totalTime').textContent = (totalFrames / 30).toFixed(1);
                
                createProperSkeleton();
                resetAnimation();
                
                updateStatus(`‚úÖ ${sequence.name} loaded with proper BVH parsing!`, 'success');
                
            } catch (error) {
                log(`BVH loading error: ${error.message}`, 'error');
                updateStatus(`‚ùå Failed to load BVH: ${error.message}`, 'error');
                
                // Create fallback skeleton with smooth procedural motion
                isRealBVHData = false;
                totalFrames = 370;
                createProperSkeleton();
                
                document.getElementById('bvhInfo').innerHTML = `
                    <strong>‚ö†Ô∏è Using Smooth Fallback Motion:</strong><br>
                    ‚Ä¢ Could not load: ${sequence.file}<br>
                    ‚Ä¢ Using smooth procedural animation<br>
                    ‚Ä¢ Frames: ${totalFrames}<br>
                    ‚Ä¢ Duration: ${(totalFrames / 30).toFixed(1)}s
                `;
                
                updateStatus('üîÑ Using smooth procedural motion (BVH failed)', 'info');
            }
        }
        
        function parseProperBVH(bvhText) {
            log('Parsing BVH data properly...', 'info');
            
            const lines = bvhText.split('\n').map(line => line.trim());
            let joints = [];
            let motionData = [];
            let currentJoint = null;
            let jointStack = [];
            let inHierarchy = false;
            let inMotion = false;
            let frameTime = 1/30;
            let totalChannels = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line === 'HIERARCHY') {
                    inHierarchy = true;
                    continue;
                } else if (line === 'MOTION') {
                    inHierarchy = false;
                    inMotion = true;
                    continue;
                } else if (line.startsWith('Frame Time:')) {
                    frameTime = parseFloat(line.split(':')[1]);
                    continue;
                } else if (line.startsWith('Frames:')) {
                    continue;
                }
                
                if (inHierarchy) {
                    if (line.startsWith('ROOT') || line.startsWith('JOINT')) {
                        const parts = line.split(/\s+/);
                        const jointName = parts[1];
                        
                        currentJoint = {
                            name: jointName,
                            parent: jointStack.length > 0 ? jointStack[jointStack.length - 1] : null,
                            children: [],
                            offset: [0, 0, 0],
                            channels: [],
                            channelOrder: [],
                            isRoot: line.startsWith('ROOT')
                        };
                        
                        if (currentJoint.parent) {
                            currentJoint.parent.children.push(currentJoint);
                        }
                        
                        joints.push(currentJoint);
                        jointStack.push(currentJoint);
                        
                    } else if (line.startsWith('OFFSET')) {
                        if (currentJoint) {
                            const parts = line.split(/\s+/);
                            currentJoint.offset = [
                                parseFloat(parts[1]),
                                parseFloat(parts[2]),
                                parseFloat(parts[3])
                            ];
                        }
                    } else if (line.startsWith('CHANNELS')) {
                        if (currentJoint) {
                            const parts = line.split(/\s+/);
                            const numChannels = parseInt(parts[1]);
                            currentJoint.channelOrder = parts.slice(2, 2 + numChannels);
                            currentJoint.channelStart = totalChannels;
                            totalChannels += numChannels;
                        }
                    } else if (line === '}') {
                        jointStack.pop();
                        currentJoint = jointStack.length > 0 ? jointStack[jointStack.length - 1] : null;
                    }
                } else if (inMotion && line && !line.startsWith('Frame')) {
                    const values = line.split(/\s+/).map(v => parseFloat(v)).filter(v => !isNaN(v));
                    if (values.length === totalChannels) {
                        motionData.push(values);
                    }
                }
            }
            
            if (motionData.length === 0) {
                log('No motion data found in BVH', 'error');
                return null;
            }
            
            log(`Parsed ${joints.length} joints, ${motionData.length} frames, ${totalChannels} channels`, 'success');
            
            return {
                joints: joints,
                motionData: motionData,
                numFrames: motionData.length,
                frameTime: frameTime,
                totalChannels: totalChannels
            };
        }
        
        function createProperSkeleton() {
            // Clear previous skeleton
            if (skeleton) {
                scene.remove(skeleton);
            }
            
            skeleton = new THREE.Group();
            skeleton.joints = [];
            skeleton.bones = [];
            
            if (isRealBVHData && bvhData) {
                // Create skeleton from BVH data
                bvhData.joints.forEach((joint, index) => {
                    const geometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: joint.isRoot ? 0xff4444 : (index % 2 === 0 ? 0x44ff44 : 0x4444ff)
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    
                    sphere.userData = {
                        jointIndex: index,
                        joint: joint,
                        initialPosition: new THREE.Vector3(),
                        initialRotation: new THREE.Euler()
                    };
                    
                    skeleton.add(sphere);
                    skeleton.joints.push(sphere);
                    
                    // Create bones to children
                    joint.children.forEach(childJoint => {
                        const childIndex = bvhData.joints.indexOf(childJoint);
                        if (childIndex !== -1) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(0, 0, 0),
                                new THREE.Vector3(0, 0, 0)
                            ]);
                            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                            const line = new THREE.Line(geometry, material);
                            
                            line.userData = {
                                parentIndex: index,
                                childIndex: childIndex,
                                isBone: true
                            };
                            
                            skeleton.add(line);
                            skeleton.bones.push(line);
                        }
                    });
                });
                
                log(`Created skeleton with ${skeleton.joints.length} joints and ${skeleton.bones.length} bones`, 'success');
                
            } else {
                // Create simple fallback skeleton
                const simpleJoints = [
                    { name: 'root', pos: [0, 1.0, 0], color: 0xff6b6b },
                    { name: 'spine', pos: [0, 1.3, 0], color: 0xff8e8e },
                    { name: 'head', pos: [0, 1.6, 0], color: 0xffb3b3 },
                    { name: 'leftShoulder', pos: [-0.2, 1.4, 0], color: 0x4ecdc4 },
                    { name: 'leftArm', pos: [-0.4, 1.3, 0], color: 0x45b7b8 },
                    { name: 'rightShoulder', pos: [0.2, 1.4, 0], color: 0x6c5ce7 },
                    { name: 'rightArm', pos: [0.4, 1.3, 0], color: 0x74b9ff },
                    { name: 'leftHip', pos: [-0.1, 0.9, 0], color: 0xfeca57 },
                    { name: 'leftKnee', pos: [-0.1, 0.5, 0], color: 0xff9ff3 },
                    { name: 'leftFoot', pos: [-0.1, 0.1, 0], color: 0xf368e0 },
                    { name: 'rightHip', pos: [0.1, 0.9, 0], color: 0xff7675 },
                    { name: 'rightKnee', pos: [0.1, 0.5, 0], color: 0xfd79a8 },
                    { name: 'rightFoot', pos: [0.1, 0.1, 0], color: 0xe84393 }
                ];
                
                simpleJoints.forEach((joint, i) => {
                    const geometry = new THREE.SphereGeometry(0.04, 12, 12);
                    const material = new THREE.MeshLambertMaterial({ color: joint.color });
                    const sphere = new THREE.Mesh(geometry, material);
                    
                    sphere.position.set(joint.pos[0], joint.pos[1], joint.pos[2]);
                    sphere.userData = { 
                        jointIndex: i, 
                        initialPos: [...joint.pos],
                        name: joint.name
                    };
                    
                    skeleton.add(sphere);
                    skeleton.joints.push(sphere);
                });
                
                // Add simple bones
                const boneConnections = [
                    [0, 1], [1, 2], // spine to head
                    [1, 3], [3, 4], // left arm
                    [1, 5], [5, 6], // right arm
                    [0, 7], [7, 8], [8, 9], // left leg
                    [0, 10], [10, 11], [11, 12] // right leg
                ];
                
                boneConnections.forEach(([from, to]) => {
                    const fromJoint = simpleJoints[from];
                    const toJoint = simpleJoints[to];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...fromJoint.pos),
                        new THREE.Vector3(...toJoint.pos)
                    ]);
                    const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                    const line = new THREE.Line(geometry, material);
                    
                    line.userData = { from, to, isBone: true };
                    skeleton.add(line);
                    skeleton.bones.push(line);
                });
            }
            
            scene.add(skeleton);
            log('Proper skeleton created successfully', 'success');
        }
        
        function getCurrentPhase() {
            const sequence = bvhSequences[currentSequence];
            for (let phase of sequence.timeline) {
                if (animationFrame >= phase.start && animationFrame < phase.start + phase.duration) {
                    return phase;
                }
            }
            return sequence.timeline[sequence.timeline.length - 1];
        }
        
        function updateSkeletonAnimation() {
            if (!skeleton) return;
            
            const currentPhase = getCurrentPhase();
            
            // Update UI
            const phaseElement = document.getElementById('currentPhase');
            if (currentPhase.type === 'transition') {
                phaseElement.innerHTML = `<div class="transition-indicator">üîÑ ${currentPhase.name}</div>`;
            } else {
                phaseElement.innerHTML = `<div class="style-indicator">üé≠ ${currentPhase.name}</div>`;
            }
            
            // Update progress bar
            const progress = (animationFrame / totalFrames) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            
            // Update stats
            document.getElementById('frameCount').textContent = Math.floor(animationFrame);
            document.getElementById('totalFrames').textContent = totalFrames;
            document.getElementById('currentTime').textContent = (animationFrame / 30).toFixed(1);
            document.getElementById('totalTime').textContent = (totalFrames / 30).toFixed(1);
            document.getElementById('currentPhaseText').textContent = currentPhase.name;
            
            // Apply proper motion to skeleton
            if (isRealBVHData && bvhData && Math.floor(animationFrame) < bvhData.motionData.length) {
                // Use real BVH data with proper parsing
                const frameIndex = Math.floor(animationFrame);
                const frameData = bvhData.motionData[frameIndex];
                
                // Apply motion to each joint properly
                skeleton.joints.forEach((jointMesh, i) => {
                    const joint = bvhData.joints[i];
                    const parentMesh = joint.parent ? skeleton.joints[bvhData.joints.indexOf(joint.parent)] : null;
                    
                    // Start with parent position or origin
                    let position = new THREE.Vector3();
                    if (parentMesh) {
                        position.copy(parentMesh.position);
                    }
                    
                    // Add joint offset (scaled appropriately)
                    position.add(new THREE.Vector3(
                        joint.offset[0] * 0.01,
                        joint.offset[1] * 0.01,
                        joint.offset[2] * 0.01
                    ));
                    
                    // Apply channel data with proper scaling
                    if (joint.channelOrder) {
                        joint.channelOrder.forEach((channel, channelIndex) => {
                            const dataIndex = joint.channelStart + channelIndex;
                            if (dataIndex < frameData.length) {
                                const value = frameData[dataIndex];
                                
                                // Apply motion with appropriate scaling
                                if (channel.includes('position')) {
                                    const scale = 0.001; // Much smaller scale for positions
                                    if (channel === 'Xposition') position.x += value * scale;
                                    else if (channel === 'Yposition') position.y += value * scale;
                                    else if (channel === 'Zposition') position.z += value * scale;
                                }
                                // Rotations are handled differently - we'll add basic rotation later
                            }
                        });
                    }
                    
                    jointMesh.position.copy(position);
                });
                
                // Update bone lines
                skeleton.bones.forEach(bone => {
                    if (bone.userData.parentIndex !== undefined && bone.userData.childIndex !== undefined) {
                        const parentJoint = skeleton.joints[bone.userData.parentIndex];
                        const childJoint = skeleton.joints[bone.userData.childIndex];
                        
                        const positions = bone.geometry.attributes.position.array;
                        positions[0] = parentJoint.position.x;
                        positions[1] = parentJoint.position.y;
                        positions[2] = parentJoint.position.z;
                        positions[3] = childJoint.position.x;
                        positions[4] = childJoint.position.y;
                        positions[5] = childJoint.position.z;
                        bone.geometry.attributes.position.needsUpdate = true;
                    }
                });
                
            } else {
                // Smooth procedural animation
                const time = clock.getElapsedTime() * animationSpeed;
                
                skeleton.joints.forEach((jointMesh) => {
                    if (jointMesh.userData.jointIndex !== undefined) {
                        const initialPos = jointMesh.userData.initialPos || [0, 1, 0];
                        
                        // Much smoother, more realistic motion
                        let motion = [0, 0, 0];
                        const baseMotion = 0.02; // Much smaller movements
                        
                        if (currentPhase.name.includes('Elated')) {
                            motion[1] = Math.sin(time * 4) * baseMotion;
                            motion[0] = Math.sin(time * 2) * baseMotion * 0.5;
                        } else if (currentPhase.name.includes('Angry')) {
                            motion[0] = Math.sin(time * 6) * baseMotion * 0.7;
                            motion[2] = Math.cos(time * 5) * baseMotion * 0.3;
                        } else if (currentPhase.name.includes('Depressed')) {
                            motion[1] = -baseMotion * 0.3 + Math.sin(time * 1) * baseMotion * 0.2;
                        } else if (currentPhase.name.includes('Robot')) {
                            const step = 0.5;
                            motion[0] = Math.round(Math.sin(time * 2) / step) * step * baseMotion;
                            motion[1] = Math.round(Math.cos(time * 3) / step) * step * baseMotion;
                        } else if (currentPhase.name.includes('Zombie')) {
                            motion[0] = Math.sin(time * 1.5) * baseMotion * 0.4;
                            motion[1] = Math.sin(time * 1.2 + jointMesh.userData.jointIndex) * baseMotion * 0.3;
                        } else {
                            motion[1] = Math.sin(time * 2 + jointMesh.userData.jointIndex * 0.5) * baseMotion * 0.4;
                            motion[0] = Math.sin(time * 1.5) * baseMotion * 0.2;
                        }
                        
                        jointMesh.position.set(
                            initialPos[0] + motion[0],
                            initialPos[1] + motion[1],
                            initialPos[2] + motion[2]
                        );
                    }
                });
                
                // Update simple bone lines
                skeleton.bones.forEach(bone => {
                    if (bone.userData.from !== undefined && bone.userData.to !== undefined) {
                        const fromJoint = skeleton.joints[bone.userData.from];
                        const toJoint = skeleton.joints[bone.userData.to];
                        
                        const positions = bone.geometry.attributes.position.array;
                        positions[0] = fromJoint.position.x;
                        positions[1] = fromJoint.position.y;
                        positions[2] = fromJoint.position.z;
                        positions[3] = toJoint.position.x;
                        positions[4] = toJoint.position.y;
                        positions[5] = toJoint.position.z;
                        bone.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            document.getElementById('playButtonText').textContent = isAnimating ? 'Pause' : 'Play';
            updateStatus(isAnimating ? 'Animation resumed' : 'Animation paused', 'success');
        }
        
        function resetAnimation() {
            animationFrame = 0;
            updateStatus('Animation reset', 'success');
        }
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('rotateButtonText').textContent = autoRotate ? 'Auto Rotate: ON' : 'Auto Rotate: OFF';
            updateStatus(autoRotate ? 'Auto rotate enabled' : 'Auto rotate disabled', 'success');
        }
        
        function changeSpeed() {
            animationSpeed = animationSpeed >= 2 ? 0.5 : animationSpeed + 0.5;
            document.getElementById('speedDisplay').textContent = animationSpeed + 'x';
            updateStatus(`Speed: ${animationSpeed}x`, 'success');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (isAnimating) {
                animationFrame = (animationFrame + animationSpeed) % totalFrames;
                updateSkeletonAnimation();
            }
            
            if (autoRotate && skeleton) {
                skeleton.rotation.y += 0.005;
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Error handling
        window.addEventListener('error', (e) => {
            log(`JavaScript error: ${e.message} at ${e.filename}:${e.lineno}`, 'error');
            updateStatus(`‚ùå Runtime error: ${e.message}`, 'error');
        });
        
        // Initialize when page loads
        if (typeof THREE !== 'undefined') {
            init();
        } else {
            window.addEventListener('load', () => {
                setTimeout(init, 100);
            });
        }
    </script>
</body>
</html>
