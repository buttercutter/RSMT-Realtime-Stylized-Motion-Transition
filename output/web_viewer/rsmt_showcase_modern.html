<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization - Modern (r177)</title>
    
    <!-- Import Map for Module Resolution -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js",
            "three/": "https://cdn.jsdelivr.net/npm/three@0.177.0/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #0084ff);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 212, 255, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            color: #4caf50;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            font-weight: bold;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #scene-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            font-size: 14px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .migration-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #4caf50, #45a049);
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 1001;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="migration-banner">
        ‚úÖ Modern THREE.js with ES Modules - No Deprecation Warnings!
    </div>
    
    <div class="migration-banner" style="background: rgba(0, 150, 0, 0.8); border-color: #00ff00;">
        üéØ Pure BVH Mode - All constraints removed, using 100% unmodified motion capture data
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Modern RSMT Viewer...</div>
        <div id="loading-status">Initializing THREE.js...</div>
    </div>
    
    <div id="container">
        <div id="ui-panel">
            <div class="title">üé≠ RSMT Neural Network Motion System (Modern)</div>
            
            <!-- AI Inference Monitoring Dashboard -->
            <div class="ai-monitoring-panel" id="ai-monitoring" style="background: rgba(0, 50, 100, 0.15); border: 1px solid #00d4ff; padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">üß† AI Inference Monitor</strong>
                    <button id="toggle-inference-details" style="background: none; border: 1px solid #00d4ff; color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">Show Details</button>
                </div>
                
                <div class="inference-summary" id="inference-summary">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div class="model-status" id="deephase-status">
                            <div style="color: #00ff88; font-weight: bold;">DeepPhase</div>
                            <div style="font-size: 10px;">Ready</div>
                        </div>
                        <div class="model-status" id="stylevae-status">
                            <div style="color: #ff8800; font-weight: bold;">StyleVAE</div>
                            <div style="font-size: 10px;">Standby</div>
                        </div>
                        <div class="model-status" id="transitionnet-status">
                            <div style="color: #ff4488; font-weight: bold;">TransitionNet</div>
                            <div style="font-size: 10px;">Idle</div>
                        </div>
                    </div>
                    
                    <!-- Model Warmup Controls -->
                    <div style="display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap;">
                        <button id="warmup-all-btn" onclick="warmupAllModels()" style="background: #4CAF50; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üî• Warm Up All</button>
                        <button id="warmup-stylevae-btn" onclick="warmupStyleVAE()" style="background: #ff8800; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üé® Wake StyleVAE</button>
                        <button id="warmup-transitionnet-btn" onclick="warmupTransitionNet()" style="background: #ff4488; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üîÑ Wake TransitionNet</button>
                        <!-- <button id="test-server-btn" onclick="testServerConnection()" style="background: #2196F3; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üåê Test Server</button> -->
                    </div>
                    
                    <div class="inference-metrics" id="inference-metrics" style="border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
                            <div>Inference Rate: <span id="inference-rate">60 FPS</span></div>
                            <div>Latency: <span id="inference-latency">16ms</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="inference-details" id="inference-details" style="display: none; border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px; margin-top: 8px;">
                    <div class="inference-log" id="inference-log" style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                        <div style="color: #00d4ff;">AI Inference Log:</div>
                        <div style="color: #00ff88;">‚úì DeepPhase model loaded</div>
                        <div style="color: #ffaa00;">‚ö† StyleVAE on standby</div>
                        <div style="color: #ff6666;">‚ö† TransitionNet not connected</div>
                        <div style="color: #888;">Tensor Shapes:</div>
                            <div id="tensor-shapes">Waiting for inference...</div>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button id="play-pause">Play/Pause</button>
                <button id="reset">Reset</button>
                <button id="cycle-animations">Cycle Animations</button>
                <button id="random-style">Random Style</button>
                <button id="transition-demo">Demo Transitions</button>
                <button id="speed-up">Speed Up</button>
                <button id="slow-down">Slow Down</button>
                <button id="toggle-wireframe">Toggle Wireframe</button>
            </div>



            <!-- Add this in the controls section -->
            <div class="controls" style="margin-top: 15px; padding: 15px; background: rgba(0, 100, 200, 0.1); border-radius: 8px; border: 1px solid #00d4ff;">
                <h3 style="margin: 0 0 10px 0; color: #00d4ff;">üß† AI Motion Control</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <button onclick="checkONNXRuntimeSetup()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">üîç Check ONNX Setup</button>
                    <button onclick="toggleAIMode()" id="ai-mode-btn" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">üé¨ BVH Mode: ON</button>
                    <button onclick="randomizeStyle()" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ú® Random Style</button>
                    <button onclick="smoothStyle()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ú® Smooth Style</button>
                    <button onclick="aggressiveStyle()" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">üî• Aggressive Style</button>
                    <button onclick="analyzeCurrentMotion()" style="padding: 8px 16px; background: #607D8B; color: white; border: none; border-radius: 4px; cursor: pointer;">üîç Analyze Motion</button>
                </div>
                
                <!-- T-Pose & Animation Debugging Controls REMOVED: All T-pose correction and adapter logic eliminated. -->
            </div>



            

            <!-- Character & Environment Controls -->
            <div class="controls" style="margin-top: 15px; padding: 15px; background: rgba(100, 0, 200, 0.1); border-radius: 8px; border: 1px solid #a855f7;">
                <h3 style="margin: 0 0 10px 0; color: #a855f7;">üé≠ Character & Environment</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <select id="character-select" style="padding: 8px; border-radius: 4px; background: #333; color: white; border: 1px solid #a855f7;">
                        <option value="">Select Character</option>
                        <option value="kaede.vrm">Kaede (School Girl)</option>
                        <option value="ichika.vrm" selected>Ichika (Student)</option>
                        <option value="buny.vrm">Buny (Teacher)</option>
                    </select>
                    
                    <select id="display-mode" style="padding: 8px; border-radius: 4px; background: #333; color: white; border: 1px solid #a855f7;">
                        <option value="textured_skeleton" selected>Textured Skeleton</option>
                        <option value="skeleton">Skeleton Only</option>
                        <option value="character">Character Only</option>
                        <option value="both">Skeleton + Character</option>
                    </select>
                    
                    <button onclick="toggleClassroom()" style="padding: 8px 16px; background: #a855f7; color: white; border: none; border-radius: 4px; cursor: pointer;">üè´ Toggle Classroom</button>
                    <button onclick="resetCharacterPosition()" style="padding: 8px 16px; background: #e11d48; color: white; border: none; border-radius: 4px; cursor: pointer;">‚Ü∫ Reset Position</button>
                    <button onclick="initTexturedSkeleton()" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer;">üé® Apply Texture</button>
                    <button onclick="initBasicTexturedSkeleton()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">üéØ Basic Texture</button>
                    <button onclick="testImports()" style="padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer;">üîß Test Imports</button>
                    
                    <select id="camera-mode" style="padding: 8px; border-radius: 4px; background: #333; color: white; border: 1px solid #a855f7;">
                        <option value="free">Free Camera</option>
                        <option value="follow">Follow Character</option>
                        <option value="front">Front View</option>
                        <option value="side">Side View</option>
                        <option value="classroom">Classroom View</option>
                        <option value="overhead">Overhead View</option>
                        <option value="close">Close-up</option>
                    </select>
                    
                    <button onclick="focusOnFace()" style="padding: 8px 16px; background: #06b6d4; color: white; border: none; border-radius: 4px; cursor: pointer;">üë§ Focus Face</button>
                    <button onclick="toggleFacialExpressions()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">üòä Toggle Expressions</button>
                    
                    <button onclick="testLighting()" style="padding: 8px 16px; background: #f59e0b; color: white; border: none; border-radius: 4px; cursor: pointer;">üí° Test Lighting</button>
                    <button onclick="improvedLighting()" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ú® Enhance Lighting</button>
                    <button onclick="focusOnFace()" style="padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer;">üëÅÔ∏è Focus Face</button>
                    <button onclick="fullBodyView()" style="padding: 8px 16px; background: #06b6d4; color: white; border: none; border-radius: 4px; cursor: pointer;">üë§ Full Body</button>
                    <button onclick="animateIchika()" style="padding: 8px 16px; background: #ec4899; color: white; border: none; border-radius: 4px; cursor: pointer;">üòä Animate Ichika</button>
                    <button onclick="fixSceneMaterials()" style="padding: 8px 16px; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">üîß Fix Materials</button>
                    <button onclick="compileAllMaterials()" style="padding: 8px 16px; background: #7c3aed; color: white; border: none; border-radius: 4px; cursor: pointer;">‚öôÔ∏è Compile Materials</button>
                    
                    <button onclick="toggleShadows()" style="padding: 8px 16px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">üåë Toggle Shadows</button>
                </div>
            </div>



            <div id="status" class="status">Ready</div>
        </div>
        
        <div class="info-panel">
            <div id="scene-info">
                <div class="metric">
                    <span>THREE.js Version:</span>
                    <span id="three-version">Loading...</span>
                </div>
                <div class="metric">
                    <span>Animation Frame:</span>
                    <span id="current-frame">0</span>
                </div>
                <div class="metric">
                    <span>Current Style:</span>
                    <span id="current-style">Neutral</span>
                </div>
                <div class="metric">
                    <span>Animation Speed:</span>
                    <span id="animation-speed">0.3x</span>
                </div>
                <div class="metric">
                    <span>Transition State:</span>
                    <span id="transition-state">Idle</span>
                </div>
                <div class="metric">
                    <span>Skeleton Joints:</span>
                    <span id="joint-count">15</span>
                </div>
                <div class="metric">
                    <span>Bone Connections:</span>
                    <span id="bone-count">13</span>
                </div>
                <div class="metric">
                    <span>Current Character:</span>
                    <span id="current-character">None</span>
                </div>
                <div class="metric">
                    <span>Display Mode:</span>
                    <span id="display-mode-info">Skeleton</span>
                </div>
                <div class="metric">
                    <span>Classroom:</span>
                    <span id="classroom-status">Hidden</span>
                </div>
                <div class="metric">
                    <span>Camera Mode:</span>
                    <span id="camera-mode-info">Free</span>
                </div>
            </div>
            
            <!-- Animation Controls -->
            <div class="controls" style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                <h3 style="margin: 0 0 10px 0; color: #fff;">Animation Controls</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <button onclick="toggleAnimation()" id="play-pause-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Pause</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Speed:</label>
                        <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="0.3" style="width: 100px;" onchange="updateAnimationSpeed(this.value)">
                        <span id="speed-value" style="color: #fff; min-width: 40px;">0.3x</span>
                    </div>
                    <button onclick="resetAnimation()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                    <button onclick="debugFrame()" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug Frame</button>
                    <button onclick="fixOrientation()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Fix Orientation (DISABLED)</button>
                    <button onclick="flipDirection()" style="padding: 8px 16px; background: #E91E63; color: none; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Flip Direction (DISABLED)</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Joint Intensity:</label>
                        <input type="range" id="intensity-slider" min="0.01" max="1.0" step="0.01" value="0.1" style="width: 100px;" onchange="updateJointIntensity(this.value)">
                        <span id="intensity-value" style="color: #fff; min-width: 40px;">0.1</span>
                    </div>
                    <button onclick="toggleSimpleMode()" id="simple-mode-btn" style="padding: 8px 16px; background: #607D8B; color: white; border: none; border-radius: 4px; cursor: pointer;">Simple Mode</button>
                    <button onclick="debugBVH()" style="padding: 8px 16px; background: #795548; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug BVH</button>
                    <button onclick="resetCharacterDirection()" style="padding: 8px 16px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Reset Direction</button>
                    <button onclick="window.fixVRMVisibility?.()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Fix VRM</button>
                    <button onclick="window.debugVRM?.()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Debug VRM</button>
                    <!-- REMOVED: Root Constraint slider - using pure BVH data with no constraints -->
                </div>
            </div>
        </div>
    </div>


    

    <!-- Character System Components -->
    <!-- <script src="./js/VRMBVHAdapter.js"></script> -->
    <!-- <script src="./js/EnhancedVRMBVHAdapter.js"></script> -->
    <script src="./js/VRMVisibilityFix.js"></script>
    <script src="./js/VRMDiagnostics.js"></script>
    <script src="./js/FacialExpressionSystem.js"></script>
    <script src="./js/AnimationBlender.js"></script>
    <script src="./js/VRMMaterialExtractor.js"></script>
    <script src="./js/ClassroomEnvironment.js"></script>
    <script src="./js/EnhancedCharacterSystem.js"></script>
    <script src="./js/ClassroomCameraController.js"></script>
    <script src="./js/AdvancedVRMLoader.js"></script>


    <script type="module">
        console.log('üöÄ Starting Modern RSMT Viewer with ES Modules...');
        
        // Test module availability
        console.log('üìã Module Availability Check:');
        const modules = ['VRMBVHAdapter', 'FacialExpressionSystem', 'AnimationBlender', 
                        'VRMMaterialExtractor', 'ClassroomEnvironment', 'EnhancedCharacterSystem', 
                        'ClassroomCameraController'];
        modules.forEach(name => {
            const available = typeof window[name] !== 'undefined';
            console.log(`${available ? '‚úÖ' : '‚ùå'} ${name}: ${available ? 'Available' : 'Not Found'}`);
        });
        
        // EARLY GLOBAL VALIDATION FUNCTIONS - Available immediately
        window.validateAndFixMaterialEarly = function(material) {
            if (!material) return null;
            
            try {
                // Ensure color is valid
                if (material.color && !material.color.isColor) {
                    if (typeof material.color === 'number') {
                        material.color = new THREE.Color(material.color);
                    } else if (typeof material.color === 'string') {
                        material.color = new THREE.Color(material.color);
                    } else {
                        material.color = new THREE.Color(0xFFFFFF);
                    }
                }
                
                // Validate uniforms if present
                if (material.uniforms) {
                    Object.keys(material.uniforms).forEach(key => {
                        const uniform = material.uniforms[key];
                        if (uniform && uniform.value !== undefined) {
                            // Check for Vector3 uniforms
                            if (uniform.value && uniform.value.isVector3) {
                                if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                    uniform.value.set(0, 0, 0);
                                }
                            }
                            // Check for Color uniforms
                            if (uniform.value && uniform.value.isColor) {
                                if (isNaN(uniform.value.r) || isNaN(uniform.value.g) || isNaN(uniform.value.b)) {
                                    uniform.value.setRGB(1, 1, 1);
                                }
                            }
                        }
                    });
                }
                
                material.needsUpdate = true;
                return material;
            } catch (error) {
                console.warn('‚ö†Ô∏è Material validation error:', error);
                return material;
            }
        };
        
        window.fixVRMShadersEarly = function() {
            console.log('üîß Early VRM shader fix attempt...');
            try {
                if (window.scene) {
                    let fixedCount = 0;
                    window.scene.traverse((object) => {
                        if (object.isMesh && object.material) {
                            const materials = Array.isArray(object.material) ? object.material : [object.material];
                            
                            materials.forEach((material, index) => {
                                if (material.type && (material.type.includes('VRM') || material.type.includes('MToon'))) {
                                    // Replace VRM materials with simple MeshLambertMaterial
                                    const newMaterial = new THREE.MeshLambertMaterial({
                                        color: material.color || 0xFFFFFF,
                                        map: material.map || null,
                                        transparent: material.transparent || false,
                                        opacity: material.opacity !== undefined ? material.opacity : 1.0
                                    });
                                    
                                    if (Array.isArray(object.material)) {
                                        object.material[index] = newMaterial;
                                    } else {
                                        object.material = newMaterial;
                                    }
                                    fixedCount++;
                                }
                            });
                        }
                    });
                    console.log(`‚úÖ Early fix applied to ${fixedCount} materials`);
                    return `Fixed ${fixedCount} materials`;
                } else {
                    console.log('‚ùå No scene available for early fix');
                    return 'No scene available';
                }
            } catch (error) {
                console.error('‚ùå Early shader fix error:', error);
                return 'Fix failed: ' + error.message;
            }
        };
        
        // Force material update and compilation for all objects in the scene
        
        async function initializeRSMTViewer() {
            console.log('üîÑ Initializing RSMT Viewer...');
            
            // Wait for THREE.js to load
            if (!window.THREE) {
                console.error('‚ùå THREE.js not loaded');
                updateLoadingStatus('Error: THREE.js not loaded');
                return;
            }
        
        console.log('‚úÖ THREE.js loaded successfully');
        
        // Initialize 3D scene first
        updateLoadingStatus('Creating 3D scene...');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            preserveDrawingBuffer: true,
            powerPreference: "high-performance"
        });
        
        // Enhanced renderer configuration for VRM compatibility
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = false; // Disabled for VRM compatibility
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        
        // Add comprehensive error handling
        
        // Handle WebGL context loss
        renderer.domElement.addEventListener('webglcontextlost', function(event) {
            event.preventDefault();
            console.warn('‚ö†Ô∏è WebGL context lost');
            updateLoadingStatus('WebGL context lost - attempting recovery...');
        });
        
        renderer.domElement.addEventListener('webglcontextrestored', function(event) {
            console.log('‚úÖ WebGL context restored');
            updateLoadingStatus('WebGL context restored');
        });
        
        // Append renderer to DOM
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Set up camera and controls
        camera.position.set(0, 1.6, 3);
        
        // Initialize skeleton group
        const skeletonGroup = new THREE.Group();
        scene.add(skeletonGroup);
        
        // Make scene globally accessible
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;
        window.skeletonGroup = skeletonGroup;
        
        updateLoadingStatus('Loading Character System...');
        
        // Initialize character system
        try {
            // Create character system instance (not a static init call)
            const characterSystem = new window.EnhancedCharacterSystem(scene, skeletonGroup);
            
            // Initialize textured skeleton in classroom with Ichika
            await characterSystem.initializeTexturedSkeletonInClassroom('ichika');
            console.log('‚úÖ Character System initialized');

            updateLoadingStatus('Loading Environment...');
            
            // Initialize environment - create instance and load classroom
            const classroomEnvironment = new window.ClassroomEnvironment(scene);
            await classroomEnvironment.loadClassroom();
            console.log('‚úÖ Environment loaded');
            
            // Now that THREE.js is loaded and environment is set up, call the main initialization
            console.log('üîß Calling initializeRSMTViewer() after THREE.js setup...');
            await initializeRSMTViewer();
            
            // Finalize loading
            loadingDiv.style.display = 'none';
            container.style.display = 'block';
            
            // Update status
            statusDiv.textContent = 'Ready';
            console.log('üéâ RSMT Viewer initialized successfully');
            
        } catch (error) {
            console.error('‚ùå Error during initialization:', error);
            updateLoadingStatus(`Error: ${error.message}`);
        }
    }

    // Note: initializeRSMTViewer() will be called after THREE.js loads in the main script section

    const loadingDiv = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        // Update loading status
        function updateLoadingStatus(message) {
            loadingStatus.textContent = message;
            console.log('üìù', message);
        }



        // === GLOBAL FUNCTION PLACEHOLDERS (Available immediately) ===

        // Define placeholder functions first so onclick handlers work
        window.toggleAIMode = function() { console.log('AI mode not ready yet'); };
        window.randomizeStyle = function() { console.log('Style system not ready yet'); };
        window.smoothStyle = function() { console.log('Style system not ready yet'); };
        window.aggressiveStyle = function() { console.log('Style system not ready yet'); };
        window.analyzeCurrentMotion = function() { console.log('Motion analysis not ready yet'); };
        window.toggleAnimation = function() { console.log('Animation controls not ready yet'); };
        window.updateAnimationSpeed = function() { console.log('Animation controls not ready yet'); };
        window.resetAnimation = function() { console.log('Animation controls not ready yet'); };
        // Global function assignments will be updated to actual functions after their definitions
        
        
        // Character System Placeholders
        window.toggleClassroom = function() { console.log('Character system not ready yet'); };
        window.resetCharacterPosition = function() { console.log('Character system not ready yet'); };
        window.focusOnFace = function() { console.log('Character system not ready yet'); };
        window.toggleFacialExpressions = function() { console.log('Character system not ready yet'); };
        window.loadSelectedCharacter = function() { console.log('Character system not ready yet'); };
        window.changeDisplayMode = function() { console.log('Character system not ready yet'); };
        window.setCameraMode = function() { console.log('Character system not ready yet'); };
        window.initTexturedSkeleton = function() { console.log('Character system not ready yet'); };
        window.initBasicTexturedSkeleton = function() { console.log('Character system not ready yet'); };
        window.testImports = function() { console.log('Character system not ready yet'); };
        
        // Test function to verify modules are loaded
        window.testModules = function() {
            console.log('Testing module availability...');
            console.log('VRMMaterialExtractor:', window.VRMMaterialExtractor ? '‚úÖ Available' : '‚ùå Missing');
            console.log('ClassroomEnvironment:', window.ClassroomEnvironment ? '‚úÖ Available' : '‚ùå Missing');
            console.log('EnhancedCharacterSystem:', window.EnhancedCharacterSystem ? '‚úÖ Available' : '‚ùå Missing');
            console.log('THREE.js:', window.THREE ? '‚úÖ Available' : '‚ùå Missing');
            console.log('THREELoaders.GLTFLoader:', window.THREELoaders?.GLTFLoader ? '‚úÖ Available' : '‚ùå Missing');
            console.log('THREELoaders.VRMLoaderPlugin:', window.THREELoaders?.VRMLoaderPlugin ? '‚úÖ Available' : '‚ùå Missing');
            return 'Module test complete - check console for details';
        };
        
        // Advanced diagnostics function
        window.fullDiagnostics = async function() {
            console.log('=== FULL MODULE DIAGNOSTICS ===');
            console.log('1. Basic availability:');
            console.log('   THREE.js:', !!window.THREE);
            console.log('   THREE.GLTFLoader:', !!window.THREE?.GLTFLoader);
            console.log('   VRMLoaderPlugin:', !!window.VRMLoaderPlugin);
            
            console.log('2. Import map support:');
            console.log('   Import map supported:', HTMLScriptElement.supports ? HTMLScriptElement.supports('importmap') : 'Unknown');
            
            console.log('3. Manual import tests:');
            try {
                const threeTest = await import('three');
                console.log('   Direct THREE import: ‚úÖ Success');
            } catch (e) {
                console.log('   Direct THREE import: ‚ùå Failed -', e.message);
            }
            
            try {
                const gltfTest = await import('three/examples/jsm/loaders/GLTFLoader.js');
                console.log('   GLTFLoader import: ‚úÖ Success');
            } catch (e) {
                console.log('   GLTFLoader import: ‚ùå Failed -', e.message);
            }
            
            try {
                const vrmTest = await import('@pixiv/three-vrm');
                console.log('   VRM import: ‚úÖ Success');
            } catch (e) {
                console.log('   VRM import: ‚ùå Failed -', e.message);
            }
            
            console.log('4. Browser info:');
            console.log('   User Agent:', navigator.userAgent);
            console.log('   ES Modules:', 'import' in window ? 'Supported' : 'Not supported');
            
            return 'Full diagnostics complete - check console for details';
        };


        // Global variables for animation and BVH data
        let isPlaying = true;
        let currentStyle = 'neutral';
        let animationSpeed = 0.3; // Much slower default speed
        let isWireframe = false;
        let bvhData = {};
        let currentAnimation = 'neutral_reference.bvh';
        let animationFrame = 0;
        let currentFrame = 0;
        let bvhScale = 0.01; // Scale factor for BVH units
        
        // BVH joint order for debugging
        let bvhJointOrder = ['Hips', 'Chest', 'Chest2', 'Chest3', 'Chest4', 'Neck', 'Head', 
                           'RightCollar', 'RightShoulder', 'RightElbow', 'RightWrist',
                           'LeftCollar', 'LeftShoulder', 'LeftElbow', 'LeftWrist',
                           'RightHip', 'RightKnee', 'RightAnkle', 'RightToe',
                           'LeftHip', 'LeftKnee', 'LeftAnkle', 'LeftToe'];
        
        // AI-powered animation variables (moved to global scope)
        let aiMode = false;
        let baseMotion = null;
        let generatedMotion = null;
        let styleUpdateCounter = 0;
        let currentTargetStyle = null;
        
        // AI Model Manager - placeholder object
        let aiModelManager = {
            isInitialized: false,
            motionHistory: [],
            models: {
                deepphase: { lastInferenceTime: 16 }
            },
            
            async initialize() {
                console.log('üß† AI Model Manager initialized (placeholder)');
                this.isInitialized = true;
            },
            
            updateMotionHistory(motion) {
                this.motionHistory.push(motion);
                if (this.motionHistory.length > 100) {
                    this.motionHistory.shift();
                }
            },
            
            getMotionSequence() {
                return this.motionHistory.slice(-30);
            },
            
            async encodeStyle(motionSequence) {
                return Array(256).fill(0).map(() => Math.random() * 0.1);
            },
            
            async predictPhase(motion) {
                return Math.random();
            },
            
            async generateTransition(baseMotion, targetStyle, length) {
                return Array(length).fill(0).map(() => Array(72).fill(0));
            }
        };
        
        // Global THREE.js objects (will be initialized in try block)
        let scene, camera, renderer, skeletonGroup;
        let jointMeshes = {};
        let boneCylinders = [];
        let jointWorldPositions = {};
        
        // Character System Variables
        let characterSystem = null;
        let cameraController = null;
        let classroomVisible = false;
        let facialExpressionsEnabled = true;
        let currentCharacterFile = null;
        
        // VRM Animation System Variables
        window.currentVRMAdapter = null; // Global VRM adapter for animation
        
        // Available BVH animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                duration: 120
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                duration: 100
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                duration: 110
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                duration: 140
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                duration: 115
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, precise walking style',
                duration: 90
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Confident, stylish walking motion',
                duration: 105
            }
        };
        try {
            updateLoadingStatus('Importing THREE.js module...');
            
            // Import THREE.js using ES modules with import map
            const THREE = await import('three');
            
            // Make THREE globally available for modules
            window.THREE = THREE;
            
            // Create a separate object for loaders since THREE may not be extensible
            window.THREELoaders = {};
            
            // Import additional THREE.js modules
            updateLoadingStatus('Loading THREE.js extensions...');
            
            // Load GLTFLoader using import map
            try {
                const { GLTFLoader } = await import('three/examples/jsm/loaders/GLTFLoader.js');
                window.THREELoaders.GLTFLoader = GLTFLoader;
                // Also try to add to THREE if possible
                try {
                    window.THREE.GLTFLoader = GLTFLoader;
                } catch (extensibilityError) {
                    console.log('THREE object not extensible, using THREELoaders instead');
                }
                console.log('‚úÖ GLTFLoader loaded successfully via import map');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load GLTFLoader via import map:', error);
                // Fallback to script tag approach
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/js/loaders/GLTFLoader.js';
                        script.onload = () => {
                            window.THREELoaders.GLTFLoader = window.GLTFLoader || window.THREE.GLTFLoader;
                            console.log('‚úÖ GLTFLoader loaded via script tag fallback');
                            resolve();
                        };
                        script.onerror = () => {
                            console.warn('‚ö†Ô∏è Failed to load GLTFLoader from CDN');
                            reject();
                        };
                        document.head.appendChild(script);
                    });
                } catch (scriptError) {
                    console.warn('‚ö†Ô∏è Failed to load GLTFLoader, will create basic loader:', scriptError);
                    // Create a basic GLTF loader fallback
                    window.THREELoaders.GLTFLoader = class BasicGLTFLoader {
                        constructor() {
                            console.log('Using BasicGLTFLoader fallback');
                        }
                        register(plugin) {
                            this.plugins = this.plugins || [];
                            this.plugins.push(plugin);
                            return this;
                        }
                        load(url, onLoad, onProgress, onError) {
                            console.warn('BasicGLTFLoader: Attempting to load:', url);
                            
                            // Try to use fetch to load the file
                            fetch(url)
                                .then(response => {
                                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                                    return response.arrayBuffer();
                                })
                                .then(buffer => {
                                    // Create a minimal GLTF-like object
                                    const scene = new window.THREE.Group();
                                    const gltf = {
                                        scene: scene,
                                        animations: [],
                                        asset: {},
                                        cameras: [],
                                        scenes: [scene],
                                        userData: {}
                                    };
                                    
                                    console.log('BasicGLTFLoader: Created basic scene object');
                                    if (onLoad) onLoad(gltf);
                                })
                                .catch(error => {
                                    console.error('BasicGLTFLoader failed:', error);
                                    if (onError) onError(error);
                                });
                        }
                    };
                }
            }
            
            // Load VRM loader using import map
            try {
                const { VRMLoaderPlugin, VRMUtils } = await import('@pixiv/three-vrm');
                window.THREELoaders.VRMLoaderPlugin = VRMLoaderPlugin;
                window.THREELoaders.VRMUtils = VRMUtils;
                // Also try to add to global window if possible
                try {
                    window.VRMLoaderPlugin = VRMLoaderPlugin;
                    window.VRMUtils = VRMUtils;
                } catch (extensibilityError) {
                    console.log('Window VRM assignment failed, using THREELoaders instead');
                }
                console.log('‚úÖ VRMLoaderPlugin loaded successfully via import map');
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to load VRMLoaderPlugin via import map:', error);
                // Create diagnostic function
                window.diagnoseVRMIssue = () => {
                    console.log('=== VRM Loading Diagnostics ===');
                    console.log('THREE.js available:', !!window.THREE);
                    console.log('GLTFLoader available:', !!window.THREELoaders?.GLTFLoader);
                    console.log('VRMLoaderPlugin available:', !!window.THREELoaders?.VRMLoaderPlugin);
                    console.log('Import map supported:', HTMLScriptElement.supports ? HTMLScriptElement.supports('importmap') : 'Unknown');
                    console.log('Browser:', navigator.userAgent);
                    console.log('THREE object extensible:', Object.isExtensible(window.THREE));
                };
                window.diagnoseVRMIssue();
            }
            
            updateLoadingStatus('THREE.js loaded successfully!');
            
            // Update loader status indicator
            function updateLoaderStatus() {
                const hasGLTF = !!(window.THREELoaders?.GLTFLoader);
                const hasVRM = !!(window.THREELoaders?.VRMLoaderPlugin);
                const status = `Loaders: GLTF ${hasGLTF ? '‚úÖ' : '‚ùå'} | VRM ${hasVRM ? '‚úÖ' : '‚ùå'}`;
                console.log('üì¶', status);
                
                // Update any status display if available
                const statusElement = document.getElementById('loader-status');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            updateLoaderStatus();
            
            // Update version info
            document.getElementById('three-version').textContent = THREE.REVISION || 'ES Module';
            
            // Initialize 3D scene
            updateLoadingStatus('Creating 3D scene...');
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            const camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                preserveDrawingBuffer: true,
                powerPreference: "high-performance"
            });
            
            // Enhanced renderer configuration for VRM compatibility
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = false; // Disabled for VRM compatibility
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            // Add comprehensive error handling
            
            // Handle WebGL context loss
            renderer.domElement.addEventListener('webglcontextlost', function(event) {
                event.preventDefault();
                console.warn('‚ö†Ô∏è WebGL context lost');
                updateLoadingStatus('WebGL context lost - attempting recovery...');
            });
            
            renderer.domElement.addEventListener('webglcontextrestored', function() {
                console.log('‚úÖ WebGL context restored');
                updateLoadingStatus('WebGL context restored');
                // Recompile materials
                compileAllMaterials();
            });
            
            // Add renderer to container (below UI)
            container.appendChild(renderer.domElement);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '1';
            
            updateLoadingStatus('Setting up professional lighting and environment...');
            
            // Professional anime character lighting setup (improved)
            
            // Beautiful gradient background for anime characters
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB'); // Sky blue
            gradient.addColorStop(0.5, '#98D8E8'); // Light blue
            gradient.addColorStop(1, '#F0F8FF'); // Alice blue
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Professional anime character lighting setup
            
            // High-intensity ambient light for soft overall illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // Main key light (strong directional light from front-top)
            window.keyLight = new THREE.DirectionalLight(0xffffff, 1.5);
            window.keyLight.position.set(2, 3, 2);
            window.keyLight.castShadow = false; // Avoid VRM shader conflicts
            scene.add(window.keyLight);
            
            // Fill light from left (softer, warmer)
            window.fillLight = new THREE.DirectionalLight(0xffeeaa, 1.0);
            window.fillLight.position.set(-2, 2, 1);
            scene.add(window.fillLight);
            
            // Rim light for character outline
            window.rimLight = new THREE.DirectionalLight(0xaaccff, 0.8);
            window.rimLight.position.set(0, 2, -3);
            scene.add(window.rimLight);
            
            // Character face lighting (important for anime style)
            window.faceLight = new THREE.SpotLight(0xffffff, 1.2);
            window.faceLight.position.set(0, 2, 1.5);
            window.faceLight.angle = Math.PI / 6;
            window.faceLight.penumbra = 0.2;
            window.faceLight.decay = 2;
            window.faceLight.distance = 5;
            scene.add(window.faceLight);
            
            // Soft environmental lights
            const envLight1 = new THREE.PointLight(0xffffff, 0.6, 8);
            envLight1.position.set(2, 2, -1);
            scene.add(envLight1);
            
            const envLight2 = new THREE.PointLight(0xffffcc, 0.6, 8);
            envLight2.position.set(-2, 2, -1);
            scene.add(envLight2);
            
            
            // Configure renderer for VRM compatibility (disable shadows to prevent shader errors)
            renderer.shadowMap.enabled = false; // Disabled for VRM compatibility 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; // Reduced for better anime lighting
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            // Configure for VRM compatibility
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.gammaFactor = 2.2;
            
            // Ground plane with better material (circular for anime aesthetic)
            const groundGeometry = new THREE.CircleGeometry(5, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.01;
            groundPlane.receiveShadow = false; // Disabled for VRM compatibility
            scene.add(groundPlane);
            
            // Subtle circular grid around character (better for anime aesthetic)
            const gridHelper = new THREE.PolarGridHelper(3, 8, 8, 64, 0x888888, 0x444444);
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(0.5);
            scene.add(axesHelper);
            
            updateLoadingStatus('Creating demo skeleton...');
            
            // Create a simple stick figure skeleton for demo
            skeletonGroup = new THREE.Group();
            
            // Create joints with proper geometry and materials (matching legacy)
            const jointGeometry = new THREE.SphereGeometry(0.04, 12, 12);
            const jointMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            
            // Create bone geometry and material (matching legacy style)
            const boneGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const boneMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0088ff,
                emissive: 0x001122
            });
            
            // ===== CORRECT BVH SKELETON FROM ACTUAL 100STYLE FILES =====
            // This matches the EXACT structure from Neutral_FW.bvh
            const bvhJoints = {
                // Root joint (world position) - 6 channels: pos + rot
                'Hips': { offset: [0.000000, 0.000000, 0.000000], parent: null },
                
                // Spine chain - exact offsets from BVH
                'Chest': { offset: [0.000000, 12.953391, -0.028419], parent: 'Hips' },
                'Chest2': { offset: [0.000000, 10.280254, 0.051622], parent: 'Chest' },
                'Chest3': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest2' },
                'Chest4': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest3' },
                'Neck': { offset: [0.000000, 13.296264, 0.000000], parent: 'Chest4' },
                'Head': { offset: [0.000000, 8.959264, 0.099003], parent: 'Neck' },
                
                // Right arm chain - exact offsets from BVH
                'RightCollar': { offset: [-3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'RightShoulder': { offset: [-15.792092, 0.000000, 0.000000], parent: 'RightCollar' },
                'RightElbow': { offset: [-31.151839, 0.000000, 0.000000], parent: 'RightShoulder' },
                'RightWrist': { offset: [-25.536298, 0.000000, 0.002321], parent: 'RightElbow' },
                
                // Left arm chain - will be mirrored
                'LeftCollar': { offset: [3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'LeftShoulder': { offset: [15.792092, 0.000000, 0.000000], parent: 'LeftCollar' },
                'LeftElbow': { offset: [31.151839, 0.000000, 0.000000], parent: 'LeftShoulder' },
                'LeftWrist': { offset: [25.536298, 0.000000, 0.002321], parent: 'LeftElbow' },
                
                // Right leg chain - exact offsets from BVH
                'RightHip': { offset: [-10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'RightKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'RightHip' },
                'RightAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'RightKnee' },
                'RightToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'RightAnkle' },
                
                // Left leg chain - mirrored from BVH
                'LeftHip': { offset: [10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'LeftKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'LeftHip' },
                'LeftAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'LeftKnee' },
                'LeftToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'LeftAnkle' }
            };
            
            
            // Create hierarchical skeleton with proper parent-child relationships
            function createHierarchicalSkeleton(joints) {
                const jointMeshes = {};
                const processedJoints = new Set();
                
                function createJoint(jointName) {
                    if (processedJoints.has(jointName) || !joints[jointName]) {
                        return jointMeshes[jointName] || null;
                    }
                    
                    const jointData = joints[jointName];
                    
                    // Create joint mesh
                    const mesh = new THREE.Mesh(jointGeometry, jointMaterial);
                    mesh.userData.bvhJointName = jointName;
                    mesh.userData.isJoint = true;
                    
                    // Set local position relative to parent
                    mesh.position.set(
                        jointData.offset[0] * bvhScale,
                        jointData.offset[1] * bvhScale,
                        jointData.offset[2] * bvhScale
                    );
                    
                    jointMeshes[jointName] = mesh;
                    processedJoints.add(jointName);
                    
                    // Add to parent or root
                    if (jointData.parent && joints[jointData.parent]) {
                        // Ensure parent exists first
                        const parentMesh = createJoint(jointData.parent);
                        if (parentMesh) {
                            parentMesh.add(mesh);
                        } else {
                            skeletonGroup.add(mesh);
                        }
                    } else {
                        // Root joint
                        skeletonGroup.add(mesh);
                    }
                    
                    return mesh;
                }
                
                // Create all joints with proper hierarchy
                for (const jointName of Object.keys(joints)) {
                    createJoint(jointName);
                }
                
                return jointMeshes;
            }
            
            jointMeshes = createHierarchicalSkeleton(bvhJoints);
            
            // Create bones connecting parent-child joints
            boneCylinders = [];
            
            for (const [jointName, jointData] of Object.entries(bvhJoints)) {
                if (jointData.parent && jointMeshes[jointData.parent] && jointMeshes[jointName]) {
                    const parentMesh = jointMeshes[jointData.parent];
                    const childMesh = jointMeshes[jointName];
                    
                    // Calculate bone length from local position
                    const localPos = childMesh.position;
                    const length = localPos.length();
                    
                    if (length > 0.01) { // Only create visible bones
                        const cylinder = new THREE.Mesh(boneGeometry, boneMaterial);
                        
                        // Position bone at parent's origin, pointing toward child
                        cylinder.position.set(0, 0, 0);
                        cylinder.scale.set(1, length, 1);
                        
                        // Rotate to point toward child
                        const direction = localPos.clone().normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        cylinder.quaternion.setFromUnitVectors(up, direction);
                        
                        // Offset to start at parent center and extend to child
                        cylinder.position.copy(direction.multiplyScalar(length * 0.5));
                        
                        // Add bone to parent joint so it moves with the joint
                        parentMesh.add(cylinder);
                        
                        cylinder.userData = {
                            parentJoint: jointData.parent,
                            childJoint: jointName,
                            length: length
                        };
                        
                        boneCylinders.push(cylinder);
                    }
                }
            }
            
            // Function to update bone positions (simplified since bones are now parented to joints)
            function updateBones() {
                // Bones automatically follow their parent joints due to hierarchy
                // No manual updates needed - THREE.js handles this automatically
            }
            
            // Function to apply BVH frame data to the skeleton joints
            function applyBVHFrameToSkeleton(frameData) {
                if (!frameData || frameData.length < 6) {
                    return;
                }
                
                // Apply root transform to the entire skeleton group
                const rootPosX = frameData[0] * 0.01; // Convert cm to meters
                const rootPosY = frameData[1] * 0.01;
                const rootPosZ = frameData[2] * 0.01;
                
                const rootRotX = frameData[3] * Math.PI / 180; // Convert degrees to radians
                const rootRotY = frameData[4] * Math.PI / 180;
                const rootRotZ = frameData[5] * Math.PI / 180;
                
                // Apply root position and rotation to skeleton group
                skeletonGroup.position.set(rootPosX, rootPosY, rootPosZ);
                skeletonGroup.rotation.set(rootRotX, rootRotY, rootRotZ);
                skeletonGroup.rotation.order = 'YXZ'; // Match BVH rotation order
                
                // Apply joint rotations
                let channelIndex = 6; // Skip root position and rotation
                
                for (let i = 1; i < bvhJointOrder.length && channelIndex + 2 < frameData.length; i++) {
                    const jointName = bvhJointOrder[i];
                    const jointMesh = jointMeshes[jointName];
                    
                    if (jointMesh) {
                        const rotX = frameData[channelIndex] * Math.PI / 180;
                        const rotY = frameData[channelIndex + 1] * Math.PI / 180;
                        const rotZ = frameData[channelIndex + 2] * Math.PI / 180;
                        
                        // Apply rotation to joint
                        jointMesh.rotation.set(rotX, rotY, rotZ);
                        jointMesh.rotation.order = 'YXZ';
                        
                        // Debug: Change joint color to show it's being animated
                        if (jointMesh.material && Math.floor(animationFrame) % 120 === 0) {
                            const intensity = Math.abs(rotX) + Math.abs(rotY) + Math.abs(rotZ);
                            if (intensity > 0.1) {
                                jointMesh.material.color.setHex(0xff0000); // Red for active joints
                            } else {
                                jointMesh.material.color.setHex(0x00ff00); // Green for static joints
                            }
                        }
                    }
                    
                    channelIndex += 3; // Each joint has 3 rotation channels
                }
                
                // Update bone connections automatically (they follow their parent joints)
                updateBones();

                // Also apply BVH frame data directly to VRM character
                applyBVHFrameToVRMDirect(frameData);
            }
            
            // Function to apply BVH frame data directly to VRM character (bypassing adapters)
            function applyBVHFrameToVRMDirect(frameData) {
                if (!frameData || frameData.length < 6) {
                    return;
                }
                
                // Find VRM character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    return; // No VRM to animate
                }
                
                // Get VRM root object and humanoid
                const vrmRoot = vrmCharacter.vrm ? vrmCharacter.vrm.scene : vrmCharacter;
                const vrm = vrmCharacter.vrm;
                const humanoid = vrm ? vrm.humanoid : null;
                
                // Apply root transform
                const rootPosX = frameData[0] * 0.01; // Convert cm to meters
                const rootPosY = frameData[1] * 0.01;
                const rootPosZ = frameData[2] * 0.01;
                
                const rootRotX = frameData[3] * Math.PI / 180; // Convert degrees to radians
                const rootRotY = frameData[4] * Math.PI / 180;
                const rootRotZ = frameData[5] * Math.PI / 180;
                
                // Apply root position and rotation to VRM
                vrmRoot.position.set(rootPosX, rootPosY - 0.98, rootPosZ); // Offset for hip height
                vrmRoot.rotation.set(rootRotX, rootRotY, rootRotZ);
                vrmRoot.rotation.order = 'YXZ';
                
                // Apply bone rotations using humanoid system
                if (humanoid && humanoid.humanBones) {
                    let channelIndex = 6; // Skip root position and rotation
                    
                    // Create BVH to VRM bone mapping
                    const bvhToVRMMapping = {
                        'Hips': 'hips',
                        'Chest': 'spine',
                        'Chest2': 'chest', 
                        'Chest3': 'upperChest',
                        'Chest4': 'upperChest',
                        'Neck': 'neck',
                        'Head': 'head',
                        'RightShoulder': 'rightShoulder',
                        'RightElbow': 'rightUpperArm',
                        'RightWrist': 'rightLowerArm',
                        'LeftShoulder': 'leftShoulder',
                        'LeftElbow': 'leftUpperArm',
                        'LeftWrist': 'leftLowerArm',
                        'RightHip': 'rightUpperLeg',
                        'RightKnee': 'rightLowerLeg',
                        'RightAnkle': 'rightFoot',
                        'LeftHip': 'leftUpperLeg',
                        'LeftKnee': 'leftLowerLeg',
                        'LeftAnkle': 'leftFoot'
                    };
                    
                    // Apply rotations to VRM bones
                    for (let i = 1; i < bvhJointOrder.length && channelIndex + 2 < frameData.length; i++) {
                        const bvhJointName = bvhJointOrder[i];
                        const vrmBoneName = bvhToVRMMapping[bvhJointName];
                        
                        if (vrmBoneName && humanoid.humanBones[vrmBoneName]) {
                            const vrmBone = humanoid.humanBones[vrmBoneName].node;
                            
                            if (vrmBone) {
                                const rotX = frameData[channelIndex] * Math.PI / 180;
                                const rotY = frameData[channelIndex + 1] * Math.PI / 180;
                                const rotZ = frameData[channelIndex + 2] * Math.PI / 180;
                                
                                // Apply rotation to VRM bone with reduced intensity to prevent over-rotation
                                const intensity = 0.5; // Reduce bone rotation intensity
                                vrmBone.rotation.set(rotX * intensity, rotY * intensity, rotZ * intensity);
                                vrmBone.rotation.order = 'YXZ';
                            }
                        }
                        
                        channelIndex += 3; // Each joint has 3 rotation channels
                    }
                }
            }
            
            scene.add(skeletonGroup);
            
            // DEBUG: Add a larger test sphere at skeleton origin
            const originGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const originSphere = new THREE.Mesh(originGeometry, originMaterial);
            originSphere.position.set(0, 0, 0); // At origin where skeleton should be
            originSphere.name = 'originSphere';
            scene.add(originSphere);
            
            // Position skeleton correctly for BVH coordinate system
            // BVH typically has hip/root at character height, but we want feet on ground
            skeletonGroup.position.y = 0; // Start at ground level - BVH will adjust
            skeletonGroup.rotation.set(0, 0, 0); // No base rotation - let BVH control
            skeletonGroup.rotation.order = 'YXZ'; // Match BVH rotation order (Y=yaw, X=pitch, Z=roll)
            
            // Update skeleton metrics
            document.getElementById('joint-count').textContent = Object.keys(jointMeshes).length;
            document.getElementById('bone-count').textContent = boneCylinders.length;
            
            // Position camera
            camera.position.set(3, 2, 3);
            camera.lookAt(0, 0.5, 0);
            
            updateLoadingStatus('Initializing character system...');
            
            // Enhanced VRM lighting setup following chat demo patterns
            window.enhanceVRMLighting = function(vrmCharacter) {
                if (!vrmCharacter || !vrmCharacter.vrm) {
                    console.warn('‚ö†Ô∏è No VRM character provided for lighting enhancement');
                    return;
                }
                
                console.log('üí° Enhancing VRM character lighting...');
                
                // Update existing lights for better anime character lighting
                if (window.keyLight) {
                    window.keyLight.intensity = 1.8; // Increase key light
                    window.keyLight.position.set(1.5, 2.5, 2); // Closer to character
                }
                
                if (window.fillLight) {
                    window.fillLight.intensity = 1.2; // Softer fill
                    window.fillLight.color.setHex(0xfff5e6); // Warmer fill light
                }
                
                if (window.rimLight) {
                    window.rimLight.intensity = 1.0;
                    window.rimLight.color.setHex(0xbbd4ff); // Cool rim light
                }
                
                if (window.faceLight) {
                    window.faceLight.intensity = 1.5; // Important for face visibility
                    window.faceLight.position.set(0, 1.8, 1.2); // Focus on face height
                }
                
                // Add character-specific lighting
                const characterLight = new THREE.SpotLight(0xffffff, 0.8);
                characterLight.position.set(0, 2, 1);
                characterLight.target = vrmCharacter.vrm.scene;
                characterLight.angle = Math.PI / 4;
                characterLight.penumbra = 0.3;
                characterLight.castShadow = false; // Avoid VRM shader conflicts
                scene.add(characterLight);
                
                // Store reference for later adjustment
                window.characterLight = characterLight;
                
                // Apply anime-style material enhancements
                vrmCharacter.vrm.scene.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // Enhance material properties for anime look
                        if (child.material.isMToonMaterial) {
                            // MToon materials get special treatment
                            child.material.shadeMultiply = new THREE.Color(0.8, 0.8, 0.9); // Slightly cool shadows
                            child.material.parametricRimColorFactor = 0.5; // Subtle rim lighting
                            child.material.parametricRimLiftFactor = 0.3;
                        } else if (child.material.isMeshStandardMaterial || child.material.isMeshBasicMaterial) {
                            // Standard materials get improved lighting response
                            child.material.roughness = 0.8; // Slightly rough for anime look
                            child.material.metalness = 0.1; // Very low metalness
                        }
                        
                        // Ensure materials receive lighting properly
                        child.material.needsUpdate = true;
                        child.castShadow = false; // Avoid shadow issues
                        child.receiveShadow = false;
                    }
                });
                
                console.log('‚úÖ VRM lighting enhancement complete');
            };
            
            // Initialize Enhanced Character System
            try {
                characterSystem = new EnhancedCharacterSystem(scene, skeletonGroup);
                
                updateLoadingStatus('Loading Ichika VRM character...');
                
                // Initialize textured skeleton in classroom with Ichika
                await characterSystem.initializeTexturedSkeletonInClassroom('ichika');
                
                // Load ACTUAL VRM character (not just textured skeleton)
                try {
                    statusDiv.textContent = 'Loading full Ichika VRM character...';
                    
                    // Create advanced VRM loader
                    const vrmLoader = new AdvancedVRMLoader();
                    const vrmCharacter = await vrmLoader.loadVRMCharacter('./assets/avatars/ichika.vrm', scene);
                    
                    // Position VRM character with proper coordinate system (feet on ground)
                    // DISABLED: Let VRMBVHAdapter handle all positioning to avoid conflicts
                    // const TYPICAL_HIP_HEIGHT_CM = 98.43;
                    // const BVH_TO_METERS_SCALE = 0.01;
                    // const TYPICAL_HIP_HEIGHT_METERS = TYPICAL_HIP_HEIGHT_CM * BVH_TO_METERS_SCALE; // ~0.98m
                    
                    // DISABLED: vrmCharacter.setPosition(0, -TYPICAL_HIP_HEIGHT_METERS, 0); // Let VRMBVHAdapter control
                    vrmCharacter.setScale(1.0); // Use full scale for VRM
                    
                    // Enable camera looking
                    vrmCharacter.lookAtCamera(camera);
                    
                    // Store VRM character reference in character system
                    characterSystem.vrmCharacter = vrmCharacter;
                    
                    // Store VRM character reference globally for functions
                    window.vrmCharacter = vrmCharacter;
                    
                    // Adapter logic removed: VRM is now animated directly from BVH frames.
                    characterSystem.vrmModel = vrmCharacter;
                    // Optionally, set up direct idle/facial animation here if needed.
                    
                    // Also store globally for debugging and lighting tests
                    window.vrmCharacter = vrmCharacter;
                    
                    
                    
                    // Apply enhanced lighting specifically for the VRM character
                    if (typeof enhanceVRMLighting === 'function') {
                        enhanceVRMLighting(vrmCharacter);
                    } else {
                        console.log('‚ö†Ô∏è enhanceVRMLighting function not yet available, will apply later');
                    }
                    
                    // Also apply textures to skeleton for comparison
                    await characterSystem.applyVRMTextureToSkeleton('./assets/avatars/ichika.vrm');
                    
                    // Set display mode to VRM character only (deprecating old skeleton)
                    characterSystem.setDisplayMode('character');
                    
                    currentCharacterFile = 'ichika.vrm';
                    
                    // Update UI to reflect VRM-only mode
                    document.getElementById('character-select').value = 'ichika.vrm';
                    document.getElementById('display-mode').value = 'character';
                    document.getElementById('current-character').textContent = 'Ichika (VRM Character)';
                    document.getElementById('display-mode-info').textContent = 'character';
                    
                    // Hide the old BVH skeleton completely - VRM will receive all animations
                    if (skeletonGroup) {
                        skeletonGroup.visible = false;
                        console.log('üîÑ Old BVH skeleton hidden - VRM character will receive all animations');
                    }
                    
                    statusDiv.textContent = 'üéâ Ichika VRM character loaded - old skeleton deprecated!';
                    console.log('üéâ Ichika VRM character loaded - all BVH animations will be applied to VRM!');
                    
                } catch (vrmError) {
                    console.warn('‚ö†Ô∏è Failed to auto-load Ichika VRM:', vrmError);
                    
                    // Fallback to textured skeleton only
                    try {
                        await characterSystem.applyVRMTextureToSkeleton('./assets/avatars/ichika.vrm');
                        characterSystem.setDisplayMode('textured_skeleton');
                        currentCharacterFile = 'ichika.vrm';
                        
                        document.getElementById('character-select').value = 'ichika.vrm';
                        document.getElementById('display-mode').value = 'textured_skeleton';
                        document.getElementById('current-character').textContent = 'Ichika (Textured Skeleton)';
                        document.getElementById('display-mode-info').textContent = 'textured_skeleton';
                        
                        statusDiv.textContent = '‚úÖ Ichika textured skeleton loaded (VRM failed)';
                        console.log('‚úÖ Fallback: Ichika textured skeleton loaded');
                    } catch (fallbackError) {
                        console.error('‚ùå Both VRM and textured skeleton failed:', fallbackError);
                        statusDiv.textContent = 'Character system ready (auto-load failed)';
                    }
                }
                
                // Initialize camera controller with optimal settings for character viewing
                cameraController = new ClassroomCameraController(camera, characterSystem);
                
                // Set camera to character-focused view
                camera.position.set(0, 1.6, 2.5); // Position from Ichika config
                camera.lookAt(0, 1.15, 0); // Look at character center
                camera.fov = 40; // Matching preview camera settings
                camera.updateProjectionMatrix();
                
                if (cameraController) {
                    cameraController.setCameraMode('front');
                    document.getElementById('camera-mode').value = 'front';
                    document.getElementById('camera-mode-info').textContent = 'front';
                }
                
                console.log('‚úÖ Character system with Ichika VRM initialized');
                
                // Set up event listeners for character controls
                const characterSelect = document.getElementById('character-select');
                const displayModeSelect = document.getElementById('display-mode');
                const cameraModeSelect = document.getElementById('camera-mode');
                
                characterSelect.addEventListener('change', loadSelectedCharacter);
                displayModeSelect.addEventListener('change', changeDisplayMode);
                cameraModeSelect.addEventListener('change', (e) => setCameraMode(e.target.value));
                
                // Initialize character control functions
                initializeCharacterControls();
                
            } catch (error) {
                console.error('‚ùå Failed to initialize character system:', error);
                // Continue without character system
            }
            
            updateLoadingStatus('Starting animation...');
            
            
            
            // Animation styles with different parameters
            const animationStyles = {
                neutral: { speed: 1.0, intensity: 1.0, bounce: 0.1, description: 'Natural walking' },
                happy: { speed: 1.3, intensity: 1.5, bounce: 0.3, description: 'Bouncy, energetic' },
                sad: { speed: 0.7, intensity: 0.5, bounce: 0.05, description: 'Slow, heavy steps' },
                angry: { speed: 1.2, intensity: 2.0, bounce: 0.1, description: 'Aggressive, forceful' },
                energetic: { speed: 1.8, intensity: 1.8, bounce: 0.4, description: 'High energy' },
                graceful: { speed: 0.9, intensity: 0.8, bounce: 0.2, description: 'Smooth, elegant' },
                robotic: { speed: 1.0, intensity: 1.0, bounce: 0.0, description: 'Mechanical, stiff' }
            };
            
            // Animation control functions
            function toggleAnimation() {
                isPlaying = !isPlaying;
                const btn = document.getElementById('play-pause-btn');
                btn.textContent = isPlaying ? 'Pause' : 'Play';
                btn.style.background = isPlaying ? '#4CAF50' : '#f44336';
            }
            
            function updateAnimationSpeed(value) {
                animationSpeed = parseFloat(value);
                document.getElementById('speed-value').textContent = value + 'x';
                document.getElementById('animation-speed').textContent = value + 'x';
                console.log('Animation speed changed to:', animationSpeed);
            }
            
            function resetAnimation() {
                animationFrame = 0;
                currentFrame = 0;
                console.log('Animation reset');
            }
            
            function debugFrame() {
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const frames = bvhData[currentAnimation].frames;
                    const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                    const frameData = frames[frameIndex];
                    
                    console.log('üîç Debug Frame Info:');
                    console.log('Current frame:', frameIndex);
                    console.log('Frame data length:', frameData.length);
                    console.log('First 12 values (root pos + rot):', frameData.slice(0, 12));
                    console.log('Animation speed:', animationSpeed);
                    console.log('Total frames:', frames.length);
                    console.log('Skeleton rotation:', skeletonGroup.rotation);
                    console.log('Skeleton position:', skeletonGroup.position);
                    
                    // Log some joint rotations
                    let channelIndex = 6; // Skip root pos and rot
                    console.log('Joint rotations:');
                    bvhJointOrder.slice(0, 3).forEach(jointName => {
                        if (channelIndex + 2 < frameData.length) {
                            const rotY = frameData[channelIndex++];
                            const rotX = frameData[channelIndex++];
                            const rotZ = frameData[channelIndex++];
                            console.log(`${jointName}: Y=${rotY.toFixed(2)}, X=${rotX.toFixed(2)}, Z=${rotZ.toFixed(2)}`);
                        }
                    });
                }
            }
            
            let orientationMode = 0;
            function fixOrientation() {
                // DISABLED: Let BVH data control all orientation
                console.log('‚ö†Ô∏è fixOrientation() disabled - using pure BVH data only');
            }
            
            let directionMultiplier = 1;
            function flipDirection() {
                // DISABLED: Let BVH data control all direction
                console.log('‚ö†Ô∏è flipDirection() disabled - using pure BVH data only');
            }
            
            // Make direction multiplier global
            window.directionMultiplier = directionMultiplier;
            
            let jointIntensity = 0.1;
            function updateJointIntensity(value) {
                jointIntensity = parseFloat(value);
                document.getElementById('intensity-value').textContent = value;
                console.log('Joint intensity changed to:', jointIntensity);
            }
            
            // Make intensity global
            window.jointIntensity = jointIntensity;
            
            // Global VRM shader fix function - defined early to be available during animation
            window.fixVRMShaders = function() {
                console.log('üîß Attempting to fix VRM shader issues...');
                
                if (!scene) {
                    console.log('‚ùå No scene available for shader fixes');
                    return 'No scene available';
                }
                
                let fixedCount = 0;
                scene.traverse((object) => {
                    if (object.isMesh && object.material) {
                        const materials = Array.isArray(object.material) ? object.material : [object.material];
                        
                        materials.forEach((material, index) => {
                            // Check for VRM materials or problematic uniforms
                            if (material.type && (material.type.includes('VRM') || material.type.includes('MToon'))) {
                                // Replace VRM materials with simple MeshLambertMaterial
                                const newMaterial = new THREE.MeshLambertMaterial({
                                    color: material.color || 0xFFFFFF,
                                    map: material.map || null,
                                    transparent: material.transparent || false,
                                    opacity: material.opacity !== undefined ? material.opacity : 1.0
                                });
                                
                                if (Array.isArray(object.material)) {
                                    object.material[index] = newMaterial;
                                } else {
                                    object.material = newMaterial;
                                }
                                fixedCount++;
                            }
                            
                            // Fix any uniforms with invalid Vector3 values
                            if (material.uniforms) {
                                Object.keys(material.uniforms).forEach(key => {
                                    const uniform = material.uniforms[key];
                                    if (uniform && uniform.value && uniform.value.isVector3) {
                                        if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                            uniform.value.set(0, 0, 0);
                                            fixedCount++;
                                        }
                                    }
                                });
                            }
                            
                            material.needsUpdate = true;
                        });
                        
                        // Disable shadows for VRM objects
                        object.castShadow = false;
                        object.receiveShadow = false;
                    }
                });
                
                console.log(`‚úÖ Fixed ${fixedCount} VRM materials/uniforms`);
                return `Fixed ${fixedCount} VRM materials for better compatibility`;
            };
            
            // Global emergency material fix function - more aggressive
            window.emergencyMaterialFix = function() {
                console.log('üö® Emergency material fix - replacing ALL problematic materials...');
                
                if (!scene) {
                    console.log('‚ùå No scene available');
                    return 'No scene available';
                }
                
                let replacedCount = 0;
                scene.traverse((object) => {
                    if (object.isMesh && object.material) {
                        const materials = Array.isArray(object.material) ? object.material : [object.material];
                        
                        materials.forEach((material, index) => {
                            // Replace ANY material that might have problematic shaders
                            if (material.isShaderMaterial || 
                                material.isRawShaderMaterial || 
                                material.type.includes('VRM') || 
                                material.type.includes('MToon') ||
                                material.uniforms) {
                                
                                // Create a safe replacement material
                                const newMaterial = new THREE.MeshBasicMaterial({
                                    color: material.color || new THREE.Color(0xFFFFFF),
                                    map: material.map || null,
                                    transparent: material.transparent || false,
                                    opacity: material.opacity !== undefined ? material.opacity : 1.0,
                                    side: material.side || THREE.FrontSide
                                });
                                
                                if (Array.isArray(object.material)) {
                                    object.material[index] = newMaterial;
                                } else {
                                    object.material = newMaterial;
                                }
                                replacedCount++;
                            }
                        });
                        
                        // Ensure object is renderable
                        object.castShadow = false;
                        object.receiveShadow = false;
                        object.frustumCulled = true;
                    }
                });
                
                // Also force update all materials
                if (typeof window.forceMaterialUpdateAndCompile === 'function') {
                    window.forceMaterialUpdateAndCompile();
                }
                
                console.log(`üö® Emergency fix: Replaced ${replacedCount} problematic materials`);
                return `Emergency fix applied to ${replacedCount} materials`;
            };
            
            // Global nuclear material fix - replaces EVERYTHING with safe materials
            window.nuclearMaterialFix = function() {
                console.log('‚ò¢Ô∏è Nuclear material fix - replacing ALL materials with basic ones...');
                
                if (!scene) {
                    console.log('‚ùå No scene available');
                    return 'No scene available';
                }
                
                let replacedCount = 0;
                scene.traverse((object) => {
                    if (object.isMesh && object.material) {
                        const materials = Array.isArray(object.material) ? object.material : [object.material];
                        
                        materials.forEach((material, index) => {
                            // Replace EVERY material with a safe one
                            const newMaterial = new THREE.MeshBasicMaterial({
                                color: new THREE.Color(0xCCCCCC), // Neutral gray
                                transparent: false,
                                opacity: 1.0,
                                side: THREE.FrontSide
                            });
                            
                            if (Array.isArray(object.material)) {
                                object.material[index] = newMaterial;
                            } else {
                                object.material = newMaterial;
                            }
                            replacedCount++;
                        });
                        
                        // Ensure object is ultra-safe
                        object.castShadow = false;
                        object.receiveShadow = false;
                        object.frustumCulled = true;
                        object.visible = true;
                    }
                });
                
                console.log(`‚ò¢Ô∏è Nuclear fix: Replaced ${replacedCount} materials with basic ones`);
                return `Nuclear fix applied to ${replacedCount} materials`;
            };
            
            // Global material validation function
            window.validateAndFixMaterial = function(material) {
                if (!material) return null;
                
                // Ensure color is valid
                if (material.color && !material.color.isColor) {
                    if (typeof material.color === 'number') {
                        material.color = new THREE.Color(material.color);
                    } else if (typeof material.color === 'string') {
                        material.color = new THREE.Color(material.color);
                    } else {
                        material.color = new THREE.Color(0xFFFFFF);
                    }
                }
                
                // Validate uniforms if present
                if (material.uniforms) {
                    Object.keys(material.uniforms).forEach(key => {
                        const uniform = material.uniforms[key];
                        if (uniform && uniform.value !== undefined) {
                            // Check for Vector3 uniforms
                            if (uniform.value && uniform.value.isVector3) {
                                if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                    uniform.value.set(0, 0, 0);
                                }
                            }
                            // Check for Color uniforms
                            if (uniform.value && uniform.value.isColor) {
                                if (isNaN(uniform.value.r) || isNaN(uniform.value.g) || isNaN(uniform.value.b)) {
                                    uniform.value.setRGB(1, 1, 1);
                                }
                            }
                        }
                    });
                }
                
                material.needsUpdate = true;
                return material;
            };
            
            // REMOVED: Root constraint functions - using pure BVH with no constraints
            
            let simpleMode = false;
            function toggleSimpleMode() {
                simpleMode = !simpleMode;
                const btn = document.getElementById('simple-mode-btn');
                btn.textContent = simpleMode ? 'Full Mode' : 'Simple Mode';
                btn.style.background = simpleMode ? '#4CAF50' : '#607D8B';
                console.log('Simple mode:', simpleMode);
            }
            
            function debugBVH() {
                console.log('üîç BVH Debug Information:');
                console.log('Current animation:', currentAnimation);
                console.log('BVH data loaded:', Object.keys(bvhData));
                
                if (bvhData[currentAnimation]) {
                    const data = bvhData[currentAnimation];
                    console.log('Frames:', data.frames?.length || 0);
                    console.log('Frame time:', data.frameTime);
                    console.log('Channel count:', data.channelCount);
                    
                    if (data.frames && data.frames.length > 0) {
                        console.log('First frame data:', data.frames[0].slice(0, 12));
                        console.log('Sample middle frame:', data.frames[Math.floor(data.frames.length/2)].slice(0, 12));
                    }
                } else {
                    console.log('‚ùå No BVH data loaded for:', currentAnimation);
                }
                
                console.log('Skeleton joints created:', Object.keys(jointMeshes));
                console.log('Skeleton group position:', skeletonGroup.position);
                console.log('Skeleton group rotation:', skeletonGroup.rotation);
                console.log('Animation frame:', animationFrame);
                console.log('Animation speed:', animationSpeed);
                console.log('Is playing:', isPlaying);
            }
            
            function resetCharacterDirection() {
                console.log('üîÑ Resetting character direction - PURE BVH MODE');
                window.characterHeading = 0;
                animationFrame = 0; // Reset animation to beginning
                
                // REMOVED: Do NOT manually set skeleton rotation/position
                // Let BVH data control everything when next frame is applied
                console.log('‚úÖ Animation reset to frame 0 - BVH will control all transforms');
            }
            
            // NOTE: Global function assignments moved to end of init() to prevent ReferenceErrors
            // All animation and UI functions will be assigned after their definitions
            


            // === AI-POWERED ANIMATION LOOP ===
            // AI variables are now defined in global scope above

            async function toggleAIMode() {
                aiMode = !aiMode;
                const aiModeBtn = document.getElementById('ai-mode-btn');
                
                if (aiMode) {
                    if (!aiModelManager.isInitialized) {
                        try {
                            await aiModelManager.initialize();
                        } catch (error) {
                            logInferenceEvent(`‚ùå Cannot enable AI mode: ${error.message}`, 'error');
                            aiMode = false;
                            return;
                        }
                    }
                    
                    aiModeBtn.textContent = 'ü§ñ AI Mode: ON';
                    aiModeBtn.style.background = '#4CAF50';
                    statusDiv.textContent = 'AI Mode: Neural networks controlling motion';
                    logInferenceEvent('üß† AI Mode activated - neural networks now controlling motion', 'success');
                    
                    // Initialize with current BVH frame as seed
                    if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                        const currentFrame = bvhData[currentAnimation].frames[0];
                        baseMotion = new Float32Array(currentFrame.slice(0, 66));
                        aiModelManager.updateMotionHistory(baseMotion);
                        // Set initial target style to the current animation's style
                        const motionSequence = aiModelManager.getMotionSequence();
                        currentTargetStyle = await aiModelManager.encodeStyle(motionSequence);
                    }
                    
                } else {
                    aiModeBtn.textContent = 'üé¨ BVH Mode: ON';
                    aiModeBtn.style.background = '#2196F3';
                    statusDiv.textContent = 'BVH Mode: Playing recorded motion capture';
                    logInferenceEvent('üé¨ BVH Mode activated - playing recorded motion', 'info');
                }
            }

            // Make toggleAIMode globally accessible after definition
            window.toggleAIMode = toggleAIMode;

            // Modified animation loop with AI integration
            function animate() {
                requestAnimationFrame(animate);
                
                if (isPlaying) {
                    animationFrame++;
                    
                    if (aiMode && aiModelManager.isInitialized) {
                        // === AI-POWERED MOTION GENERATION ===
                        
                        try {
                            // Every 10 frames, update style encoding (if not in transition)
                            if (styleUpdateCounter % 10 === 0 && aiModelManager.motionHistory.length >= 60 && !currentTargetStyle) {
                                const motionSequence = aiModelManager.getMotionSequence();
                                aiModelManager.encodeStyle(motionSequence).catch(error => {
                                    logInferenceEvent(`Style encoding failed: ${error.message}`, 'error');
                                });
                            }
                            styleUpdateCounter++;
                            
                            if (baseMotion && currentTargetStyle) {
                                // Predict phase for current motion
                                aiModelManager.predictPhase(baseMotion).then(phase => {
                                    document.getElementById('current-frame').textContent = `AI Phase: ${phase.toFixed(3)}`;
                                }).catch(error => {
                                    console.warn('Phase prediction failed:', error);
                                });
                                
                                // Generate next motion frame using TransitionNet
                                if (styleUpdateCounter % 5 === 0) { // Generate every 5 frames
                                    aiModelManager.generateTransition(
                                        baseMotion,
                                        currentTargetStyle // Use the target style for transition
                                    ).then(newMotion => {
                                        generatedMotion = newMotion;
                                        baseMotion = newMotion; // Use generated motion as next base
                                        aiModelManager.updateMotionHistory(newMotion);
                                        
                                        // Apply AI-generated motion to VRM character
                                        if (characterSystem) {
                                            characterSystem.applyBVHFrame(newMotion);
                                        }
                                        
                                    }).catch(error => {
                                        console.warn('Transition generation failed:', error);
                                    });
                                }
                                
                                // Update UI metrics
                                document.getElementById('inference-rate').textContent = 
                                    `${(1000 / (aiModelManager.models.deepphase?.lastInferenceTime || 16)).toFixed(1)} FPS`;
                                document.getElementById('inference-latency').textContent = 
                                    `${(aiModelManager.models.deepphase?.lastInferenceTime || 16).toFixed(1)}ms`;
                            }
                            
                        } catch (error) {
                            logInferenceEvent(`‚ùå AI processing error: ${error.message}`, 'error');
                            // Fallback to BVH mode
                            aiMode = false;
                            toggleAIMode();
                        }
                        
                    } else {
                        // === ORIGINAL BVH PLAYBACK ===
                        
                        if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                            const frames = bvhData[currentAnimation].frames;
                            const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                            const frameData = frames[frameIndex];
                            
                            // Apply to skeleton joints FIRST (this is what you see!)
                            try {
                                applyBVHFrameToSkeleton(frameData);
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Skeleton animation error:', e.message);
                            }
                            
                            // Apply to VRM character DIRECTLY (bypassing potentially broken adapters)
                            try {
                                applyBVHFrameToVRMDirect(frameData);
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Direct VRM animation error:', e.message);
                            }
                            
                            // ALSO try the character system (in case it works)
                            if (characterSystem) {
                                try {
                                    characterSystem.applyBVHFrame(frameData);
                                } catch (e) {
                                    console.warn('‚ö†Ô∏è Character system frame error:', e.message);
                                }
                            }
                            
                            // Update frame counter
                            document.getElementById('current-frame').textContent = `${frameIndex + 1}/${frames.length} (BVH)`;
                            
                        } else {
                            document.getElementById('current-frame').textContent = 'No BVH data';
                        }
                    }
                    
                    // Update UI displays
                    document.getElementById('animation-speed').textContent = `${animationSpeed.toFixed(1)}x`;
                }
                
                // Update VRM character system (idle animations, facial expressions, etc.)
                // Adapter logic removed: VRM idle/facial animation should be handled directly if needed.
                
                // Update full VRM character if available
                if (characterSystem && characterSystem.vrmCharacter) {
                    const deltaTime = 0.016;
                    characterSystem.vrmCharacter.update(deltaTime);
                }
                
                // Update camera controller
                if (cameraController) {
                    cameraController.update();
                }
                
                renderer.render(scene, camera);
            }

            


            
            // Setup enhanced controls
            document.getElementById('play-pause').onclick = () => {
                isPlaying = !isPlaying;
                statusDiv.textContent = isPlaying ? 'Playing' : 'Paused';
            };
            
            document.getElementById('reset').onclick = () => {
                animationFrame = 0;
                // REMOVED: skeletonGroup.rotation.y = 0; // Let BVH control rotation!
                animationSpeed = 1.0;
                currentStyle = 'neutral';
                document.getElementById('current-style').textContent = currentStyle;
                statusDiv.textContent = 'Reset to neutral (BVH-controlled)';
            };
            
            document.getElementById('cycle-animations').onclick = async () => {
                // Cycle through real BVH animations
                const animFiles = Object.keys(animations);
                const currentIndex = animFiles.indexOf(currentAnimation);
                const nextFile = animFiles[(currentIndex + 1) % animFiles.length];
                
                await loadAnimation(nextFile);
                statusDiv.textContent = `Loading: ${animations[nextFile].name}`;

                // If AI mode is active, trigger style encoding for the new animation
                if (aiMode && aiModelManager.isInitialized) {
                    logInferenceEvent(`üîÑ Initiating AI transition to ${animations[nextFile].name} style...`, 'info');
                    const motionSequence = aiModelManager.getMotionSequence();
                    currentTargetStyle = await aiModelManager.encodeStyle(motionSequence);
                    document.getElementById('current-style').textContent = `AI: ${animations[nextFile].name}`;
                }
            };
            
            document.getElementById('random-style').onclick = async () => {
                // Load random BVH animation
                const animFiles = Object.keys(animations);
                const randomFile = animFiles[Math.floor(Math.random() * animFiles.length)];
                
                await loadAnimation(randomFile);
                statusDiv.textContent = `Random: ${animations[randomFile].name}`;

                // If AI mode is active, trigger style encoding for the new random animation
                if (aiMode && aiModelManager.isInitialized) {
                    logInferenceEvent(`üé≤ Initiating AI transition to random style (${animations[randomFile].name})...`, 'info');
                    const motionSequence = aiModelManager.getMotionSequence();
                    currentTargetStyle = await aiModelManager.encodeStyle(motionSequence);
                    document.getElementById('current-style').textContent = `AI: ${animations[randomFile].name}`;
                }
            };
            
            document.getElementById('speed-up').onclick = () => {
                animationSpeed = Math.min(3.0, animationSpeed * 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('slow-down').onclick = () => {
                animationSpeed = Math.max(0.2, animationSpeed / 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('toggle-wireframe').onclick = () => {
                isWireframe = !isWireframe;
                
                // Toggle wireframe on skeleton joint materials
                Object.values(jointMeshes).forEach(joint => {
                    if (joint && joint.material) {
                        joint.material.wireframe = isWireframe;
                        joint.material.needsUpdate = true;
                    }
                });
                
                // Toggle wireframe on bone cylinders
                boneCylinders.forEach(bone => {
                    if (bone && bone.material) {
                        bone.material.wireframe = isWireframe;
                        bone.material.needsUpdate = true;
                    }
                });
                
                // Toggle wireframe on VRM character if available
                if (window.currentVRMAdapter && window.currentVRMAdapter.vrmCharacter) {
                    const vrmCharacter = window.currentVRMAdapter.vrmCharacter;
                    vrmCharacter.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    mat.wireframe = isWireframe;
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material.wireframe = isWireframe;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                }
                
                // Also toggle wireframe on character system if available
                if (characterSystem && characterSystem.vrmCharacter) {
                    characterSystem.vrmCharacter.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    mat.wireframe = isWireframe;
                                    mat.needsUpdate = true;
                                });
                            } else {
                                child.material.wireframe = isWireframe;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                }
                
                console.log(`üîß Wireframe ${isWireframe ? 'ENABLED' : 'DISABLED'} for skeleton and VRM character`);
                statusDiv.textContent = isWireframe ? 'Wireframe ON (Skeleton + VRM)' : 'Wireframe OFF';
            };
            
            document.getElementById('transition-demo').onclick = () => {
                statusDiv.textContent = 'Running animation transition demo...';
                document.getElementById('transition-state').textContent = 'Active';
                
                // Cycle through different BVH animations
                const animFiles = Object.keys(animations);
                let animIndex = 0;
                
                const transitionInterval = setInterval(() => {
                    const animFile = animFiles[animIndex];
                    loadAnimation(animFile);
                    const animData = animations[animFile];
                    document.getElementById('current-style').textContent = animData.name;
                    statusDiv.textContent = `Transition: ${animData.name} - ${animData.description}`;
                    animIndex = (animIndex + 1) % animFiles.length;
                    
                    if (animIndex === 0) {
                        clearInterval(transitionInterval);
                        document.getElementById('transition-state').textContent = 'Complete';
                        statusDiv.textContent = 'Animation transition demo completed';
                        loadAnimation('neutral_reference.bvh');
                        document.getElementById('current-style').textContent = 'Neutral Walking';
                    }
                }, 2000);
            };
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
                      

            // ‚úÖ Add this function to check ONNX Runtime setup
            window.checkONNXRuntimeSetup = function() {
                console.log('üîç === ONNX RUNTIME SETUP CHECK ===');
                
                // Check if ONNX Runtime is properly loaded
                console.log('Global ort object:', typeof ort);
                console.log('ort.version:', ort.version);
                console.log('ort.env:', ort.env);
                
                // Check WebGPU support in ONNX Runtime
                console.log('WebGPU support checks:');
                console.log('- ort.env.webgpu:', ort.env.webgpu);
                console.log('- ort.env.wasm:', ort.env.wasm);
                
                // Check execution providers
                console.log('Available execution providers:');
                try {
                    // This might not work in all versions, but worth checking
                    if (ort.env.webgpu) {
                        console.log('- WebGPU execution provider: Available');
                    } else {
                        console.log('- WebGPU execution provider: Not available');
                    }
                } catch (e) {
                    console.log('- Could not check execution providers:', e.message);
                }
                
                // Check browser WebGPU support
                console.log('Browser WebGPU support:');
                console.log('- navigator.gpu:', !!navigator.gpu);
                if (navigator.gpu) {
                    navigator.gpu.requestAdapter().then(adapter => {
                        console.log('- WebGPU adapter:', !!adapter);
                        if (adapter) {
                            console.log('- Adapter features:', Array.from(adapter.features || []));
                        }
                    });
                }
            };

            // === FIX VRM ADAPTER CONNECTION ===
            window.fixVRMAdapterConnection = function() {
                console.log('üîó Fixing VRM adapter connection...');
                
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found to connect');
                    return 'No VRM character found';
                }
                
                // Connect to currentVRMAdapter
                if (window.currentVRMAdapter) {
                    console.log('- Connecting VRM to currentVRMAdapter');
                    window.currentVRMAdapter.vrmCharacter = vrmCharacter;
                    window.currentVRMAdapter.vrmModel = vrmCharacter.vrm || vrmCharacter;
                    console.log('‚úÖ VRM connected to currentVRMAdapter');
                }
                
                // Connect to characterSystem adapter
                if (characterSystem && characterSystem.vrmAdapter) {
                    console.log('- Connecting VRM to characterSystem.vrmAdapter');
                    characterSystem.vrmAdapter.vrmCharacter = vrmCharacter;
                    characterSystem.vrmAdapter.vrmModel = vrmCharacter.vrm || vrmCharacter;
                    console.log('‚úÖ VRM connected to characterSystem.vrmAdapter');
                }
                
                return 'VRM adapter connections fixed';
            };

            // === PERMANENTLY DISABLE T-POSE CORRECTIONS ===
            window.permanentlyDisableTPose = function() {
                console.log('üö´ PERMANENTLY disabling T-pose corrections...');
                
                // First fix the adapter connections
                window.fixVRMAdapterConnection();
                
                // Method 1: Disable T-pose corrections in VRM adapter
                if (window.currentVRMAdapter) {
                    console.log('- Disabling T-pose corrections in currentVRMAdapter');
                    window.currentVRMAdapter.disableTPoseCorrections = true;
                    window.currentVRMAdapter.applyTPoseCorrections = false;
                    
                    // Override the applyTPoseCorrections method
                    if (typeof window.currentVRMAdapter.applyTPoseCorrectionsToVRM === 'function') {
                        window.currentVRMAdapter.applyTPoseCorrectionsToVRM = function() {
                            // Do nothing - completely disabled
                            return;
                        };
                        console.log('‚úÖ Overrode currentVRMAdapter.applyTPoseCorrectionsToVRM method');
                    }
                    
                    // Also override any other T-pose related methods
                    if (typeof window.currentVRMAdapter.correctTPose === 'function') {
                        window.currentVRMAdapter.correctTPose = function() { return; };
                        console.log('‚úÖ Disabled correctTPose method');
                    }
                }
                
                // Method 2: Disable in character system adapter
                if (characterSystem && characterSystem.vrmAdapter) {
                    console.log('- Disabling T-pose corrections in characterSystem.vrmAdapter');
                    characterSystem.vrmAdapter.disableTPoseCorrections = true;
                    characterSystem.vrmAdapter.applyTPoseCorrections = false;
                    
                    if (typeof characterSystem.vrmAdapter.applyTPoseCorrectionsToVRM === 'function') {
                        characterSystem.vrmAdapter.applyTPoseCorrectionsToVRM = function() {
                            // Do nothing - completely disabled
                            return;
                        };
                        console.log('‚úÖ Overrode characterSystem.vrmAdapter.applyTPoseCorrectionsToVRM method');
                    }
                    
                    if (typeof characterSystem.vrmAdapter.correctTPose === 'function') {
                        characterSystem.vrmAdapter.correctTPose = function() { return; };
                        console.log('‚úÖ Disabled characterSystem correctTPose method');
                    }
                }
                
                console.log('üö´ T-pose corrections PERMANENTLY DISABLED');
                return 'T-pose corrections permanently disabled - VRM should now animate with BVH data';
            };

            // === ENABLE BONE ANIMATION ===
            window.enableBoneAnimation = function() {
                console.log('ü¶¥ Enabling direct bone animation...');
                
                // First make sure T-pose is disabled
                window.permanentlyDisableTPose();
                
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter || !vrmCharacter.vrm) {
                    console.log('‚ùå No VRM character found for bone animation');
                    return 'No VRM character found';
                }
                
                const vrm = vrmCharacter.vrm;
                const humanoid = vrm.humanoid;
                
                if (!humanoid) {
                    console.log('‚ùå No humanoid bones found in VRM');
                    return 'No humanoid bones found';
                }
                
                // Store humanoid for direct bone animation
                window.vrmHumanoid = humanoid;
                
                console.log('‚úÖ Direct bone animation enabled');
                console.log('Available humanoid bones:', humanoid.humanBones ? Object.keys(humanoid.humanBones) : 'none');
                
                return 'Direct bone animation enabled - VRM bones ready for animation';
            };

            // === RESTORE T-POSE CORRECTIONS ===
            window.restoreTPoseCorrections = function() {
                console.log('üîÑ Restoring T-pose corrections...');
                
                // This would require reloading the VRM adapter
                // For now, just reset the flags
                if (window.currentVRMAdapter) {
                    window.currentVRMAdapter.disableTPoseCorrections = false;
                    window.currentVRMAdapter.applyTPoseCorrections = true;
                    console.log('‚úÖ Restored currentVRMAdapter T-pose corrections');
                }
                
                if (characterSystem && characterSystem.vrmAdapter) {
                    characterSystem.vrmAdapter.disableTPoseCorrections = false;
                    characterSystem.vrmAdapter.applyTPoseCorrections = true;
                    console.log('‚úÖ Restored characterSystem T-pose corrections');
                }
                
                return 'T-pose corrections restored (may require VRM reload)';
            };

            // === DISABLE T-POSE CORRECTIONS FUNCTION ===
            window.disableTPoseCorrections = function() {
                console.log('üö´ Disabling T-pose corrections that override animation...');
                
                // Method 1: Disable T-pose corrections in VRM adapter
                if (window.currentVRMAdapter) {
                    console.log('- Disabling T-pose corrections in currentVRMAdapter');
                    window.currentVRMAdapter.disableTPoseCorrections = true;
                    window.currentVRMAdapter.applyTPoseCorrections = false;
                    
                    // Override the applyTPoseCorrections method
                    if (typeof window.currentVRMAdapter.applyTPoseCorrectionsToVRM === 'function') {
                        window.currentVRMAdapter.applyTPoseCorrectionsToVRM = function() {
                            console.log('‚ö†Ô∏è T-pose corrections disabled - skipping');
                            return; // Do nothing
                        };
                        console.log('‚úÖ Overrode applyTPoseCorrectionsToVRM method');
                    }
                }
                
                // Method 2: Disable in character system adapter
                if (characterSystem && characterSystem.vrmAdapter) {
                    console.log('- Disabling T-pose corrections in characterSystem.vrmAdapter');
                    characterSystem.vrmAdapter.disableTPoseCorrections = true;
                    characterSystem.vrmAdapter.applyTPoseCorrections = false;
                    
                    if (typeof characterSystem.vrmAdapter.applyTPoseCorrectionsToVRM === 'function') {
                        characterSystem.vrmAdapter.applyTPoseCorrectionsToVRM = function() {
                            console.log('‚ö†Ô∏è T-pose corrections disabled - skipping');
                            return; // Do nothing
                        };
                        console.log('‚úÖ Overrode characterSystem applyTPoseCorrectionsToVRM method');
                    }
                }
                
                return 'T-pose corrections disabled - VRM should now animate properly';
            };

            // === COMPREHENSIVE VRM & ANIMATION DEBUGGING FUNCTIONS ===
            
            window.debugVRMState = function() {
                console.log('üé≠ === VRM CHARACTER DEBUG STATE ===');
                
                // Check VRM adapter
                console.log('VRM Adapter Status:');
                console.log('- currentVRMAdapter exists:', !!window.currentVRMAdapter);
                if (window.currentVRMAdapter) {
                    console.log('- VRM character loaded:', !!window.currentVRMAdapter.vrmCharacter);
                    console.log('- VRM model loaded:', !!window.currentVRMAdapter.vrmModel);
                    console.log('- Bone mapping created:', !!window.currentVRMAdapter.boneMapping);
                    
                    if (window.currentVRMAdapter.vrmCharacter) {
                        const char = window.currentVRMAdapter.vrmCharacter;
                        console.log('- VRM position:', char.position);
                        console.log('- VRM rotation:', char.rotation);
                        console.log('- VRM scale:', char.scale);
                        console.log('- VRM visible:', char.visible);
                        console.log('- VRM in scene:', scene.children.includes(char));
                        
                        // Check materials
                        let materialCount = 0;
                        let meshCount = 0;
                        char.traverse((child) => {
                            if (child.isMesh) {
                                meshCount++;
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        materialCount += child.material.length;
                                    } else {
                                        materialCount++;
                                    }
                                }
                            }
                        });
                        console.log(`- Meshes found: ${meshCount}`);
                        console.log(`- Materials found: ${materialCount}`);
                    }
                    
                    // Check bone mapping
                    if (window.currentVRMAdapter.boneMapping) {
                        console.log('- Bone mapping keys:', Object.keys(window.currentVRMAdapter.boneMapping));
                        console.log('- Sample bone mapping:');
                        Object.keys(window.currentVRMAdapter.boneMapping).slice(0, 5).forEach(key => {
                            const bone = window.currentVRMAdapter.boneMapping[key];
                            if (bone) {
                                console.log(`  ${key}:`, bone.name, bone.position, bone.rotation);
                            }
                        });
                    }
                }
                
                // Check character system
                console.log('\nCharacter System Status:');
                console.log('- characterSystem exists:', !!characterSystem);
                if (characterSystem) {
                    console.log('- VRM character loaded:', !!characterSystem.vrmCharacter);
                    console.log('- VRM adapter exists:', !!characterSystem.vrmAdapter);
                    console.log('- Classroom visible:', classroomVisible);
                    console.log('- Facial expressions enabled:', facialExpressionsEnabled);
                }
                
                return 'VRM debug complete - check console for details';
            };
            
            window.debugBVHAnimation = function() {
                console.log('üé¨ === BVH ANIMATION DEBUG STATE ===');
                
                // Animation state
                console.log('Animation State:');
                console.log('- Current animation:', currentAnimation);
                console.log('- Animation frame:', animationFrame);
                console.log('- Animation speed:', animationSpeed);
                console.log('- Is playing:', isPlaying);
                console.log('- AI mode:', aiMode);
                
                // BVH data
                console.log('\nBVH Data:');
                console.log('- BVH data loaded:', Object.keys(bvhData));
                if (bvhData[currentAnimation]) {
                    const bvh = bvhData[currentAnimation];
                    console.log(`- ${currentAnimation} frames:`, bvh.frames ? bvh.frames.length : 'NO FRAMES');
                    console.log(`- ${currentAnimation} frame rate:`, bvh.frameRate || 'NO FRAME RATE');
                    console.log(`- ${currentAnimation} joints:`, bvh.joints ? Object.keys(bvh.joints) : 'NO JOINTS');
                    
                    if (bvh.frames && bvh.frames.length > 0) {
                        const currentFrameIndex = Math.floor(animationFrame) % bvh.frames.length;
                        const frameData = bvh.frames[currentFrameIndex];
                        console.log(`- Current frame ${currentFrameIndex} data:`, frameData ? frameData.slice(0, 6) : 'NO FRAME DATA');
                        
                        if (frameData && frameData.length >= 6) {
                            console.log('- Root position (cm):', frameData[0], frameData[1], frameData[2]);
                            console.log('- Root rotation (deg):', frameData[3], frameData[4], frameData[5]);
                        }
                    }
                }
                
                // Skeleton state
                console.log('\nSkeleton State:');
                console.log('- Skeleton group exists:', !!skeletonGroup);
                if (skeletonGroup) {
                    console.log('- Skeleton position:', skeletonGroup.position);
                    console.log('- Skeleton rotation:', skeletonGroup.rotation);
                    console.log('- Skeleton visible:', skeletonGroup.visible);
                    console.log('- Skeleton in scene:', scene.children.includes(skeletonGroup));
                    console.log('- Joint meshes count:', Object.keys(jointMeshes).length);
                    console.log('- Bone cylinders count:', boneCylinders.length);
                }
                
                return 'BVH animation debug complete - check console for details';
            };
            
            window.debugRenderingState = function() {
                console.log('üé® === RENDERING DEBUG STATE ===');
                
                // Scene state
                console.log('Scene State:');
                console.log('- Scene children count:', scene.children.length);
                console.log('- Camera position:', camera.position);
                console.log('- Camera rotation:', camera.rotation);
                console.log('- Renderer size:', renderer.getSize(new THREE.Vector2()));
                
                // Check for VRM character in scene
                let vrmInScene = false;
                let skeletonInScene = false;
                scene.children.forEach((child, index) => {
                    console.log(`- Child ${index}:`, child.type, child.name || 'unnamed');
                    if (child === skeletonGroup) skeletonInScene = true;
                    if (window.currentVRMAdapter && child === window.currentVRMAdapter.vrmCharacter) vrmInScene = true;
                    if (characterSystem && child === characterSystem.vrmCharacter) vrmInScene = true;
                });
                
                console.log('- VRM character in scene:', vrmInScene);
                console.log('- Skeleton in scene:', skeletonInScene);
                
                // Material errors
                console.log('\nError State:');
                console.log('- Consecutive errors:', consecutiveErrors);
                console.log('- Render error count:', renderErrorCount);
                console.log('- Animation halted:', animationHalted);
                console.log('- Last error message:', lastErrorMessage);
                
                return 'Rendering debug complete - check console for details';
            };
            
            window.debugAnimationFlow = function() {
                console.log('üîÑ === ANIMATION FLOW DEBUG ===');
                
                console.log('Testing animation flow...');
                
                // Test BVH frame application
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const frameIndex = Math.floor(animationFrame) % bvhData[currentAnimation].frames.length;
                    const frameData = bvhData[currentAnimation].frames[frameIndex];
                    
                    console.log('1. BVH frame data available:', !!frameData);
                    
                    if (frameData) {
                        console.log('2. Applying to skeleton...');
                        if (skeletonGroup.visible) {
                            console.log('   - Skeleton is visible, updating position/rotation');
                        } else {
                            console.log('   - Skeleton is HIDDEN, skipping update');
                        }
                        
                        console.log('3. Applying to VRM adapter...');
                        if (window.currentVRMAdapter) {
                            try {
                                console.log('   - VRM adapter exists, calling applyBVHFrameToVRM');
                                window.currentVRMAdapter.applyBVHFrameToVRM(frameData);
                                console.log('   - VRM frame application SUCCESS');
                            } catch (e) {
                                console.error('   - VRM frame application ERROR:', e.message);
                            }
                        } else {
                            console.log('   - NO VRM adapter available');
                        }
                        
                        console.log('4. Character system update...');
                        if (characterSystem) {
                            try {
                                characterSystem.update();
                                console.log('   - Character system update SUCCESS');
                            } catch (e) {
                                console.error('   - Character system update ERROR:', e.message);
                            }
                        } else {
                            console.log('   - NO character system available');
                        }
                    }
                } else {
                    console.log('1. NO BVH frame data available');
                }
                
                return 'Animation flow debug complete - check console for details';
            };
            
            window.forceSkeletonVisible = function() {
                console.log('üëÄ Forcing skeleton to be visible for debugging...');
                if (skeletonGroup) {
                    skeletonGroup.visible = true;
                    console.log('- Skeleton group made visible');
                    
                    // Make all joints visible and colored
                    Object.values(jointMeshes).forEach(joint => {
                        if (joint) {
                            joint.visible = true;
                            joint.material.color.setHex(0xff0000); // Red for visibility
                            joint.material.emissive.setHex(0x330000); // Dark red emissive
                            joint.material.needsUpdate = true;
                        }
                    });
                    console.log(`- Made ${Object.keys(jointMeshes).length} joints visible and red`);
                    
                    // Make all bones visible and colored
                    boneCylinders.forEach(bone => {
                        if (bone) {
                            bone.visible = true;
                            bone.material.color.setHex(0x00ff00); // Green for visibility
                            bone.material.emissive.setHex(0x003300); // Dark green emissive
                            bone.material.needsUpdate = true;
                        }
                    });
                    console.log(`- Made ${boneCylinders.length} bones visible and green`);
                    
                    statusDiv.textContent = 'Skeleton forced visible (Red joints, Green bones)';
                } else {
                    console.log('- NO skeleton group found');
                    statusDiv.textContent = 'ERROR: No skeleton group found';
                }
                
                return 'Skeleton visibility forced - skeleton should now be visible';
            };
            
            window.toggleSkeletonVisibility = function() {
                if (skeletonGroup) {
                    skeletonGroup.visible = !skeletonGroup.visible;
                    console.log(`üîß Skeleton visibility: ${skeletonGroup.visible ? 'VISIBLE' : 'HIDDEN'}`);
                    statusDiv.textContent = `Skeleton: ${skeletonGroup.visible ? 'VISIBLE' : 'HIDDEN'}`;
                } else {
                    console.log('‚ùå No skeleton group found');
                    statusDiv.textContent = 'ERROR: No skeleton group found';
                }
                
                return `Skeleton is now ${skeletonGroup?.visible ? 'VISIBLE' : 'HIDDEN'}`;
            };
            
            window.fullDebugReport = function() {
                console.log('üìä === FULL DEBUG REPORT ===');
                console.log('Generated at:', new Date().toISOString());
                
                window.debugVRMState();
                console.log('\n' + '='.repeat(50) + '\n');
                
                window.debugBVHAnimation();
                console.log('\n' + '='.repeat(50) + '\n');
                
                window.debugRenderingState();
                console.log('\n' + '='.repeat(50) + '\n');
                
                window.debugAnimationFlow();
                console.log('\n' + '='.repeat(50) + '\n');
                
                console.log('üìä === END FULL DEBUG REPORT ===');
                
                return 'Full debug report complete - check console for comprehensive details';
            };

            // ======= NEW COMPREHENSIVE BVH FRAME VERIFICATION FUNCTION =======
            window.verifyBVHFrameFlow = function() {
                console.log('üîç === COMPREHENSIVE BVH FRAME FLOW VERIFICATION ===');
                console.log('Testing if BVH frame data reaches skeleton and VRM character...');
                
                // Step 1: Check if BVH data is loaded
                console.log('üìÅ Step 1: BVH Data Status');
                console.log('- Current animation:', currentAnimation);
                console.log('- BVH data keys:', Object.keys(bvhData));
                console.log('- Is playing:', isPlaying);
                console.log('- Animation frame:', animationFrame);
                console.log('- Animation speed:', animationSpeed);
                
                if (!bvhData[currentAnimation]) {
                    console.log('‚ùå No BVH data loaded for current animation');
                    return 'No BVH data - load an animation first';
                }
                
                const bvh = bvhData[currentAnimation];
                if (!bvh.frames || bvh.frames.length === 0) {
                    console.log('‚ùå No frames in BVH data');
                    return 'No BVH frames available';
                }
                
                console.log('‚úÖ BVH data available:', bvh.frames.length, 'frames');
                
                // Step 2: Test frame data extraction
                console.log('\nüé¨ Step 2: Frame Data Extraction');
                const testFrameIndex = Math.min(100, Math.floor(bvh.frames.length / 4));
                const testFrame = bvh.frames[testFrameIndex];
                
                console.log('- Test frame index:', testFrameIndex);
                console.log('- Frame data length:', testFrame.length);
                console.log('- Root position (cm):', testFrame.slice(0, 3));
                console.log('- Root rotation (deg):', testFrame.slice(3, 6));
                console.log('- First joint rotations:', testFrame.slice(6, 12));
                
                // Step 3: Test skeleton animation
                console.log('\nü¶¥ Step 3: Skeleton Animation Test');
                console.log('- Skeleton exists:', !!skeletonGroup);
                console.log('- Skeleton visible:', skeletonGroup?.visible);
                console.log('- Joint count:', Object.keys(jointMeshes).length);
                
                if (skeletonGroup) {
                    console.log('- Current skeleton position:', skeletonGroup.position);
                    console.log('- Current skeleton rotation:', skeletonGroup.rotation);
                    
                    // Store original position for comparison
                    const originalSkeletonPos = skeletonGroup.position.clone();
                    const originalSkeletonRot = skeletonGroup.rotation.clone();
                    
                    // Apply test frame to skeleton
                    console.log('üß™ Applying test frame to skeleton...');
                    try {
                        applyBVHFrameToSkeleton(testFrame);
                        
                        const newSkeletonPos = skeletonGroup.position.clone();
                        const newSkeletonRot = skeletonGroup.rotation.clone();
                        
                        const skeletonPosChanged = !originalSkeletonPos.equals(newSkeletonPos);
                        const skeletonRotChanged = !originalSkeletonRot.equals(newSkeletonRot);
                        
                        console.log('‚úÖ Skeleton frame application result:');
                        console.log('  - Position changed:', skeletonPosChanged);
                        console.log('  - Rotation changed:', skeletonRotChanged);
                        console.log('  - New position:', newSkeletonPos);
                        console.log('  - New rotation:', newSkeletonRot);
                        
                        if (!skeletonPosChanged && !skeletonRotChanged) {
                            console.log('‚ö†Ô∏è WARNING: Skeleton did not move with BVH frame!');
                        }
                    } catch (error) {
                        console.log('‚ùå Skeleton frame application failed:', error.message);
                    }
                } else {
                    console.log('‚ùå No skeleton group available');
                }
                
                // Step 4: Test VRM animation  
                console.log('\nüé≠ Step 4: VRM Animation Test');
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                console.log('- VRM character found:', !!vrmCharacter);
                console.log('- VRM source:', vrmDiscovery.vrmSource);
                
                if (vrmCharacter) {
                    console.log('- VRM visible:', vrmCharacter.visible);
                    console.log('- VRM in scene:', scene.children.includes(vrmCharacter));
                    console.log('- Current VRM position:', vrmCharacter.position);
                    console.log('- Current VRM rotation:', vrmCharacter.rotation);
                    
                    // Store original position for comparison
                    const originalVRMPos = vrmCharacter.position.clone();
                    const originalVRMRot = vrmCharacter.rotation.clone();
                    
                    // Test direct VRM animation
                    console.log('üß™ Applying test frame to VRM (direct)...');
                    try {
                        applyBVHFrameToVRMDirect(testFrame);
                        
                        const newVRMPos = vrmCharacter.position.clone();
                        const newVRMRot = vrmCharacter.rotation.clone();
                        
                        const vrmPosChanged = !originalVRMPos.equals(newVRMPos);
                        const vrmRotChanged = !originalVRMRot.equals(newVRMRot);
                        
                        console.log('‚úÖ VRM direct frame application result:');
                        console.log('  - Position changed:', vrmPosChanged);
                        console.log('  - Rotation changed:', vrmRotChanged);
                        console.log('  - New position:', newVRMPos);
                        console.log('  - New rotation:', newVRMRot);
                        
                        if (!vrmPosChanged && !vrmRotChanged) {
                            console.log('‚ö†Ô∏è WARNING: VRM did not move with direct BVH frame!');
                        }
                    } catch (error) {
                        console.log('‚ùå VRM direct frame application failed:', error.message);
                    }
                    
                    // Test VRM adapter
                    console.log('üß™ Testing VRM adapter...');
                    if (window.currentVRMAdapter && window.currentVRMAdapter.applyBVHFrameToVRM) {
                        try {
                            const beforeAdapterPos = vrmCharacter.position.clone();
                            const beforeAdapterRot = vrmCharacter.rotation.clone();
                            
                            window.currentVRMAdapter.applyBVHFrameToVRM(testFrame);
                            
                            const afterAdapterPos = vrmCharacter.position.clone();
                            const afterAdapterRot = vrmCharacter.rotation.clone();
                            
                            const adapterPosChanged = !beforeAdapterPos.equals(afterAdapterPos);
                            const adapterRotChanged = !beforeAdapterRot.equals(afterAdapterRot);
                            
                            console.log('‚úÖ VRM adapter frame application result:');
                            console.log('  - Position changed:', adapterPosChanged);
                            console.log('  - Rotation changed:', adapterRotChanged);
                            console.log('  - Adapter position:', afterAdapterPos);
                            console.log('  - Adapter rotation:', afterAdapterRot);
                            
                            if (!adapterPosChanged && !adapterRotChanged) {
                                console.log('‚ö†Ô∏è WARNING: VRM adapter did not move character!');
                            }
                        } catch (error) {
                            console.log('‚ùå VRM adapter frame application failed:', error.message);
                        }
                    } else {
                        console.log('‚ùå No VRM adapter available');
                    }
                } else {
                    console.log('‚ùå No VRM character available');
                }
                
                // Step 5: Check animation loop status
                console.log('\n‚öôÔ∏è Step 5: Animation Loop Status');
                console.log('- enhancedAnimate running:', 'Check if frame counter is incrementing');
                console.log('- Current animation frame:', animationFrame);
                console.log('- Animation speed:', animationSpeed);
                console.log('- Is playing:', isPlaying);
                
                // Step 6: Summary and recommendations
                console.log('\nüìã Step 6: Summary & Recommendations');
                
                const hasWorkingSkeleton = skeletonGroup && skeletonGroup.visible;
                const hasWorkingVRM = vrmCharacter && (window.currentVRMAdapter || applyBVHFrameToVRMDirect);
                const hasBVHData = bvh.frames && bvh.frames.length > 0;
                
                console.log('- BVH data available:', hasBVHData);
                console.log('- Skeleton animation working:', hasWorkingSkeleton);
                console.log('- VRM animation working:', hasWorkingVRM);
                
                if (!hasWorkingSkeleton && !hasWorkingVRM) {
                    console.log('‚ùå PROBLEM: Neither skeleton nor VRM responding to BVH frames');
                    console.log('üí° Try: window.forceSkeletonVisible() and window.testDirectVRMAnimation()');
                } else if (!hasWorkingSkeleton) {
                    console.log('‚ö†Ô∏è Skeleton not responding - VRM should be working');
                    console.log('üí° Try: window.forceSkeletonVisible()');
                } else if (!hasWorkingVRM) {
                    console.log('‚ö†Ô∏è VRM not responding - skeleton should be working');
                    console.log('üí° Try: window.permanentlyDisableTPose() and window.testDirectVRMAnimation()');
                } else {
                    console.log('‚úÖ Both skeleton and VRM should be animating');
                    console.log('üí° If you don\'t see movement, check camera position and object visibility');
                }
                
                console.log('\nüîç === BVH FRAME FLOW VERIFICATION COMPLETE ===');
                
                return 'BVH frame flow verification complete - check console for detailed analysis';
            };

            // ======= VRM-SKELETON SYNCHRONIZATION FIX =======
            window.fixVRMSkeletonSync = function() {
                console.log('üîß === FIXING VRM-SKELETON SYNCHRONIZATION ===');
                console.log('Problem: Skeleton animates correctly but VRM does not follow');
                console.log('Solution: Copy skeleton animation directly to VRM character');
                console.log('‚ö†Ô∏è DISABLING ALL CONFLICTING ANIMATION FUNCTIONS');
                
                // Find VRM character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found');
                    return 'No VRM character found';
                }
                
                console.log('‚úÖ VRM character found:', vrmDiscovery.vrmSource);
                
                // Store original functions for restoration
                window.originalFunctions = window.originalFunctions || {};
                
                // 1. DISABLE VRM ADAPTER (from enhancedAnimate loop)
                if (window.currentVRMAdapter) {
                    console.log('üîß Disabling VRM adapter (from enhancedAnimate)...');
                    
                    if (!window.originalFunctions.vrmAdapterApply) {
                        window.originalFunctions.vrmAdapterApply = window.currentVRMAdapter.applyBVHFrameToVRM;
                    }
                    
                    // Replace with no-op function
                    window.currentVRMAdapter.applyBVHFrameToVRM = function(frameData) {
                        // Do nothing - skeleton sync handles VRM animation
                        return;
                    };
                    
                    console.log('‚úÖ VRM adapter disabled');
                }
                
                // 2. DISABLE applyBVHFrameToVRMDirect (from animate loop)
                console.log('üîß Disabling applyBVHFrameToVRMDirect (from animate)...');
                if (!window.originalFunctions.applyBVHFrameToVRMDirect) {
                    window.originalFunctions.applyBVHFrameToVRMDirect = window.applyBVHFrameToVRMDirect || applyBVHFrameToVRMDirect;
                }
                
                window.applyBVHFrameToVRMDirect = function(frameData) {
                    // Do nothing - skeleton sync handles VRM animation
                    return;
                };
                
                // 3. DISABLE characterSystem.applyBVHFrame (from animate loop)
                if (characterSystem && characterSystem.applyBVHFrame) {
                    console.log('üîß Disabling characterSystem.applyBVHFrame...');
                    if (!window.originalFunctions.characterSystemApply) {
                        window.originalFunctions.characterSystemApply = characterSystem.applyBVHFrame;
                    }
                    
                    characterSystem.applyBVHFrame = function(frameData) {
                        // Do nothing - skeleton sync handles VRM animation
                        return;
                    };
                }
                
                // 4. OVERRIDE applyBVHFrameToSkeleton to ALSO sync VRM
                console.log('üîß Overriding applyBVHFrameToSkeleton to sync VRM...');
                if (!window.originalFunctions.applyBVHFrameToSkeleton) {
                    window.originalFunctions.applyBVHFrameToSkeleton = window.applyBVHFrameToSkeleton || applyBVHFrameToSkeleton;
                }
                
                // Enhanced skeleton application that also updates VRM
                window.applyBVHFrameToSkeleton = function(frameData) {
                    // Apply to skeleton first (this works correctly)
                    if (window.originalFunctions.applyBVHFrameToSkeleton) {
                        window.originalFunctions.applyBVHFrameToSkeleton.call(this, frameData);
                    }
                    
                    // Debug: Log every 60 frames that we're being called
                    if (Math.floor(animationFrame) % 60 === 0) {
                        console.log('üîÑ applyBVHFrameToSkeleton called, attempting VRM sync...');
                    }
                    
                    // Now copy skeleton transform to VRM character
                    if (skeletonGroup && vrmCharacter) {
                        // Get skeleton's current position and rotation
                        const skeletonPos = skeletonGroup.position.clone();
                        const skeletonRot = skeletonGroup.rotation.clone();
                        
                        // Debug: Log skeleton state
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log('üíÄ Skeleton state:', {
                                position: skeletonPos,
                                rotation: skeletonRot,
                                visible: skeletonGroup.visible
                            });
                        }
                        
                        // Apply same transform to VRM character
                        let vrmRoot = null;
                        if (vrmCharacter.vrm && vrmCharacter.vrm.scene) {
                            // VRM character has .vrm.scene structure
                            vrmRoot = vrmCharacter.vrm.scene;
                            vrmRoot.position.copy(skeletonPos);
                            vrmRoot.rotation.copy(skeletonRot);
                            vrmRoot.rotation.order = 'YXZ';
                        } else if (vrmCharacter.scene) {
                            // Alternative structure
                            vrmRoot = vrmCharacter.scene;
                            vrmRoot.position.copy(skeletonPos);
                            vrmRoot.rotation.copy(skeletonRot);
                            vrmRoot.rotation.order = 'YXZ';
                        } else {
                            // Direct VRM object
                            vrmRoot = vrmCharacter;
                            vrmRoot.position.copy(skeletonPos);
                            vrmRoot.rotation.copy(skeletonRot);
                            vrmRoot.rotation.order = 'YXZ';
                        }
                        
                        // Debug: Log VRM state after sync
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log('ü§ñ VRM state after sync:', {
                                vrmRoot: vrmRoot,
                                position: vrmRoot ? vrmRoot.position : 'No VRM root',
                                rotation: vrmRoot ? vrmRoot.rotation : 'No VRM root',
                                visible: vrmRoot ? vrmRoot.visible : 'No VRM root'
                            });
                        }
                        
                        // Apply individual bone rotations if possible
                        if (vrmCharacter.vrm && vrmCharacter.vrm.humanoid && jointMeshes) {
                            const humanoid = vrmCharacter.vrm.humanoid;
                            
                            // Map skeleton joints to VRM bones
                            const jointToVRMMapping = {
                                'Hips': 'hips',
                                'Chest': 'spine', 
                                'Chest2': 'chest',
                                'Chest3': 'upperChest',
                                'Neck': 'neck',
                                'Head': 'head',
                                'RightShoulder': 'rightUpperArm',
                                'RightElbow': 'rightLowerArm', 
                                'LeftShoulder': 'leftUpperArm',
                                'LeftElbow': 'leftLowerArm',
                                'RightHip': 'rightUpperLeg',
                                'RightKnee': 'rightLowerLeg',
                                'LeftHip': 'leftUpperLeg',
                                'LeftKnee': 'leftLowerLeg'
                            };
                            
                            // Copy joint rotations from skeleton to VRM
                            let bonesSynced = 0;
                            for (const [skeletonJoint, vrmBone] of Object.entries(jointToVRMMapping)) {
                                const skeletonJointMesh = jointMeshes[skeletonJoint];
                                
                                if (skeletonJointMesh && humanoid.humanBones[vrmBone]) {
                                    const vrmBoneNode = humanoid.humanBones[vrmBone].node;
                                    
                                    if (vrmBoneNode) {
                                        // Copy rotation from skeleton joint to VRM bone
                                        vrmBoneNode.rotation.copy(skeletonJointMesh.rotation);
                                        vrmBoneNode.rotation.order = 'YXZ';
                                        bonesSynced++;
                                    }
                                }
                            }
                            
                            // Debug: Log bone sync count
                            if (Math.floor(animationFrame) % 60 === 0) {
                                console.log(`ü¶¥ Synced ${bonesSynced} bones from skeleton to VRM`);
                            }
                        }
                        
                        // Debug logging every 60 frames
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log('‚úÖ VRM sync complete:', {
                                frameIndex: Math.floor(animationFrame),
                                skeletonAnimating: !!(skeletonPos && skeletonRot),
                                vrmCharacterFound: !!vrmCharacter,
                                syncSuccessful: !!(vrmRoot && vrmRoot.position)
                            });
                        }
                    } else {
                        // Debug: Log missing components
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log('‚ùå VRM sync failed - missing components:', {
                                skeletonGroup: !!skeletonGroup,
                                vrmCharacter: !!vrmCharacter,
                                frameIndex: Math.floor(animationFrame)
                            });
                        }
                    }
                };
                
                // Make both skeleton and VRM visible for comparison
                if (skeletonGroup) {
                    skeletonGroup.visible = true;
                    console.log('‚úÖ Skeleton made visible');
                }
                
                if (vrmCharacter) {
                    if (vrmCharacter.vrm && vrmCharacter.vrm.scene) {
                        vrmCharacter.vrm.scene.visible = true;
                    } else {
                        vrmCharacter.visible = true;
                    }
                    console.log('‚úÖ VRM character made visible');
                }
                
                console.log('üîß === VRM-SKELETON SYNC COMPLETE ===');
                console.log('üí° VRM character should now follow skeleton animation exactly');
                console.log('üéØ Both skeleton and VRM should move in perfect sync');
                console.log('‚ö†Ô∏è ALL conflicting animation functions have been disabled');
                
                statusDiv.textContent = 'VRM-Skeleton sync enabled - ALL conflicts disabled';
                
                return 'VRM character will now copy skeleton animation directly (all conflicts disabled)';
            };

            // ======= DEBUG: MANUAL VRM SYNC TEST =======
            window.testManualVRMSync = function() {
                console.log('üß™ === MANUAL VRM SYNC TEST ===');
                
                // Find VRM character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found for manual sync test');
                    return 'No VRM character found';
                }
                
                console.log('‚úÖ VRM character found for manual sync test');
                
                if (!skeletonGroup) {
                    console.log('‚ùå No skeleton group found for manual sync test');
                    return 'No skeleton group found';
                }
                
                console.log('‚úÖ Skeleton group found for manual sync test');
                
                // Test setting VRM position manually
                console.log('üß™ Testing manual VRM positioning...');
                
                // Test position: move VRM to a specific location
                const testPosition = new THREE.Vector3(0.5, 0.2, 0.3);
                const testRotation = new THREE.Euler(0.1, 0.2, 0.0);
                
                let vrmRoot = null;
                if (vrmCharacter.vrm && vrmCharacter.vrm.scene) {
                    vrmRoot = vrmCharacter.vrm.scene;
                } else if (vrmCharacter.scene) {
                    vrmRoot = vrmCharacter.scene;
                } else {
                    vrmRoot = vrmCharacter;
                }
                
                console.log('üéØ VRM root object:', vrmRoot);
                console.log('üéØ VRM root type:', vrmRoot ? vrmRoot.constructor.name : 'null');
                
                if (vrmRoot) {
                    const beforePos = vrmRoot.position.clone();
                    const beforeRot = vrmRoot.rotation.clone();
                    
                    // Apply test transform
                    vrmRoot.position.copy(testPosition);
                    vrmRoot.rotation.copy(testRotation);
                    vrmRoot.rotation.order = 'YXZ';
                    
                    const afterPos = vrmRoot.position.clone();
                    const afterRot = vrmRoot.rotation.clone();
                    
                    console.log('üìç Manual VRM positioning test:', {
                        beforePosition: beforePos,
                        afterPosition: afterPos,
                        beforeRotation: beforeRot,
                        afterRotation: afterRot,
                        positionChanged: !beforePos.equals(afterPos),
                        rotationChanged: !beforeRot.equals(afterRot)
                    });
                    
                    // Wait 2 seconds, then copy skeleton position to VRM
                    setTimeout(() => {
                        console.log('üß™ Testing skeleton-to-VRM copy...');
                        
                        const skeletonPos = skeletonGroup.position.clone();
                        const skeletonRot = skeletonGroup.rotation.clone();
                        
                        vrmRoot.position.copy(skeletonPos);
                        vrmRoot.rotation.copy(skeletonRot);
                        vrmRoot.rotation.order = 'YXZ';
                        
                        console.log('‚úÖ Copied skeleton transform to VRM:', {
                            skeletonPosition: skeletonPos,
                            skeletonRotation: skeletonRot,
                            vrmPosition: vrmRoot.position,
                            vrmRotation: vrmRoot.rotation
                        });
                        
                    }, 2000);
                    
                    return 'Manual VRM sync test started - check console for results';
                } else {
                    console.log('‚ùå Could not find VRM root object');
                    return 'Could not find VRM root object';
                }
            };

            // ======= RESTORE ORIGINAL VRM ADAPTER =======
            window.restoreVRMAdapter = function() {
                console.log('üîÑ Restoring original VRM adapter behavior...');
                console.log('‚ö†Ô∏è RESTORING ALL DISABLED ANIMATION FUNCTIONS');
                
                // Restore VRM adapter method
                if (window.currentVRMAdapter && window.originalFunctions?.vrmAdapterApply) {
                    window.currentVRMAdapter.applyBVHFrameToVRM = window.originalFunctions.vrmAdapterApply;
                    delete window.originalFunctions.vrmAdapterApply;
                    console.log('‚úÖ VRM adapter method restored');
                }
                
                // Restore applyBVHFrameToVRMDirect
                if (window.originalFunctions?.applyBVHFrameToVRMDirect) {
                    window.applyBVHFrameToVRMDirect = window.originalFunctions.applyBVHFrameToVRMDirect;
                    delete window.originalFunctions.applyBVHFrameToVRMDirect;
                    console.log('‚úÖ applyBVHFrameToVRMDirect restored');
                }
                
                // Restore characterSystem.applyBVHFrame
                if (characterSystem && window.originalFunctions?.characterSystemApply) {
                    characterSystem.applyBVHFrame = window.originalFunctions.characterSystemApply;
                    delete window.originalFunctions.characterSystemApply;
                    console.log('‚úÖ characterSystem.applyBVHFrame restored');
                }
                
                // Restore applyBVHFrameToSkeleton
                if (window.originalFunctions?.applyBVHFrameToSkeleton) {
                    window.applyBVHFrameToSkeleton = window.originalFunctions.applyBVHFrameToSkeleton;
                    delete window.originalFunctions.applyBVHFrameToSkeleton;
                    console.log('‚úÖ applyBVHFrameToSkeleton restored');
                }
                
                console.log('ÔøΩ === RESTORATION COMPLETE ===');
                console.log('üí° All original animation functions restored');
                console.log('‚ö†Ô∏è VRM and skeleton may now animate independently again');
                
                statusDiv.textContent = 'All original animation functions restored';
                
                return 'All animation functions restored - VRM and skeleton independent again';
            };

            // === T-POSE AND ANIMATION DEBUGGING FUNCTIONS ===
            
            window.debugTPoseCorrections = function() {
                console.log('ü§ñ === T-POSE CORRECTIONS DEBUG ===');
                
                if (window.currentVRMAdapter) {
                    console.log('VRM Adapter found, checking T-pose behavior...');
                    
                    // Check if T-pose corrections are being applied
                    const adapter = window.currentVRMAdapter;
                    console.log('- VRM adapter exists:', !!adapter);
                    console.log('- VRM character exists:', !!adapter.vrmCharacter);
                    console.log('- Bone mapping exists:', !!adapter.boneMapping);
                    
                    if (adapter.boneMapping) {
                        console.log('- Bone mapping count:', Object.keys(adapter.boneMapping).length);
                        
                        // Check a few key bones to see if they're moving
                        const testBones = ['hips', 'spine', 'leftUpperArm', 'rightUpperArm', 'leftUpperLeg', 'rightUpperLeg'];
                        console.log('Testing key bone rotations:');
                        
                        testBones.forEach(boneName => {
                            const bone = adapter.boneMapping[boneName];
                            if (bone) {
                                console.log(`  ${boneName}:`, {
                                    rotation: bone.rotation,
                                    quaternion: bone.quaternion,
                                    position: bone.position
                                });
                            } else {
                                console.log(`  ${boneName}: NOT FOUND in bone mapping`);
                            }
                        });
                    }
                    
                    // Check if the adapter has T-pose correction settings
                    if (adapter.applyBVHFrameToVRM) {
                        console.log('- applyBVHFrameToVRM method exists');
                        
                        // Test with current frame data
                        if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                            const currentFrameIndex = Math.floor(animationFrame) % bvhData[currentAnimation].frames.length;
                            const frameData = bvhData[currentAnimation].frames[currentFrameIndex];
                            console.log('- Current frame data (first 12 values):', frameData.slice(0, 12));
                            console.log('- Frame data length:', frameData.length);
                        }
                    }
                } else {
                    console.log('‚ùå No VRM adapter found');
                }
                
                return 'T-pose debug complete - check console for details';
            };
            
            window.toggleTPoseCorrections = function() {
                console.log('üö´ Attempting to disable T-pose corrections...');
                
                if (window.currentVRMAdapter) {
                    // Try to find and disable T-pose corrections
                    const adapter = window.currentVRMAdapter;
                    
                    // Look for T-pose related properties/flags
                    console.log('Searching for T-pose correction flags...');
                    
                    // Common T-pose correction flags that might exist
                    const tPoseFlags = ['enableTPoseCorrection', 'applyTPoseCorrection', 'tPoseCorrection', 'restPose', 'bindPose'];
                    
                    tPoseFlags.forEach(flag => {
                        if (adapter.hasOwnProperty(flag)) {
                            console.log(`Found flag: ${flag} = ${adapter[flag]}`);
                            if (typeof adapter[flag] === 'boolean') {
                                adapter[flag] = false;
                                console.log(`Disabled: ${flag} = ${adapter[flag]}`);
                            }
                        }
                    });
                    
                    // Try to create a version of applyBVHFrameToVRM that skips T-pose corrections
                    if (adapter.applyBVHFrameToVRM) {
                        console.log('Creating T-pose correction bypass...');
                        
                        // Store original method
                        adapter.originalApplyBVHFrameToVRM = adapter.applyBVHFrameToVRM;
                        
                        // Replace with a version that logs what it's doing
                        adapter.applyBVHFrameToVRM = function(frameData) {
                            console.log('üé≠ BYPASS: Applying BVH frame WITHOUT T-pose corrections');
                            console.log('Frame data:', frameData.slice(0, 6));
                            
                            // Try to apply just the basic transformations without corrections
                            if (this.boneMapping && frameData.length >= 6) {
                                // Apply root position and rotation only
                                const rootBone = this.boneMapping['hips'] || this.boneMapping['Hips'];
                                if (rootBone && this.vrmCharacter) {
                                    const rootPosX = frameData[0] * 0.01; // Convert cm to meters
                                    const rootPosY = frameData[1] * 0.01;
                                    const rootPosZ = frameData[2] * 0.01;
                                    
                                    const rootRotY = frameData[3] * Math.PI / 180; // Convert degrees to radians
                                    const rootRotX = frameData[4] * Math.PI / 180;
                                    const rootRotZ = frameData[5] * Math.PI / 180;
                                    
                                    // Apply to VRM character root
                                    this.vrmCharacter.position.set(rootPosX, rootPosY - 0.98, rootPosZ);
                                    this.vrmCharacter.rotation.set(rootRotX, rootRotY, rootRotZ);
                                    
                                    console.log('Applied basic transform:', {
                                        position: this.vrmCharacter.position,
                                        rotation: this.vrmCharacter.rotation
                                    });
                                }
                            }
                        };
                        
                        statusDiv.textContent = 'T-pose corrections BYPASSED - testing basic transforms only';
                    }
                } else {
                    console.log('‚ùå No VRM adapter to modify');
                    statusDiv.textContent = 'No VRM adapter found';
                }
                
                return 'T-pose correction bypass attempted';
            };
            
            window.testWithoutVRMAdapter = function() {
                console.log('üé≠ Testing animation WITHOUT VRM adapter...');
                
                // Temporarily disable VRM adapter and show skeleton instead
                if (window.currentVRMAdapter) {
                    window.vrmAdapterBackup = window.currentVRMAdapter;
                    window.currentVRMAdapter = null;
                    console.log('VRM adapter temporarily disabled');
                }
                
                // Show skeleton for comparison
                if (skeletonGroup) {
                    skeletonGroup.visible = true;
                    console.log('Skeleton made visible');
                }
                
                // Hide VRM character temporarily
                if (characterSystem && characterSystem.vrmCharacter) {
                    characterSystem.vrmCharacter.visible = false;
                    console.log('VRM character hidden');
                }
                
                statusDiv.textContent = 'Testing with skeleton only - VRM adapter disabled';
                
                return 'Now testing with skeleton only - VRM adapter disabled';
            };
            
            window.compareSkeletonVRM = function() {
                console.log('‚öñÔ∏è Comparing skeleton and VRM animation...');
                
                // Show both skeleton and VRM character
                if (skeletonGroup) {
                    skeletonGroup.visible = true;
                    // Make skeleton more visible with bright colors
                    Object.values(jointMeshes).forEach(joint => {
                        if (joint && joint.material) {
                            joint.material.color.setHex(0xff0000); // Red joints
                            joint.material.emissive.setHex(0x330000);
                        }
                    });
                    boneCylinders.forEach(bone => {
                        if (bone && bone.material) {
                            bone.material.color.setHex(0x00ff00); // Green bones
                            bone.material.emissive.setHex(0x003300);
                        }
                    });
                    console.log('Skeleton made visible with bright colors');
                }
                
                // Restore VRM adapter if it was disabled
                if (window.vrmAdapterBackup) {
                    window.currentVRMAdapter = window.vrmAdapterBackup;
                    window.vrmAdapterBackup = null;
                    console.log('VRM adapter restored');
                }
                
                // Show VRM character
                if (characterSystem && characterSystem.vrmCharacter) {
                    characterSystem.vrmCharacter.visible = true;
                    console.log('VRM character shown');
                }
                
                statusDiv.textContent = 'Comparing both: Red/Green skeleton + VRM character';
                
                return 'Both skeleton and VRM character now visible for comparison';
            };
            
            window.restoreTPoseCorrections = function() {
                console.log('üîÑ Restoring original T-pose corrections...');
                
                if (window.currentVRMAdapter && window.currentVRMAdapter.originalApplyBVHFrameToVRM) {
                    window.currentVRMAdapter.applyBVHFrameToVRM = window.currentVRMAdapter.originalApplyBVHFrameToVRM;
                    delete window.currentVRMAdapter.originalApplyBVHFrameToVRM;
                    console.log('Original T-pose corrections restored');
                    statusDiv.textContent = 'T-pose corrections RESTORED to original behavior';
                } else {
                    console.log('No backup found or no VRM adapter');
                    statusDiv.textContent = 'No T-pose correction backup found';
                }
                
                return 'T-pose corrections restored';
            };
            
            // Global flag for detailed animation debugging
            window.debugAnimationEnabled = false;
            
            window.toggleAnimationDebug = function() {
                window.debugAnimationEnabled = !window.debugAnimationEnabled;
                console.log(`üîß Animation debugging ${window.debugAnimationEnabled ? 'ENABLED' : 'DISABLED'}`);
                statusDiv.textContent = `Animation debugging: ${window.debugAnimationEnabled ? 'ON' : 'OFF'}`;
                return `Animation debugging ${window.debugAnimationEnabled ? 'enabled' : 'disabled'}`;
            };
            
            window.testSingleFrame = function() {
                console.log('üéØ Testing single frame application...');
                
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const testFrameIndex = Math.floor(bvhData[currentAnimation].frames.length / 4); // Test 25% through animation
                    const testFrame = bvhData[currentAnimation].frames[testFrameIndex];
                    
                    console.log('Test frame data:', {
                        frameIndex: testFrameIndex,
                        totalFrames: bvhData[currentAnimation].frames.length,
                        rootPos: testFrame.slice(0, 3),
                        rootRot: testFrame.slice(3, 6),
                        firstJointRots: testFrame.slice(6, 12)
                    });
                    
                    // Test with VRM adapter
                    if (window.currentVRMAdapter) {
                        console.log('Testing with VRM adapter...');
                        
                        // Store current position for comparison
                        const beforePos = window.currentVRMAdapter.vrmCharacter ? 
                            window.currentVRMAdapter.vrmCharacter.position.clone() : 'No VRM character';
                        const beforeRot = window.currentVRMAdapter.vrmCharacter ? 
                            window.currentVRMAdapter.vrmCharacter.rotation.clone() : 'No VRM character';
                        
                        console.log('Before application:', { position: beforePos, rotation: beforeRot });
                        
                        try {
                            const result = window.currentVRMAdapter.applyBVHFrameToVRM(testFrame);
                            
                            const afterPos = window.currentVRMAdapter.vrmCharacter ? 
                                window.currentVRMAdapter.vrmCharacter.position.clone() : 'No VRM character';
                            const afterRot = window.currentVRMAdapter.vrmCharacter ? 
                                window.currentVRMAdapter.vrmCharacter.rotation.clone() : 'No VRM character';
                            
                            console.log('After application:', { position: afterPos, rotation: afterRot });
                            console.log('Position changed:', beforePos && afterPos ? !beforePos.equals(afterPos) : 'Unknown');
                            console.log('Rotation changed:', beforeRot && afterRot ? !beforeRot.equals(afterRot) : 'Unknown');
                            
                        } catch (error) {
                            console.error('Error applying test frame:', error);
                        }
                    }
                    
                    // Test with skeleton for comparison
                    if (skeletonGroup && skeletonGroup.visible) {
                        console.log('Testing with skeleton...');
                        // Apply to skeleton to see if BVH data is actually changing
                        applyBVHFrame(testFrame);
                    }
                } else {
                    console.log('‚ùå No BVH data available for testing');
                }
                
                return 'Single frame test complete - check console for details';
            };
            
            // === MINIMAL VRM ANIMATION TEST (NO T-POSE CORRECTIONS) ===
            
            // First, let's add a comprehensive VRM discovery function
            window.findVRMCharacter = function() {
                console.log('üîç === VRM CHARACTER DISCOVERY ===');
                
                let vrmCharacter = null;
                let vrmSource = 'none';
                
                // Check window.currentVRMAdapter
                if (window.currentVRMAdapter && window.currentVRMAdapter.vrmCharacter) {
                    vrmCharacter = window.currentVRMAdapter.vrmCharacter;
                    vrmSource = 'window.currentVRMAdapter';
                    console.log('‚úÖ Found VRM via window.currentVRMAdapter');
                }
                
                // Check characterSystem.vrmCharacter
                if (!vrmCharacter && characterSystem && characterSystem.vrmCharacter) {
                    vrmCharacter = characterSystem.vrmCharacter;
                    vrmSource = 'characterSystem.vrmCharacter';
                    console.log('‚úÖ Found VRM via characterSystem.vrmCharacter');
                }
                
                // Check window.vrmCharacter
                if (!vrmCharacter && window.vrmCharacter) {
                    vrmCharacter = window.vrmCharacter;
                    vrmSource = 'window.vrmCharacter';
                    console.log('‚úÖ Found VRM via window.vrmCharacter');
                }
                
                // Check characterSystem.vrmAdapter
                if (!vrmCharacter && characterSystem && characterSystem.vrmAdapter && characterSystem.vrmAdapter.vrmCharacter) {
                    vrmCharacter = characterSystem.vrmAdapter.vrmCharacter;
                    vrmSource = 'characterSystem.vrmAdapter.vrmCharacter';
                    console.log('‚úÖ Found VRM via characterSystem.vrmAdapter.vrmCharacter');
                }
                
                // Search scene for VRM objects
                if (!vrmCharacter && scene) {
                    scene.traverse((child) => {
                        if (child.userData && child.userData.vrm) {
                            vrmCharacter = child;
                            vrmSource = 'scene.traverse (userData.vrm)';
                            console.log('‚úÖ Found VRM in scene via userData.vrm');
                        }
                        if (!vrmCharacter && child.isVRM) {
                            vrmCharacter = child;
                            vrmSource = 'scene.traverse (isVRM)';
                            console.log('‚úÖ Found VRM in scene via isVRM property');
                        }
                    });
                }
                
                console.log('VRM Character found:', !!vrmCharacter, 'from', vrmSource);
                if (vrmCharacter) {
                    console.log('VRM object type:', vrmCharacter.constructor.name);
                    console.log('VRM has vrm property:', !!vrmCharacter.vrm);
                    console.log('VRM has scene property:', !!vrmCharacter.scene);
                    console.log('VRM visible:', vrmCharacter.visible);
                    if (vrmCharacter.vrm) {
                        console.log('VRM humanoid bones:', vrmCharacter.vrm.humanoid ? Object.keys(vrmCharacter.vrm.humanoid.humanBones) : 'No humanoid');
                    }
                }
                
                return { vrmCharacter, vrmSource };
            };
            
            window.diagnoseVRMAnimation = function() {
                console.log('üîç === VRM ANIMATION DIAGNOSIS ===');
                
                // Check character system
                console.log('Character System:');
                console.log('- characterSystem exists:', !!characterSystem);
                if (characterSystem) {
                    console.log('- applyBVHFrame method:', typeof characterSystem.applyBVHFrame);
                    console.log('- vrmAdapter exists:', !!characterSystem.vrmAdapter);
                    console.log('- vrmCharacter exists:', !!characterSystem.vrmCharacter);
                }
                
                // Check VRM adapters
                console.log('\nVRM Adapters:');
                console.log('- window.currentVRMAdapter exists:', !!window.currentVRMAdapter);
                console.log('- characterSystem.vrmAdapter exists:', !!(characterSystem && characterSystem.vrmAdapter));
                
                if (characterSystem && characterSystem.vrmAdapter) {
                    const adapter = characterSystem.vrmAdapter;
                    console.log('- Adapter type:', adapter.constructor.name);
                    console.log('- applyBVHFrameToVRM method:', typeof adapter.applyBVHFrameToVRM);
                    console.log('- VRM character in adapter:', !!adapter.vrmCharacter);
                    console.log('- Bone mapping exists:', !!adapter.boneMapping);
                    
                    if (adapter.boneMapping) {
                        console.log('- Bone mapping keys:', Object.keys(adapter.boneMapping));
                    }
                }
                
                // Check if VRM is visible in scene
                console.log('\nVRM in Scene:');
                let vrmFound = false;
                scene.traverse((child) => {
                    if (child.userData && child.userData.vrm) {
                        console.log('- VRM found in scene:', child.name || 'unnamed');
                        console.log('- VRM visible:', child.visible);
                        console.log('- VRM position:', child.position);
                        vrmFound = true;
                    }
                });
                
                if (!vrmFound) {
                    console.log('- No VRM objects found in scene');
                }
                
                return 'VRM animation diagnosis complete';
            };
            
            window.testDirectVRMAnimation = function() {
                console.log('üé≠ === TESTING DIRECT VRM ANIMATION ===');
                
                // Find VRM character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found');
                    return 'No VRM character found';
                }
                
                if (!bvhData[currentAnimation] || !bvhData[currentAnimation].frames.length) {
                    console.log('‚ùå No BVH data available');
                    return 'No BVH data available';
                }
                
                console.log('‚úÖ Testing DIRECT VRM animation without adapters...');
                
                // Get VRM root object
                const vrmRoot = vrmCharacter.vrm ? vrmCharacter.vrm.scene : vrmCharacter;
                
                console.log('VRM root object:', vrmRoot);
                console.log('VRM humanoid bones available:', vrmCharacter.vrm?.humanoid?.humanBones ? Object.keys(vrmCharacter.vrm.humanoid.humanBones) : 'No humanoid bones');
                
                // Make VRM very visible for testing
                vrmRoot.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.color && mat.color.setHex) {
                                    mat.color.setHex(0x00ff00); // Bright green
                                }
                                if (mat.emissive && mat.emissive.setHex) {
                                    mat.emissive.setHex(0x004400);
                                }
                            });
                        } else {
                            if (child.material.color && child.material.color.setHex) {
                                child.material.color.setHex(0x00ff00); // Bright green
                            }
                            if (child.material.emissive && child.material.emissive.setHex) {
                                child.material.emissive.setHex(0x004400);
                            }
                        }
                    }
                });
                
                // Test frames
                const frames = bvhData[currentAnimation].frames;
                const testFrameIndex = Math.min(100, Math.floor(frames.length / 4));
                
                console.log(`Testing VRM with frame ${testFrameIndex} out of ${frames.length} frames`);
                
                // Apply root movement directly to VRM
                let testFrameCounter = 0;
                const vrmTestInterval = setInterval(() => {
                    testFrameCounter++;
                    const currentTestFrame = frames[(testFrameIndex + testFrameCounter) % frames.length];
                    
                    // Apply root transform directly to VRM
                    const rootPosX = currentTestFrame[0] * 0.01;
                    const rootPosY = currentTestFrame[1] * 0.01;
                    const rootPosZ = currentTestFrame[2] * 0.01;
                    
                    const rootRotX = currentTestFrame[3] * Math.PI / 180;
                    const rootRotY = currentTestFrame[4] * Math.PI / 180;
                    const rootRotZ = currentTestFrame[5] * Math.PI / 180;
                    
                    // Move VRM character directly
                    vrmRoot.position.set(rootPosX, rootPosY - 0.98, rootPosZ);
                    vrmRoot.rotation.set(rootRotX, rootRotY, rootRotZ);
                    vrmRoot.rotation.order = 'YXZ';
                    
                    console.log(`VRM test frame ${testFrameCounter}: pos(${rootPosX.toFixed(2)}, ${(rootPosY-0.98).toFixed(2)}, ${rootPosZ.toFixed(2)})`);
                    
                    if (testFrameCounter >= 60) {
                        clearInterval(vrmTestInterval);
                        console.log('üé≠ Direct VRM animation test complete');
                        statusDiv.textContent = 'VRM direct test complete - did character move?';
                    }
                }, 50); // 20 FPS
                
                statusDiv.textContent = 'Testing direct VRM animation...';
                return 'Direct VRM animation test started';
            };
            
            window.testSkeletonAnimation = function() {
                console.log('ü¶¥ === TESTING SKELETON ANIMATION ===');
                
                if (!bvhData[currentAnimation] || !bvhData[currentAnimation].frames.length) {
                    console.log('‚ùå No BVH data available');
                    return 'No BVH data available';
                }
                
                if (!jointMeshes || Object.keys(jointMeshes).length === 0) {
                    console.log('‚ùå No skeleton joints available');
                    return 'No skeleton joints available';
                }
                
                console.log('‚úÖ Skeleton joints available:', Object.keys(jointMeshes));
                console.log('‚úÖ BVH frames available:', bvhData[currentAnimation].frames.length);
                
                // Make skeleton visible and bright for testing
                if (skeletonGroup) {
                    skeletonGroup.visible = true;
                    Object.values(jointMeshes).forEach(joint => {
                        if (joint && joint.material) {
                            joint.material.color.setHex(0x00ffff); // Cyan for visibility
                            joint.material.emissive.setHex(0x004444); // Bright emissive
                        }
                    });
                    boneCylinders.forEach(bone => {
                        if (bone && bone.material) {
                            bone.material.color.setHex(0xff00ff); // Magenta for bones
                            bone.material.emissive.setHex(0x440044);
                        }
                    });
                }
                
                // Test frame (use frame 100 which should show clear movement)
                const frames = bvhData[currentAnimation].frames;
                const testFrameIndex = Math.min(100, Math.floor(frames.length / 4));
                const testFrame = frames[testFrameIndex];
                
                console.log(`Testing skeleton with frame ${testFrameIndex}:`, testFrame.slice(0, 12));
                
                // Apply the frame directly to the skeleton
                try {
                    applyBVHFrameToSkeleton(testFrame);
                    console.log('‚úÖ Frame applied to skeleton successfully');
                    
                    // Animate for a few frames to show movement
                    let testFrameCounter = 0;
                    const skeletonTestInterval = setInterval(() => {
                        testFrameCounter++;
                        const currentTestFrame = frames[(testFrameIndex + testFrameCounter) % frames.length];
                        applyBVHFrameToSkeleton(currentTestFrame);
                        
                        console.log(`Skeleton test frame ${testFrameCounter}: root pos(${currentTestFrame[0].toFixed(1)}, ${currentTestFrame[1].toFixed(1)}, ${currentTestFrame[2].toFixed(1)})`);
                        
                        if (testFrameCounter >= 60) { // Test for 60 frames (1 second at 60fps)
                            clearInterval(skeletonTestInterval);
                            console.log('ü¶¥ Skeleton animation test complete - joints should have moved!');
                            statusDiv.textContent = 'Skeleton test complete - check if joints moved!';
                        }
                    }, 50); // 20 FPS for clear observation
                    
                    statusDiv.textContent = 'Testing skeleton animation...';
                    return 'Skeleton animation test started';
                    
                } catch (error) {
                    console.error('‚ùå Failed to apply frame to skeleton:', error);
                    return 'Failed to animate skeleton: ' + error.message;
                }
            };
            
            window.testMinimalVRMAnimation = function() {
                console.log('üß™ === MINIMAL VRM ANIMATION TEST ===');
                console.log('Testing VRM animation with ZERO T-pose corrections...');
                
                // Use the discovery function to find VRM character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found anywhere');
                    console.log('Available objects:');
                    console.log('- window.currentVRMAdapter:', !!window.currentVRMAdapter);
                    console.log('- characterSystem:', !!characterSystem);
                    console.log('- characterSystem.vrmCharacter:', !!(characterSystem && characterSystem.vrmCharacter));
                    console.log('- window.vrmCharacter:', !!window.vrmCharacter);
                    return 'No VRM character available';
                }
                
                if (!bvhData[currentAnimation] || !bvhData[currentAnimation].frames.length) {
                    console.log('‚ùå No BVH data available');
                    return 'No BVH data available';
                }
                
                if (!bvhData[currentAnimation] || !bvhData[currentAnimation].frames.length) {
                    console.log('‚ùå No BVH data available');
                    return 'No BVH data available';
                }
                
                const frames = bvhData[currentAnimation].frames;
                
                console.log('VRM character found from:', vrmDiscovery.vrmSource);
                console.log('VRM character name:', vrmCharacter.name || 'unnamed');
                console.log('Available frames:', frames.length);
                
                // Store original position for comparison
                const originalPos = vrmCharacter.position.clone();
                const originalRot = vrmCharacter.rotation.clone();
                
                console.log('Original VRM position:', originalPos);
                console.log('Original VRM rotation:', originalRot);
                
                // Test frame (use frame 100 which should show clear movement)
                const testFrameIndex = Math.min(100, Math.floor(frames.length / 4));
                const testFrame = frames[testFrameIndex];
                
                console.log(`Testing with frame ${testFrameIndex}:`, testFrame.slice(0, 6));
                
                // Apply ONLY root transform (no T-pose corrections, no bone mapping)
                const rootPosX = testFrame[0] * 0.01; // Convert cm to meters
                const rootPosY = testFrame[1] * 0.01;
                const rootPosZ = testFrame[2] * 0.01;
                
                const rootRotX = testFrame[3] * Math.PI / 180; // Convert degrees to radians
                const rootRotY = testFrame[4] * Math.PI / 180;
                const rootRotZ = testFrame[5] * Math.PI / 180;
                
                // Apply minimal transform - just move the entire VRM character
                vrmCharacter.position.set(rootPosX, rootPosY - 0.98, rootPosZ); // Offset for hip height
                vrmCharacter.rotation.set(rootRotX, rootRotY, rootRotZ);
                vrmCharacter.rotation.order = 'YXZ';
                
                const newPos = vrmCharacter.position.clone();
                const newRot = vrmCharacter.rotation.clone();
                
                console.log('New VRM position:', newPos);
                console.log('New VRM rotation:', newRot);
                
                const posChanged = !originalPos.equals(newPos);
                const rotChanged = !originalRot.equals(newRot);
                
                console.log('Position changed:', posChanged);
                console.log('Rotation changed:', rotChanged);
                
                if (posChanged || rotChanged) {
                    console.log('‚úÖ SUCCESS: VRM character moved with minimal transform!');
                    statusDiv.textContent = 'SUCCESS: VRM moved with basic transform only';
                    
                    // Now test if we can see the movement by animating for a few frames
                    let frameCounter = 0;
                    const animateTestInterval = setInterval(() => {
                        frameCounter++;
                        const currentTestFrame = frames[(testFrameIndex + frameCounter) % frames.length];
                        
                        const posX = currentTestFrame[0] * 0.01;
                        const posY = currentTestFrame[1] * 0.01;
                        const posZ = currentTestFrame[2] * 0.01;
                        
                        const rotX = currentTestFrame[3] * Math.PI / 180;
                        const rotY = currentTestFrame[4] * Math.PI / 180;
                        const rotZ = currentTestFrame[5] * Math.PI / 180;
                        
                        vrmCharacter.position.set(posX, posY - 0.98, posZ);
                        vrmCharacter.rotation.set(rotX, rotY, rotZ);
                        
                        console.log(`Test frame ${frameCounter}: pos(${posX.toFixed(2)}, ${(posY-0.98).toFixed(2)}, ${posZ.toFixed(2)}) rot(${(rotX*180/Math.PI).toFixed(1)}¬∞, ${(rotY*180/Math.PI).toFixed(1)}¬∞, ${(rotZ*180/Math.PI).toFixed(1)}¬∞)`);
                        
                        if (frameCounter >= 30) { // Test for 30 frames
                            clearInterval(animateTestInterval);
                            console.log('üé¨ Minimal animation test complete - check if character moved');
                            statusDiv.textContent = 'Minimal test complete - did character move?';
                        }
                    }, 100); // 10 FPS for easier observation
                    
                } else {
                    console.log('‚ùå FAILED: VRM character did not move even with basic transform');
                    statusDiv.textContent = 'FAILED: VRM did not respond to basic transform';
                }
                
                return posChanged || rotChanged ? 'VRM responded to basic transform' : 'VRM did not respond';
            };
            
            window.permanentlyDisableTPose = function() {
                console.log('üö´ === PERMANENTLY DISABLING T-POSE CORRECTIONS ===');
                
                // Use VRM discovery to find the character
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found to disable T-pose on');
                    return 'No VRM character found';
                }
                
                console.log('üéØ Found VRM character via:', vrmDiscovery.vrmSource);
                
                // Try to find the VRM adapter
                let vrmAdapter = null;
                if (window.currentVRMAdapter) {
                    vrmAdapter = window.currentVRMAdapter;
                } else if (characterSystem && characterSystem.vrmAdapter) {
                    vrmAdapter = characterSystem.vrmAdapter;
                }
                
                if (vrmAdapter) {
                    console.log('üîß Disabling T-pose corrections in VRM adapter...');
                    
                    // Create a completely stripped down version that only applies root transforms
                    vrmAdapter.originalApplyBVHFrameToVRM = vrmAdapter.applyBVHFrameToVRM;
                    
                    vrmAdapter.applyBVHFrameToVRM = function(frameData) {
                        console.log('üé≠ STRIPPED VRM ADAPTER: NO T-POSE CORRECTIONS');
                        
                        if (!this.vrmCharacter || !frameData || frameData.length < 6) {
                            return;
                        }
                        
                        // ONLY apply root position and rotation - NO bone mapping, NO T-pose corrections
                        const rootPosX = frameData[0] * 0.01; // cm to meters
                        const rootPosY = frameData[1] * 0.01;
                        const rootPosZ = frameData[2] * 0.01;
                        
                        const rootRotX = frameData[3] * Math.PI / 180; // degrees to radians
                        const rootRotY = frameData[4] * Math.PI / 180;
                        const rootRotZ = frameData[5] * Math.PI / 180;
                        
                        // Apply to VRM character root
                        this.vrmCharacter.position.set(rootPosX, rootPosY - 0.98, rootPosZ);
                        this.vrmCharacter.rotation.set(rootRotX, rootRotY, rootRotZ);
                        this.vrmCharacter.rotation.order = 'YXZ';
                        
                        // Log every 60 frames to see if it's working
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log(`üé≠ ROOT-ONLY transform applied: pos(${rootPosX.toFixed(2)}, ${(rootPosY-0.98).toFixed(2)}, ${rootPosZ.toFixed(2)}) rot(${(rootRotX*180/Math.PI).toFixed(1)}¬∞, ${(rootRotY*180/Math.PI).toFixed(1)}¬∞, ${(rotZ*180/Math.PI).toFixed(1)}¬∞)`);
                        }
                    };
                    
                    console.log('‚úÖ T-pose corrections PERMANENTLY DISABLED');
                    console.log('üìç VRM will now ONLY move with root transforms from BVH data');
                    statusDiv.textContent = 'T-pose corrections DISABLED - VRM uses root transforms only';
                    
                } else {
                    console.log('‚ùå No VRM adapter found');
                    statusDiv.textContent = 'No VRM adapter found';
                }
                
                return 'T-pose corrections permanently disabled';
            };
            
            window.enableBoneAnimation = function() {
                console.log('ü¶¥ === ENABLING BONE ANIMATION (NO T-POSE) ===');
                
                // Use VRM discovery to find the character and adapter
                const vrmDiscovery = window.findVRMCharacter();
                const vrmCharacter = vrmDiscovery.vrmCharacter;
                
                if (!vrmCharacter) {
                    console.log('‚ùå No VRM character found for bone animation');
                    return 'No VRM character found';
                }
                
                // Try to find the VRM adapter
                let vrmAdapter = null;
                if (window.currentVRMAdapter) {
                    vrmAdapter = window.currentVRMAdapter;
                } else if (characterSystem && characterSystem.vrmAdapter) {
                    vrmAdapter = characterSystem.vrmAdapter;
                }
                
                if (vrmAdapter && vrmAdapter.boneMapping) {
                    console.log('ü¶¥ Enabling bone animation with bone mapping...');
                    
                    vrmAdapter.applyBVHFrameToVRM = function(frameData) {
                        if (!this.vrmCharacter || !frameData || frameData.length < 6) {
                            return;
                        }
                        
                        // Apply root transform
                        const rootPosX = frameData[0] * 0.01;
                        const rootPosY = frameData[1] * 0.01;
                        const rootPosZ = frameData[2] * 0.01;
                        
                        const rootRotX = frameData[3] * Math.PI / 180;
                        const rootRotY = frameData[4] * Math.PI / 180;
                        const rootRotZ = frameData[5] * Math.PI / 180;
                        
                        this.vrmCharacter.position.set(rootPosX, rootPosY - 0.98, rootPosZ);
                        this.vrmCharacter.rotation.set(rootRotX, rootRotY, rootRotZ);
                        this.vrmCharacter.rotation.order = 'YXZ';
                        
                        // Apply bone rotations WITHOUT T-pose corrections
                        if (this.boneMapping && frameData.length > 6) {
                            let channelIndex = 6; // Skip root channels
                            
                            // Simple bone mapping without T-pose corrections
                            const boneNames = ['spine', 'chest', 'neck', 'head', 'leftUpperArm', 'leftLowerArm', 'rightUpperArm', 'rightLowerArm', 'leftUpperLeg', 'leftLowerLeg', 'rightUpperLeg', 'rightLowerLeg'];
                            
                            boneNames.forEach(boneName => {
                                const bone = this.boneMapping[boneName];
                                if (bone && channelIndex + 2 < frameData.length) {
                                    const rotX = frameData[channelIndex] * Math.PI / 180;
                                    const rotY = frameData[channelIndex + 1] * Math.PI / 180;
                                    const rotZ = frameData[channelIndex + 2] * Math.PI / 180;
                                    
                                    // Apply rotation directly without T-pose correction
                                    bone.rotation.set(rotX, rotY, rotZ);
                                    bone.rotation.order = 'YXZ';
                                    
                                    channelIndex += 3;
                                }
                            });
                        }
                        
                        // Log progress
                        if (Math.floor(animationFrame) % 60 === 0) {
                            console.log(`ü¶¥ BONE animation applied (no T-pose): root pos(${rootPosX.toFixed(2)}, ${(rootPosY-0.98).toFixed(2)}, ${rootPosZ.toFixed(2)})`);
                        }
                    };
                    
                    console.log('‚úÖ Bone animation enabled WITHOUT T-pose corrections');
                    statusDiv.textContent = 'Bone animation enabled - no T-pose corrections';
                    
                } else {
                    console.log('‚ùå No VRM adapter or bone mapping found');
                    console.log('Available adapters:');
                    console.log('- window.currentVRMAdapter:', !!window.currentVRMAdapter);
                    console.log('- characterSystem.vrmAdapter:', !!(characterSystem && characterSystem.vrmAdapter));
                    if (vrmAdapter) {
                        console.log('- VRM adapter bone mapping:', !!vrmAdapter.boneMapping);
                    }
                    statusDiv.textContent = 'No VRM adapter or bone mapping available';
                }
                
                return 'Bone animation enabled without T-pose corrections';
            };

            // Enhanced animation loop with proper error handling - Initialize variables first
            let consecutiveErrors = 0;
            let renderErrorCount = 0;
            const maxConsecutiveErrors = 10;
            let animationHalted = false;
            let lastErrorMessage = '';
            let errorMessageCount = 0;
            let materialFixAttempted = false; // Prevent endless material fixing loops

            // Start animation loop and load first animation
            enhancedAnimate();
            
            // Load default animation
            updateLoadingStatus('Loading default animation...');
            loadAnimation('neutral_reference.bvh');
                        
            function enhancedAnimate() {
                if (animationHalted) {
                    console.log('üõë Animation halted due to persistent errors');
                    return;
                }
                            
                try {
                    requestAnimationFrame(enhancedAnimate);
                    
                    if (isPlaying) {
                        animationFrame += animationSpeed;
                        
                        // ===== COORDINATE SYSTEM AND SCALE FIXES =====
                        // Based on BVH analysis and BvhToDeepMimic settings:
                        // - BVH data is in CENTIMETERS (Y=98.43 = 98.43cm hip height)
                        // - BvhToDeepMimic scale factor 0.0254 is for inches->meters, but this data is cm
                        // - Need to convert from cm to meters: divide by 100
                        // - Hip height ~98cm should put feet at ground level (Y=0)
                        
                        const BVH_TO_METERS_SCALE = 0.01; // Convert from centimeters to meters (1cm = 0.01m)
                        const TYPICAL_HIP_HEIGHT_CM = 98.43; // From BVH data analysis
                        const TYPICAL_HIP_HEIGHT_METERS = TYPICAL_HIP_HEIGHT_CM * BVH_TO_METERS_SCALE; // ~0.98m
                        
                        // UNIFIED ANIMATION: Only use VRMBVHAdapter for character positioning
                        if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                            const frames = bvhData[currentAnimation].frames;
                            const frameIndex = Math.floor(animationFrame) % frames.length;
                            const frameData = frames[frameIndex];
                            
                            if (frameData && frameData.length >= 6) {
                                // ONLY update the skeleton for debug visualization (hidden)
                                if (skeletonGroup.visible) {
                                    const rootPosX_cm = frameData[0];
                                    const rootPosY_cm = frameData[1]; 
                                    const rootPosZ_cm = frameData[2];
                                    
                                    const rootPosX = rootPosX_cm * BVH_TO_METERS_SCALE;
                                    const rootPosY = (rootPosY_cm * BVH_TO_METERS_SCALE) - TYPICAL_HIP_HEIGHT_METERS;
                                    const rootPosZ = rootPosZ_cm * BVH_TO_METERS_SCALE;
                                    
                                    const rootRotY = frameData[3] * Math.PI / 180;
                                    const rootRotX = frameData[4] * Math.PI / 180;  
                                    const rootRotZ = frameData[5] * Math.PI / 180;
                                    
                                    skeletonGroup.position.set(rootPosX, rootPosY, rootPosZ);
                                    skeletonGroup.rotation.set(rootRotX, rootRotY, rootRotZ);
                                    skeletonGroup.rotation.order = 'YXZ';
                                }
                            }
                            
                            // PRIMARY CHARACTER ANIMATION: VRM will be animated directly by applyBVHFrameToSkeleton
                            // The VRM adapter is now bypassed to prevent T-pose corrections and coordinate transforms.
                            // The applyBVHFrameToSkeleton function will handle both skeleton and VRM animation.
                            
                            // DISABLED: characterSystem.applyBVHFrame to prevent conflicts
                            // if (characterSystem) {
                            //     characterSystem.applyBVHFrame(frameData);
                            // }
                            
                            document.getElementById('current-frame').textContent = `${frameIndex + 1}/${frames.length}`;
                        }
                    }
                    
                    // Update character system
                    if (characterSystem) {
                        try {
                            characterSystem.update();
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Character system update error:', e.message);
                        }
                    }
                    
                    // Update VRM adapter if available
                    if (window.currentVRMAdapter) {
                        try {
                            const deltaTime = 0.016; // Approximately 60 FPS
                            window.currentVRMAdapter.tick(deltaTime);
                        } catch (e) {
                            console.warn('‚ö†Ô∏è VRM adapter update error:', e.message);
                        }
                    }
                    
                    // Update camera controller
                    if (cameraController) {
                        try {
                            cameraController.update();
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Camera controller error:', e.message);
                        }
                    }
                    
                    
                    
                    // Safe rendering with error handling
                    try {
                        // Validate materials before rendering if we've had errors
                        if (consecutiveErrors > 0) {
                            scene.traverse((object) => {
                                if (object.isMesh && object.material) {
                                    if (Array.isArray(object.material)) {
                                        object.material.forEach(mat => validateAndFixMaterial(mat));
                                    } else {
                                        window.validateAndFixMaterial(object.material);
                                    }
                                }
                            });
                        }
                        
                        // Final validation pass before rendering
                        if (renderErrorCount > 0) {
                            scene.traverse((object) => {
                                if (object.isMesh && object.material) {
                                    const materials = Array.isArray(object.material) ? object.material : [object.material];
                                    materials.forEach(material => {
                                        if (material.uniforms) {
                                            Object.keys(material.uniforms).forEach(key => {
                                                const uniform = material.uniforms[key];
                                                if (uniform && uniform.value && uniform.value.isVector3) {
                                                    if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                                        uniform.value.set(0, 0, 0);
                                                    }
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        }
                        
                        renderer.render(scene, camera);
                        consecutiveErrors = 0; // Reset on successful render
                        renderErrorCount = 0;
                        materialFixAttempted = false; // Allow material fixing again if needed
                    } catch (renderError) {
                        consecutiveErrors++;
                        renderErrorCount++;
                        
                        // Track repeated error messages
                        if (renderError.message === lastErrorMessage) {
                            errorMessageCount++;
                        } else {
                            lastErrorMessage = renderError.message;
                            errorMessageCount = 1;
                        }
                        
                        console.warn(`‚ö†Ô∏è Render error #${renderErrorCount} (consecutive: ${consecutiveErrors}): ${renderError.message}`);
                        
                        // Log stack trace for first few errors to help debugging
                        if (renderErrorCount <= 3) {
                            console.error('Error stack:', renderError.stack);
                        }
                        
                        // Try different fix strategies based on error count
                        if (consecutiveErrors < maxConsecutiveErrors) {
                            if ((consecutiveErrors === 1 || consecutiveErrors === 2 || consecutiveErrors === 3) && renderError.message.includes('uniform3fv')) {
                                console.log(`üîß Attempting to fix VRM shader issues on error #${consecutiveErrors}...`);
                                try {
                                    if (typeof window.fixVRMShaders === 'function') {
                                        console.log('üîß Calling fixVRMShaders...');
                                        window.fixVRMShaders();
                                    } else {
                                        console.log('‚ùå fixVRMShaders not available');
                                    }
                                    
                                    if (typeof window.fixVRMShadersEarly === 'function') {
                                        console.log('üîß Calling fixVRMShadersEarly...');
                                        window.fixVRMShadersEarly();
                                    } else {
                                        console.log('‚ùå fixVRMShadersEarly not available');
                                    }
                                    
                                    if (typeof window.emergencyMaterialFix === 'function') {
                                        console.log('üö® Calling emergencyMaterialFix...');
                                        window.emergencyMaterialFix();
                                    } else {
                                        console.log('‚ùå emergencyMaterialFix not available');
                                    }
                                    
                                    // Apply VRM-specific shader fixes
                                    if (typeof window.fixVRMShaderErrors === 'function') {
                                        console.log('üîß Applying VRM shader error fixes...');
                                        window.fixVRMShaderErrors();
                                    }
                                    
                                    if (consecutiveErrors >= 2 && typeof window.nuclearMaterialFix === 'function') {
                                        console.log('üî• Applying nuclear material fix...');
                                        window.nuclearMaterialFix();
                                    }
                                } catch (fixError) {
                                    console.error('‚ùå Shader fix error:', fixError);
                                }
                                materialFixAttempted = true;
                            } else if (consecutiveErrors === 1) {
                                console.log('üîß Attempting to fix all scene materials...');
                                forceMaterialUpdateAndCompile();
                                materialFixAttempted = true;
                            } else if (consecutiveErrors <= 3 && !materialFixAttempted) {
                                console.log('üîß Attempting to re-initialize character system...');
                                if (characterSystem) {
                                    characterSystem.initializeTexturedSkeletonInClassroom('ichika');
                                }
                            } else if (consecutiveErrors === 4 || consecutiveErrors === 5) {
                                console.log('üö® Attempting emergency material fix...');
                                if (typeof window.emergencyMaterialFix === 'function') {
                                    window.emergencyMaterialFix();
                                }
                            } else if (consecutiveErrors === 6 || consecutiveErrors === 7) {
                                console.log('‚ò¢Ô∏è Attempting nuclear material fix...');
                                if (typeof window.nuclearMaterialFix === 'function') {
                                    window.nuclearMaterialFix();
                                }
                            } else if (consecutiveErrors <= 8) {
                                console.log('üîß Attempting to reset camera...');
                                if (cameraController) {
                                    cameraController.setCameraMode('front');
                                }
                            } else {
                                console.log('‚ö†Ô∏è No further automatic fixes. Manual intervention may be required.');
                            }
                        } else {
                            console.error(`üí• Too many consecutive render errors (${consecutiveErrors}). HALTING ANIMATION.`);
                            console.error(`Last error repeated ${errorMessageCount} times: ${lastErrorMessage}`);
                            animationHalted = true;
                            addErrorNotification();
                            return;
                        }
                    }
                    
                } catch (error) {
                    console.error('‚ùå Animation loop error:', error);
                    consecutiveErrors++;
                    
                    if (consecutiveErrors >= maxConsecutiveErrors) {
                        console.error(`üí• Too many consecutive animation errors (${consecutiveErrors}). HALTING ANIMATION.`);
                        animationHalted = true;
                        addErrorNotification();
                        return;
                    } else {
                        // Add delay to prevent rapid error loops
                        setTimeout(() => requestAnimationFrame(enhancedAnimate), 100);
                    }
                }   
            }
            
            // Global error notification function
            function addErrorNotification() {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background-color: #ff4444; color: white; padding: 10px 20px; border-radius: 5px; z-index: 1000; font-family: sans-serif;';
                errorDiv.textContent = 'Animation Halted Due to Errors. Check Console.';
                document.body.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 5000);
            }

            // Material fixing functions - ULTRA AGGRESSIVE MODE
            
            
            
            
            
                    
            
            // Force material update and compilation for all objects in the scene
            function forceMaterialUpdateAndCompile() {
                console.log('üîÑ Forcing material update and compilation for all scene objects...');
                scene.traverse((object) => {
                    if (object.isMesh) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(mat => {
                                validateAndFixMaterial(mat);
                                updateMaterialTextures(mat);
                            });
                        } else if (object.material && object.material.isMaterial) {
                            validateAndFixMaterial(object.material);
                            updateMaterialTextures(object.material);
                        }
                    }
                });
                try {
                    renderer.compile(scene, camera);
                    console.log('‚úÖ Scene materials compiled successfully.');
                } catch (e) {
                    console.warn('‚ö†Ô∏è Failed to compile scene materials:', e.message);
                }
            }
            
            // Validate and fix material to prevent shader errors
            function validateAndFixMaterial(material) {
                if (!material || !material.isMaterial) return;
                
                // Fix color properties
                if (material.color && !material.color.isColor) {
                    if (typeof material.color === 'number') {
                        material.color = new THREE.Color(material.color);
                    } else {
                        material.color = new THREE.Color(0xFFFFFF);
                    }
                }
                
                // Fix emissive properties
                if (material.emissive && !material.emissive.isColor) {
                    if (typeof material.emissive === 'number') {
                        material.emissive = new THREE.Color(material.emissive);
                    } else {
                        material.emissive = new THREE.Color(0x000000);
                    }
                }
                
                // Fix uniforms if present (for shader materials)
                if (material.uniforms) {
                    Object.keys(material.uniforms).forEach(key => {
                        const uniform = material.uniforms[key];
                        if (uniform && uniform.value !== undefined) {
                            // Fix Vector3 uniforms
                            if (uniform.value && uniform.value.isVector3) {
                                if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                    uniform.value.set(0, 0, 0);
                                }
                            }
                            // Fix Color uniforms
                            else if (uniform.value && uniform.value.isColor) {
                                if (isNaN(uniform.value.r) || isNaN(uniform.value.g) || isNaN(uniform.value.b)) {
                                    uniform.value.setRGB(1, 1, 1);
                                }
                            }
                            // Fix array uniforms
                            else if (Array.isArray(uniform.value)) {
                                uniform.value = uniform.value.map(val => {
                                    if (typeof val === 'number' && isNaN(val)) return 0;
                                    return val;
                                });
                            }
                            // Fix scalar uniforms
                            else if (typeof uniform.value === 'number' && isNaN(uniform.value)) {
                                uniform.value = 0;
                            }
                        }
                    });
                }
                
                material.needsUpdate = true;
            }
            
            // Update material textures
            function updateMaterialTextures(mat) {
                if (mat.isMaterial) {
                    if (mat.map) mat.map.needsUpdate = true;
                    if (mat.emissiveMap) mat.emissiveMap.needsUpdate = true;
                    if (mat.normalMap) mat.normalMap.needsUpdate = true;
                    if (mat.roughnessMap) mat.roughnessMap.needsUpdate = true;
                    if (mat.metalnessMap) mat.metalnessMap.needsUpdate = true;
                    if (mat.aoMap) mat.aoMap.needsUpdate = true;
                    if (mat.lightMap) mat.lightMap.needsUpdate = true;
                    if (mat.alphaMap) mat.alphaMap.needsUpdate = true;
                    if (mat.envMap) mat.envMap.needsUpdate = true;
                }
            }

            // Force material compilation for the scene
            function compileAllMaterials() {
                console.log('üîÑ Compiling all scene materials...');
                try {
                    renderer.compile(scene, camera);
                    console.log('‚úÖ Material compilation complete');
                } catch (e) {
                    console.warn('Material compilation failed:', e.message);
                    // Try alternative approach
                    scene.traverse((object) => {
                        if (object.material) {
                            try {
                                if (Array.isArray(object.material)) {
                                    object.material.forEach(mat => mat.needsUpdate = true);
                                } else {
                                    object.material.needsUpdate = true;
                                }
                            } catch (err) {
                                console.warn('Failed to update material:', err.message);
                            }
                        }
                    });
                }
            }
            
            
            
            // Replace the original animate function with enhanced version
            if (typeof animate !== 'undefined') {
                animate = enhancedAnimate;
            }
            
            // Make enhancedAnimate globally accessible
            window.enhancedAnimate = enhancedAnimate;
            
            // Log comprehensive startup summary
            console.log('üéâ RSMT Viewer initialization complete!');
            console.log('üìä System Configuration:');
            console.log('  - Shadow mapping:', renderer.shadowMap.enabled ? 'ENABLED' : 'DISABLED (VRM compatibility)');
            console.log('  - Tone mapping:', renderer.toneMapping);
            console.log('  - Output color space:', renderer.outputColorSpace);
            console.log('  - Character system:', characterSystem ? 'LOADED' : 'FAILED');
            console.log('  - Camera controller:', cameraController ? 'LOADED' : 'FAILED');
            console.log('  - VRM character:', characterSystem?.vrmCharacter ? 'LOADED' : 'NOT LOADED');
            console.log('  - Current character file:', currentCharacterFile || 'None');
            console.log('üîß Use fixVRMShaders() if you see shader errors');
            console.log('üí° Use testLighting() to check lighting setup');
            console.log('üåë Use toggleShadows() to test shadow compatibility');
            
            // Hide loading screen
            updateLoadingStatus('Complete!');
            setTimeout(() => {
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Modern RSMT Viewer Ready! Character system loaded.';
            }, 1000);
            
        } catch (error) {
            console.error('‚ùå Error loading THREE.js:', error);
            updateLoadingStatus('Error: ' + error.message);
            statusDiv.textContent = 'Error loading 3D engine';
            statusDiv.className = 'error';
            
            // Hide loading screen even on error
            setTimeout(() => {
                loadingDiv.style.display = 'none';
            }, 3000);
        }
        
        // Load and parse BVH animation files
        async function loadAnimation(filename) {
            try {
                console.log('üé¨ Loading animation:', filename);
                statusDiv.textContent = `Loading ${filename}...`;
                
                // Try to load actual BVH data
                try {
                    console.log('üì° Fetching BVH file:', `./${filename}`);
                    const response = await fetch(`./${filename}`);
                    console.log('üîç Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const bvhText = await response.text();
                        console.log('üìÑ BVH text length:', bvhText.length, 'characters');
                        
                        bvhData[filename] = parseBVHData(bvhText);
                        console.log('‚úÖ BVH data parsed for', filename, '- Frames:', bvhData[filename].frames?.length);
                        
                        currentAnimation = filename;
                        animationFrame = 0;
                        statusDiv.textContent = `Loaded ${animations[filename]?.name || filename}`;

                        // If AI mode is active, encode the style of the new animation
                        if (aiMode && aiModelManager.isInitialized) {
                            const motionSequence = aiModelManager.getMotionSequence(); // Get current motion history
                            currentTargetStyle = await aiModelManager.encodeStyle(motionSequence);
                            logInferenceEvent(`üé® New target style encoded from ${filename}`, 'success');
                        }
                        
                    } else {
                        throw new Error(`BVH file not found: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not load BVH file:', error);
                    statusDiv.textContent = `BVH load failed, using fallback animation`;
                }
                
            } catch (error) {
                console.error('‚ùå Failed to load animation:', error);
                statusDiv.textContent = 'Animation load failed';
            }
        }
        
        // Enhanced BVH parser
        function parseBVHData(bvhText) {
            const lines = bvhText.split('\n');
            let motionIndex = -1;
            let frameTimeIndex = -1;
            
            // Find MOTION section
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('MOTION')) {
                    motionIndex = i;
                    break;
                }
            }
            
            if (motionIndex === -1) {
                throw new Error('No MOTION section found in BVH');
            }
            
            // Find frame time
            for (let i = motionIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('Frame Time:')) {
                    frameTimeIndex = i;
                    break;
                }
            }
            
            // Parse frame data
            const frames = [];
            const frameTime = frameTimeIndex >= 0 ? 
                parseFloat(lines[frameTimeIndex].split(':')[1]) || 0.016667 : 0.016667;
            
            console.log('üìä Parsing BVH - Frame time:', frameTime);
            
            // Parse all frame data starting after Frame Time line
            const startLine = frameTimeIndex >= 0 ? frameTimeIndex + 1 : motionIndex + 3;
            
            for (let i = startLine; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && line.length > 0) {
                    const values = line.split(/\s+/).map(parseFloat);
                    if (values.length > 0 && !isNaN(values[0])) {
                        frames.push(values);
                    }
                }
            }
            
            console.log('üìä Parsed', frames.length, 'frames with', frames[0]?.length || 0, 'channels each');
            
            return {
                frames,
                frameTime,
                frameCount: frames.length,
                channelCount: frames[0]?.length || 0
            };
        }
        
        
       


        // Style control functions
        async function randomizeStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('üé≤ Randomizing motion style...', 'info');
            
            // Generate random style vector
            for (let i = 0; i < aiModelManager.currentStyle.length; i++) {
                aiModelManager.currentStyle[i] = (Math.random() - 0.5) * 2; // [-1, 1]
            }
            
            logInferenceEvent('‚úÖ Style randomized - motion will adapt over next few frames', 'success');
        }

        async function smoothStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('‚ú® Applying smooth/graceful style...', 'info');
            
            // Smooth, graceful style pattern
            aiModelManager.currentStyle.fill(0);
            for (let i = 0; i < 64; i++) {
                aiModelManager.currentStyle[i] = Math.sin(i * 0.1) * 0.5; // Smooth sinusoidal
            }
            
            logInferenceEvent('‚úÖ Smooth style applied', 'success');
        }

        async function aggressiveStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('üî• Applying aggressive style...', 'info');
            
            // Aggressive, sharp style pattern
            aiModelManager.currentStyle.fill(0);
            for (let i = 0; i < 64; i++) {
                aiModelManager.currentStyle[i] = Math.sign(Math.sin(i * 0.3)) * 0.8; // Sharp square wave
            }
            
            logInferenceEvent('‚úÖ Aggressive style applied', 'success');
        }

        async function analyzeCurrentMotion() {
            if (!aiModelManager.isInitialized || aiModelManager.motionHistory.length < 10) {
                logInferenceEvent('‚ö†Ô∏è Need more motion history for analysis', 'warning');
                return;
            }
            
            logInferenceEvent('üîç Analyzing current motion patterns...', 'info');
            
            // Analyze recent motion
            const recentMotion = aiModelManager.motionHistory.slice(-10);
            const avgVelocity = recentMotion.reduce((sum, frame) => {
                return sum + Math.abs(frame[0]) + Math.abs(frame[2]); // X and Z velocity
            }, 0) / recentMotion.length;
            
            const avgRotation = recentMotion.reduce((sum, frame) => {
                return sum + Math.abs(frame[4]); // Y rotation
            }, 0) / recentMotion.length;
            
            logInferenceEvent(`üìä Motion Analysis:`, 'info');
            logInferenceEvent(`  - Average velocity: ${avgVelocity.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Average rotation: ${avgRotation.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Current phase: ${aiModelManager.currentPhase.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Style vector norm: ${Math.sqrt(aiModelManager.currentStyle.reduce((sum, x) => sum + x*x, 0)).toFixed(3)}`, 'info');
        }


        // Initialize AI system on page load
        updateLoadingStatus('Initializing AI-powered motion system...');

        // Initialize AI model manager
        setTimeout(async () => {
            try {
                logInferenceEvent('üß† Pure WebGPU AI system ready for initialization...', 'info');
                logInferenceEvent('üí° Click "üî• Warm Up All" to load ONNX models on WebGPU', 'info');
                logInferenceEvent('üéØ Then switch to AI mode to use neural networks!', 'success');

                // Enable AI mode button
                const aiModeBtn = document.getElementById('ai-mode-btn');
                if (aiModeBtn) {
                    aiModeBtn.disabled = false;
                    aiModeBtn.title = 'Switch between BVH playback and AI-generated motion';
                }
                
            } catch (error) {
                logInferenceEvent(`‚ùå AI initialization failed: ${error.message}`, 'error');
                logInferenceEvent('üí° Falling back to BVH-only mode', 'warning');
            }
        }, 2000);



        // Toggle function for inference details (from legacy)
        function toggleInferenceDetails() {
            const details = document.getElementById('inference-details');
            const button = document.getElementById('toggle-inference-details');
            
            if (!details || !button) {
                console.log('‚ÑπÔ∏è Inference details elements not found - feature disabled');
                return;
            }
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                button.textContent = 'Hide Details';
            } else {
                details.style.display = 'none';
                button.textContent = 'Show Details';
            }
        }
        
        // Add event listener for the toggle button (if it exists)
        const toggleButton = document.getElementById('toggle-inference-details');
        if (toggleButton) {
            toggleButton.onclick = toggleInferenceDetails;
        } else {
            console.log('‚ÑπÔ∏è Toggle inference details button not found - feature disabled');
        }
        
        // === SERVER WARMUP FUNCTIONALITY ===
        
        // Server configuration
        const SERVER_BASE_URL = 'http://localhost:8000';
        const WEBSOCKET_URL = 'ws://localhost:8765';
        let modelStatus = {
            deephase: 'ready',
            stylevae: 'standby', 
            transitionnet: 'idle'
        };
        
        // WebSocket connection
        let websocket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        
        // Update model status displays
        function updateModelStatus(model, status, message = '') {
            const statusElement = document.getElementById(`${model}-status`);
            if (statusElement) {
                const statusDiv = statusElement.querySelector('div:last-child');
                if (statusDiv) {
                    statusDiv.textContent = status;
                    if (message) {
                        statusDiv.title = message;
                    }
                }
                
                // Update color based on status
                const titleDiv = statusElement.querySelector('div:first-child');
                if (titleDiv) {
                    if (status.toLowerCase().includes('ready') || status.toLowerCase().includes('active')) {
                        titleDiv.style.color = '#00ff88';
                    } else if (status.toLowerCase().includes('loading') || status.toLowerCase().includes('warming')) {
                        titleDiv.style.color = '#ffaa00';
                    } else {
                        titleDiv.style.color = '#ff6666';
                    }
                }
            }
            
            modelStatus[model] = status.toLowerCase();
        }
        
        // Log inference events
        function logInferenceEvent(message, type = 'info') {
            const inferenceLog = document.getElementById('inference-log');
            if (inferenceLog) {
                const timestamp = new Date().toLocaleTimeString();
                const color = type === 'error' ? '#ff6666' : 
                             type === 'warning' ? '#ffaa00' : 
                             type === 'success' ? '#00ff88' : '#00d4ff';
                
                const logEntry = document.createElement('div');
                logEntry.style.color = color;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                inferenceLog.appendChild(logEntry);
                inferenceLog.scrollTop = inferenceLog.scrollHeight;
                
                // Keep only last 20 log entries
                while (inferenceLog.children.length > 25) {
                    inferenceLog.removeChild(inferenceLog.children[5]); // Keep first 5 header lines
                }
            }
        }
        
        // === WEBSOCKET COMMUNICATION ===
        
        function connectWebSocket() {
            try {
                logInferenceEvent('üîó Connecting to WebSocket server...', 'info');
                websocket = new WebSocket(WEBSOCKET_URL);
                
                websocket.onopen = function(event) {
                    logInferenceEvent('‚úÖ WebSocket connected - real-time mode active!', 'success');
                    reconnectAttempts = 0;
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        logInferenceEvent(`‚ùå Error parsing WebSocket message: ${error}`, 'error');
                    }
                };
                
                websocket.onclose = function(event) {
                    logInferenceEvent('üîå WebSocket disconnected', 'warning');
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        logInferenceEvent(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`, 'info');
                        setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                    } else {
                        logInferenceEvent('‚ùå Max reconnection attempts reached. Using fallback mode.', 'error');
                    }
                };
                
                websocket.onerror = function(error) {
                    logInferenceEvent('‚ùå WebSocket error - falling back to HTTP mode', 'error');
                };
                
            } catch (error) {
                logInferenceEvent(`‚ùå WebSocket connection failed: ${error.message}`, 'error');
            }
        }
        
        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'initial_status':
                    logInferenceEvent('üìä Received initial server status', 'info');
                    updateModelsFromServerData(data.models);
                    break;
                    
                case 'status_update':
                    const model = data.model;
                    const status = data.status;
                    const details = data.details || {};
                    
                    updateModelStatus(model, status, `${data.model_type || ''} - ${details.stage || ''}`);
                    
                    if (details.progress !== undefined) {
                        logInferenceEvent(`${model}: ${status} (${details.progress}%)`, 'info');
                    } else {
                        logInferenceEvent(`${model}: ${status}`, 'info');
                    }
                    
                    if (details.processing_time) {
                        logInferenceEvent(`${model} processing time: ${details.processing_time.toFixed(3)}s`, 'success');
                    }
                    break;
                    
                case 'command_ack':
                    logInferenceEvent(`‚úÖ Command acknowledged: ${data.command} for ${data.model}`, 'success');
                    break;
                    
                case 'pong':
                    logInferenceEvent('üèì Server responsive', 'info');
                    break;
                    
                default:
                    logInferenceEvent(`üì® Received: ${data.type}`, 'info');
            }
        }
        
        function sendWebSocketCommand(command, model = null) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const message = {
                    type: command,
                    model: model,
                    timestamp: Date.now()
                };
                
                websocket.send(JSON.stringify(message));
                logInferenceEvent(`üì§ Sent command: ${command}${model ? ' for ' + model : ''}`, 'info');
                return true;
            } else {
                logInferenceEvent('‚ö†Ô∏è WebSocket not connected, using fallback mode', 'warning');
                return false;
            }
        }
        
        function updateModelsFromServerData(modelsData) {
            for (const [modelName, modelInfo] of Object.entries(modelsData)) {
                if (modelName !== 'skeleton') {
                    updateModelStatus(modelName, modelInfo.status, modelInfo.type);
                }
            }
        }
        
        // Test server connection
        async function testServerConnection() {
            logInferenceEvent('Testing server connection...', 'info');
            updateModelStatus('deephase', 'Testing...', 'Checking server connectivity');
            
            try {
                const response = await fetch(`${SERVER_BASE_URL}/api/status`);
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì Server connected: ${data.server || 'RSMT Server'}`, 'success');
                    
                    // Update model statuses from server response
                    if (data.models) {
                        for (const [modelName, modelInfo] of Object.entries(data.models)) {
                            if (modelName !== 'skeleton') {
                                const status = modelInfo.status || 'Unknown';
                                updateModelStatus(modelName, status, `Type: ${modelInfo.type || 'Unknown'}`);
                            }
                        }
                    }
                    
                    logInferenceEvent(`AI Status: ${data.ai_status || 'Unknown'}`, 'info');
                    logInferenceEvent(`Models using AI: ${data.models_using_ai || '0/3'}`, 'info');
                    
                } else {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå Server connection failed: ${error.message}`, 'error');
                
                // Try simple HTTP server test
                try {
                    const simpleResponse = await fetch(`${SERVER_BASE_URL}/`);
                    if (simpleResponse.ok) {
                        logInferenceEvent('‚ö† Simple HTTP server detected, need FastAPI server', 'warning');
                        logInferenceEvent('üí° To start proper server: python3 simple_warmup_server.py', 'info');
                        updateModelStatus('deephase', 'No API', 'Simple HTTP server only');
                        updateModelStatus('stylevae', 'No API', 'Need API server');
                        updateModelStatus('transitionnet', 'No API', 'Need API server');
                    }
                } catch (simpleError) {
                    logInferenceEvent('üîÑ Server not running - simulating warmup locally', 'warning');
                    simulateLocalWarmup();
                }
            }
        }
        
        // Simulate warmup when server is not available
        function simulateLocalWarmup() {
            updateModelStatus('deephase', 'Simulated', 'Local simulation mode');
            updateModelStatus('stylevae', 'Standby', 'Ready for simulation');
            updateModelStatus('transitionnet', 'Idle', 'Ready for simulation');
            logInferenceEvent('üé≠ Running in simulation mode - no real neural networks', 'warning');
            logInferenceEvent('üí° Start server on port 8000 for real AI processing', 'info');
        }
        
        // Warm up StyleVAE model
        async function warmupStyleVAE() {
            logInferenceEvent('üé® Initiating StyleVAE warmup...', 'info');
            updateModelStatus('stylevae', 'Initiating...', 'Sending warmup command');
            
            // Try WebSocket first
            if (sendWebSocketCommand('warmup', 'stylevae')) {
                return; // WebSocket will handle the rest
            }
            
            // Fallback to HTTP/simulation
            try {
                const dummyMotion = {
                    frames: [
                        [0, 0, 0, 0, 0, 0, ...Array(60).fill(0)]
                    ],
                    frame_time: 0.016667
                };
                
                const response = await fetch(`${SERVER_BASE_URL}/api/encode_style`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        motion_data: dummyMotion
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì StyleVAE activated! Processing time: ${data.processing_time?.toFixed(3) || 'unknown'}s`, 'success');
                    updateModelStatus('stylevae', 'Active', `Ready for style encoding. Time: ${data.processing_time?.toFixed(3)}s`);
                    
                    if (data.style_code && data.style_code.length > 0) {
                        logInferenceEvent(`Style vector dimension: ${data.style_code.length}`, 'info');
                    }
                } else {
                    throw new Error(`StyleVAE warmup failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå HTTP warmup failed: ${error.message}`, 'error');
                // Simulate StyleVAE activation
                logInferenceEvent('üé® Simulating StyleVAE warmup...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 800));
                updateModelStatus('stylevae', 'Simulated', 'Local simulation active');
                logInferenceEvent('‚úì StyleVAE simulation active (256-dim style vectors)', 'success');
            }
        }
        
        // Warm up TransitionNet model
        async function warmupTransitionNet() {
            logInferenceEvent('üîÑ Initiating TransitionNet warmup...', 'info');
            updateModelStatus('transitionnet', 'Initiating...', 'Sending warmup command');
            
            // Try WebSocket first
            if (sendWebSocketCommand('warmup', 'transitionnet')) {
                return; // WebSocket will handle the rest
            }
            
            // Fallback to HTTP/simulation
            try {
                const dummyMotion = {
                    frames: [
                        [0, 0, 0, 0, 0, 0, ...Array(60).fill(0)]
                    ],
                    frame_time: 0.016667
                };
                
                const dummyStyleCode = Array(256).fill(0.1);
                
                const response = await fetch(`${SERVER_BASE_URL}/api/generate_transition`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_motion: dummyMotion,
                        target_motion: dummyMotion,
                        style_code: dummyStyleCode,
                        transition_length: 10
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì TransitionNet activated! Processing time: ${data.processing_time?.toFixed(3) || 'unknown'}s`, 'success');
                    updateModelStatus('transitionnet', 'Active', `Ready for motion transitions. Time: ${data.processing_time?.toFixed(3)}s`);
                    
                    if (data.transition_frames && data.transition_frames.length > 0) {
                        logInferenceEvent(`Generated ${data.transition_frames.length} transition frames`, 'info');
                    }
                } else {
                    throw new Error(`TransitionNet warmup failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå HTTP warmup failed: ${error.message}`, 'error');
                // Simulate TransitionNet activation
                logInferenceEvent('üîÑ Simulating TransitionNet warmup...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 600));
                updateModelStatus('transitionnet', 'Simulated', 'Local simulation active');
                logInferenceEvent('‚úì TransitionNet simulation active (motion blending)', 'success');
            }
        }
        
        // Warm up all models
        async function warmupAllModels() {
            logInferenceEvent('üî• Starting full model warmup sequence...', 'info');
            
            // Try WebSocket command for all models
            if (sendWebSocketCommand('warmup', 'all')) {
                updateModelStatus('stylevae', 'Queued...', 'Waiting for server');
                updateModelStatus('transitionnet', 'Queued...', 'Waiting for server');
                return; // WebSocket will handle the rest
            }
            
            // Fallback to individual warmups
            updateModelStatus('deephase', 'Ready', 'Already active');
            updateModelStatus('stylevae', 'Initializing...', 'Starting StyleVAE warmup');
            updateModelStatus('transitionnet', 'Initializing...', 'Starting TransitionNet warmup');
            
            try {
                await testServerConnection();
                await new Promise(resolve => setTimeout(resolve, 1000));
                await warmupStyleVAE();
                await new Promise(resolve => setTimeout(resolve, 500));
                await warmupTransitionNet();
                
                logInferenceEvent('üéØ All models warmed up successfully!', 'success');
                document.getElementById('inference-rate').textContent = 'Variable';
                document.getElementById('inference-latency').textContent = 'Active';
            } catch (error) {
                logInferenceEvent(`‚ùå Warmup sequence failed: ${error.message}`, 'error');
            }
        }



        // === PURE WEBGPU WARMUP FUNCTIONS (No Server Dependencies) ===
        async function testServerConnectionReal() {
            logInferenceEvent('üåê Pure WebGPU mode - no server connection needed!', 'success');
            updateModelStatus('deephase', 'WebGPU Ready', 'Client-side inference');
            updateModelStatus('stylevae', 'WebGPU Ready', 'Client-side inference');
            updateModelStatus('transitionnet', 'WebGPU Ready', 'Client-side inference');
        }

        async function warmupStyleVAEReal() {
            if (!aiModelManager.isInitialized) {
                logInferenceEvent('üé® Initializing StyleVAE on WebGPU...', 'info');
                try {
                    await aiModelManager.initialize();
                    updateModelStatus('stylevae', 'Ready', 'WebGPU loaded successfully');
                    logInferenceEvent('‚úÖ StyleVAE ready on WebGPU!', 'success');
                } catch (error) {
                    updateModelStatus('stylevae', 'Failed', error.message);
                    logInferenceEvent(`‚ùå StyleVAE initialization failed: ${error.message}`, 'error');
                }
            } else {
                updateModelStatus('stylevae', 'Active', 'WebGPU inference ready');
                logInferenceEvent('‚úÖ StyleVAE already active on WebGPU', 'success');
            }
        }

        async function warmupTransitionNetReal() {
            if (!aiModelManager.isInitialized) {
                logInferenceEvent('üîÑ Initializing TransitionNet on WebGPU...', 'info');
                try {
                    await aiModelManager.initialize();
                    updateModelStatus('transitionnet', 'Ready', 'WebGPU loaded successfully');
                    logInferenceEvent('‚úÖ TransitionNet ready on WebGPU!', 'success');
                } catch (error) {
                    updateModelStatus('transitionnet', 'Failed', error.message);
                    logInferenceEvent(`‚ùå TransitionNet initialization failed: ${error.message}`, 'error');
                }
            } else {
                logInferenceEvent('‚úÖ TransitionNet already active on WebGPU', 'success');
            }
        }

        async function warmupAllModelsReal() {
            logInferenceEvent('üî• Starting WebGPU model initialization...', 'info');
            updateModelStatus('deephase', 'Initializing...', 'Loading on WebGPU');
            updateModelStatus('stylevae', 'Initializing...', 'Loading on WebGPU');
            updateModelStatus('transitionnet', 'Initializing...', 'Loading on WebGPU');

            try {
                await aiModelManager.initialize();
            // Priority 1: Apply to VRM character if available
            if (window.currentVRMAdapter && window.currentVRMAdapter.vrmModel) {
                if (animationFrame % 120 === 0) { // Every 2 seconds at 60fps
                    console.log('üé≠ Applying BVH frame to VRM character...');
                    console.log('Frame data length:', frameData.length);
                    console.log('VRM adapter available:', !!window.currentVRMAdapter);
                    console.log('VRM scene in global scene:', scene.children.some(child => child === window.currentVRMAdapter.vrmScene));
                    window.currentVRMAdapter.applyBVHFrame(frameData);
                }
            }
                updateModelStatus('deephase', 'Ready', 'WebGPU loaded successfully');
                updateModelStatus('stylevae', 'Ready', 'WebGPU loaded successfully');
                updateModelStatus('transitionnet', 'Ready', 'WebGPU loaded successfully');
                logInferenceEvent('‚úÖ All models initialized on WebGPU!', 'success');
            } catch (error) {
                updateModelStatus('deephase', 'Failed', error.message);
                updateModelStatus('stylevae', 'Failed', error.message);
                updateModelStatus('transitionnet', 'Failed', error.message);
                logInferenceEvent(`‚ùå WebGPU initialization failed: ${error.message}`, 'error');
            }
        }
        // === CHARACTER SYSTEM CONTROL FUNCTIONS ===
        
        function initializeCharacterControls() {
            console.log('üé≠ Initializing character control functions...');
            
            // Enhanced character testing and control functions
            window.showFullVRMCharacter = function() {
                if (characterSystem) {
                    if (characterSystem.vrmCharacter) {
                        characterSystem.setDisplayMode('character');
                        statusDiv.textContent = 'Full VRM character not loaded';
                        return '‚ùå Full VRM character not available';
                    }
                } else {
                    return '‚ùå Character system not ready';
                }
            };
            
            window.runMaterialDiagnostics = function() {
                console.log('üîç Running comprehensive material diagnostics...');
                
                // Check if scene exists
                if (!scene) {
                    console.warn('‚ö†Ô∏è Scene not available for diagnostics');
                    return;
                }
                
                let totalObjects = 0;
                let materialsFound = 0;
                let problematicMaterials = 0;
                let shaderMaterials = 0;
                let vrmMaterials = 0;
                const materialTypes = {};
                const shaderErrors = [];
                
                scene.traverse((object) => {
                    totalObjects++;
                    
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach((mat, index) => {
                                materialsFound++;
                                analyzeMaterial(mat, `${object.name}_${index}`);
                            });
                        } else {
                            materialsFound++;
                            analyzeMaterial(object.material, object.name || 'unnamed');
                        }
                    }
                });
                
                function analyzeMaterial(material, objectName) {
                    if (!material) return;
                    
                    const type = material.type || 'Unknown';
                    materialTypes[type] = (materialTypes[type] || 0) + 1;
                    
                    // Check for VRM materials
                    if (type.includes('VRM') || type.includes('MToon')) {
                        vrmMaterials++;
                    }
                    
                    // Check for shader materials
                    if (material.isShaderMaterial || material.isRawShaderMaterial) {
                        shaderMaterials++;
                        
                        // Check uniforms
                        if (material.uniforms) {
                            Object.keys(material.uniforms).forEach(key => {
                                const uniform = material.uniforms[key];
                                if (uniform && uniform.value === undefined) {
                                    shaderErrors.push(`${objectName}: ${key} uniform is undefined`);
                                    problematicMaterials++;
                                }
                            });
                        }
                    }
                    
                    // Check for common issues
                    if (material.map && !material.map.image) {
                        shaderErrors.push(`${objectName}: texture map missing image`);
                        problematicMaterials++;
                    }
                    
                    if (material.opacity === undefined) {
                        shaderErrors.push(`${objectName}: opacity undefined`);
                        problematicMaterials++;
                    }
                }
                
                console.log('üìä Material Diagnostics Report:');
                console.log(`  Total objects: ${totalObjects}`);
                console.log(`  Materials found: ${materialsFound}`);
                console.log(`  Shader materials: ${shaderMaterials}`);
                console.log(`  VRM materials: ${vrmMaterials}`);
                console.log(`  Problematic materials: ${problematicMaterials}`);
                console.log('üìã Material types:', materialTypes);
                
                if (shaderErrors.length > 0) {
                    console.log('‚ö†Ô∏è Shader errors found:');
                    shaderErrors.forEach(error => console.log(`  - ${error}`));
                }
                
                return {
                    totalObjects,
                    materialsFound,
                    shaderMaterials,
                    vrmMaterials,
                    problematicMaterials,
                    materialTypes,
                    shaderErrors
                };
            };
            
            window.testLighting = function() {
                console.log('üåü Testing enhanced anime lighting...');
                
                // Check if lights exist
                const lights = [
                    ['Key Light', window.keyLight],
                    ['Fill Light', window.fillLight], 
                    ['Rim Light', window.rimLight],
                    ['Face Light', window.faceLight]
                ];
                
                lights.forEach(([name, light]) => {
                    if (light) {
                        console.log(`‚úÖ ${name}: intensity ${light.intensity}, position (${light.position.x.toFixed(1)}, ${light.position.y.toFixed(1)}, ${light.position.z.toFixed(1)})`);
                    } else {
                        console.log(`‚ùå ${name}: not found`);
                    }
                });
                
                // Count all lights in scene
                let lightCount = 0;
                scene.traverse((child) => {
                    if (child.isLight) {
                        lightCount++;
                        console.log(`  Light: ${child.type}, Intensity: ${child.intensity}, Position: [${child.position.x.toFixed(1)}, ${child.position.y.toFixed(1)}, ${child.position.z.toFixed(1)}]`);
                    }
                });
                
                console.log(`Total lights in scene: ${lightCount}`);
                console.log('Renderer shadow mapping:', renderer.shadowMap.enabled);
                console.log('Tone mapping:', renderer.toneMapping);
                console.log('Tone mapping exposure:', renderer.toneMappingExposure);
                console.log('üé® Background: Gradient sky for anime aesthetic');
                console.log('üîß Shadows: Disabled for VRM compatibility');
                
                // Test lighting by temporarily changing key light intensity
                if (window.keyLight) {
                    const originalIntensity = window.keyLight.intensity;
                    window.keyLight.intensity = 2.0;
                    setTimeout(() => { window.keyLight.intensity = originalIntensity; }, 1000);
                    console.log('üí° Key light intensity temporarily boosted for 1 second');
                }
                
                // Check VRM character lighting
                if (characterSystem?.vrmCharacter?.vrm?.scene) {
                    console.log('üé≠ VRM character detected - lighting optimized for anime style');
                    console.log('üìä VRM scene children:', characterSystem.vrmCharacter.vrm.scene.children.length);
                } else {
                    console.log('‚ö†Ô∏è No VRM character loaded yet');
                }
                
                return `‚úÖ ${lightCount} lights configured - enhanced anime lighting active`;
            };
            
            // Function to improve lighting and contrast for anime characters
            window.improvedLighting = function() {
                console.log('‚ú® Applying improved anime lighting...');
                
                // Use the enhanced VRM lighting function if VRM character is available
                if (window.vrmCharacter) {
                    enhanceVRMLighting(window.vrmCharacter);
                }
                
                // Boost key light for better character visibility
                if (window.keyLight) {
                    window.keyLight.intensity = 2.0;
                    console.log('üí° Key light boosted to 2.0');
                }
                
                // Enhance face light for anime style
                if (window.faceLight) {
                    window.faceLight.intensity = 1.5;
                    window.faceLight.angle = Math.PI / 5; // Wider angle
                    console.log('üí° Face light enhanced');
                }
                
                // Adjust fill light for better balance
                if (window.fillLight) {
                    window.fillLight.intensity = 1.2;
                    console.log('üí° Fill light adjusted');
                }
                
                // Boost tone mapping exposure for anime brightness
                renderer.toneMappingExposure = 1.2;
                console.log('üé® Tone mapping exposure increased');
                
                statusDiv.textContent = 'Enhanced anime lighting applied!';
                return '‚ú® Improved anime lighting applied!';
            };
            
            // Function to focus camera on Ichika's face
            window.focusOnFace = function() {
                if (window.vrmCharacter) {
                    // Use Ichika's specific camera settings
                    camera.position.set(0, 1.35, -1.8); // From ichika.json preview camera
                    camera.lookAt(0, 1.15, 0);
                    camera.fov = 40;
                    camera.updateProjectionMatrix();
                    console.log('üì∑ Camera focused on Ichika\'s face');
                    return 'Camera focused on face';
                } else {
                    console.log('‚ö†Ô∏è No VRM character loaded');
                    return 'No character to focus on';
                }
            };
            
            // Fix VRM shader errors specifically
            window.fixVRMShaders = function() {
                let fixedCount = 0;
                console.log('üîß Fixing VRM shader issues...');
                
                scene.traverse((object) => {
                    if (object.isMesh && object.material) {
                        const materials = Array.isArray(object.material) ? object.material : [object.material];
                        
                        materials.forEach(material => {
                            // Check for VRM materials or problematic uniforms
                            if (material.type && (material.type.includes('VRM') || material.type.includes('MToon'))) {
                                // Replace VRM materials with simple MeshLambertMaterial
                                const newMaterial = new THREE.MeshLambertMaterial({
                                    color: material.color || 0xFFFFFF,
                                    map: material.map || null,
                                    transparent: material.transparent || false,
                                    opacity: material.opacity !== undefined ? material.opacity : 1.0,
                                    emissive: material.emissive || 0x000000,
                                });
                                
                                if (Array.isArray(object.material)) {
                                    const index = object.material.indexOf(material);
                                    object.material[index] = newMaterial;
                                } else {
                                    object.material = newMaterial;
                                }
                                fixedCount++;
                                console.log(`üîß Replaced VRM material on ${object.name || 'unnamed object'}`);
                            }
                            
                            // Fix any problematic uniforms
                            if (material.uniforms) {
                                Object.keys(material.uniforms).forEach(key => {
                                    const uniform = material.uniforms[key];
                                    if (uniform && uniform.value !== undefined) {
                                        // Fix Vector3 uniforms causing uniform3fv errors
                                        if (uniform.value && uniform.value.isVector3) {
                                            if (isNaN(uniform.value.x) || isNaN(uniform.value.y) || isNaN(uniform.value.z)) {
                                                uniform.value.set(0, 0, 0);
                                                fixedCount++;
                                                console.log(`üîß Fixed Vector3 uniform: ${key}`);
                                            }
                                        }
                                    }
                                });
                            }
                        });
                    }
                });
                
                // Force material compilation
                try {
                    renderer.compile(scene, camera);
                    console.log(`‚úÖ Fixed ${fixedCount} shader issues and recompiled scene`);
                } catch (e) {
                    console.warn('‚ö†Ô∏è Scene compilation failed after fixes:', e.message);
                }
                
                return `Fixed ${fixedCount} shader issues`;
            };
            
            // Function to set optimal character view
            window.fullBodyView = function() {
                camera.position.set(0, 1.6, 2.5);
                camera.lookAt(0, 1.0, 0);
                camera.fov = 40;
                camera.updateProjectionMatrix();
                console.log('üì∑ Full body view set');
                return 'Full body view active';
            };
            
            // Function to apply Ichika's idle animation and expressions
            window.animateIchika = function() {
                if (window.vrmCharacter && window.vrmCharacter.vrm) {
                    try {
                        // Apply some basic facial expressions
                        const expressionManager = window.vrmCharacter.vrm.expressionManager;
                        if (expressionManager) {
                            // Set a subtle happy expression
                            expressionManager.setValue('happy', 0.3);
                            expressionManager.setValue('relaxed', 0.2);
                            expressionManager.update();
                            console.log('üòä Applied happy expression to Ichika');
                        }
                        
                        // Add subtle breathing animation
                        if (window.vrmCharacter.vrm.humanoid) {
                            const chest = window.vrmCharacter.vrm.humanoid.getRawBoneNode('chest');
                            if (chest) {
                                const time = Date.now() * 0.001;
                                chest.rotation.x = Math.sin(time * 2) * 0.02; // Subtle breathing
                            }
                        }
                        
                        return 'üòä Ichika animation applied';
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Animation error:', e.message);
                        return 'Animation failed: ' + e.message;
                    }
                } else {
                    return 'No VRM character loaded';
                }
            };
            window.fixVRMShaders = function() {
                console.log('üîß Attempting to fix VRM shader issues...');
                
                if (!characterSystem?.vrmCharacter?.vrm?.scene) {
                    console.log('‚ùå No VRM character loaded');
                    return 'No VRM character to fix';
                }
                
                let fixedCount = 0;
                characterSystem.vrmCharacter.vrm.scene.traverse((child) => {
                    if (child.isMesh && child.material) {
                        // Completely disable shadows
                        child.castShadow = false;
                        child.receiveShadow = false;
                        
                        // Force material to use basic lighting
                        if (child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) {
                            // Convert to MeshLambertMaterial for better compatibility
                            const newMaterial = new THREE.MeshLambertMaterial({
                                map: child.material.map,
                                color: child.material.color,
                                transparent: child.material.transparent,
                                opacity: child.material.opacity,
                                side: child.material.side
                            });
                            child.material = newMaterial;
                            fixedCount++;
                        }
                        
                        // Force update
                        child.material.needsUpdate = true;
                    }
                });
                
                console.log(`‚úÖ Fixed ${fixedCount} VRM materials`);
                return `Fixed ${fixedCount} VRM materials for better compatibility`;
            };
            
            // Function to debug VRM state
            window.debugVRMState = function() {
                console.log('üîç VRM Debug State:');
                console.log('  currentVRMAdapter:', !!window.currentVRMAdapter);
                if (window.currentVRMAdapter) {
                    console.log('  vrmModel:', !!window.currentVRMAdapter.vrmModel);
                    console.log('  initialized:', window.currentVRMAdapter.initialized);
                    console.log('  available bones:', window.currentVRMAdapter.getAvailableBones?.().length || 'no method');
                    console.log('  scene in global scene:', scene.children.some(child => child === window.currentVRMAdapter.vrmModel?.scene));
                    if (window.currentVRMAdapter.vrmModel?.scene) {
                        console.log('  scene visible:', window.currentVRMAdapter.vrmModel.scene.visible);
                        console.log('  scene position:', window.currentVRMAdapter.vrmModel.scene.position);
                        console.log('  scene children:', window.currentVRMAdapter.vrmModel.scene.children.length);
                    }
                }
                console.log('  vrmCharacter:', !!window.vrmCharacter);
                console.log('  Global scene children:', scene.children.length);
                
                // Test applying a frame manually
                if (window.currentVRMAdapter && bvhData[currentAnimation]?.frames?.length > 0) {
                    console.log('üß™ Testing manual frame application...');
                    const testFrame = bvhData[currentAnimation].frames[0];
                    const result = window.currentVRMAdapter.applyBVHFrameToVRM(testFrame);
                    console.log('  Manual frame application result:', result);
                }
                
                return 'VRM debug info logged to console';
            };
            
            // Function to toggle shadow mapping for testing
            window.toggleShadows = function() {
                const enabled = !renderer.shadowMap.enabled;
                renderer.shadowMap.enabled = enabled;
                
                // Update lights
                scene.traverse((child) => {
                    if (child.isDirectionalLight) {
                        child.castShadow = enabled;
                    }
                });
                
                // Update objects
                scene.traverse((child) => {
                    if (child.isMesh && !child.userData.isVRM) {
                        child.castShadow = enabled;
                        child.receiveShadow = enabled;
                    }
                });
                
                console.log(`üåë Shadows ${enabled ? 'enabled' : 'disabled'}`);
                return `Shadows ${enabled ? 'enabled' : 'disabled'}`;
            };
            
            // Character management functions - Enhanced with VRM rigging
            window.loadSelectedCharacter = async function() {
                const select = document.getElementById('character-select');
                const characterFile = select.value;
                
                if (characterFile && characterSystem) {
                    try {
                        statusDiv.textContent = `Loading VRM character: ${characterFile}`;
                        updateLoadingStatus(`Loading VRM character: ${characterFile}`);
                        
                        // Try to load the actual VRM character first
                        console.log('üé≠ Attempting to load VRM character:', characterFile);
                        
                        // Use the AdvancedVRMLoader that's already in the system
                        if (window.AdvancedVRMLoader) {
                            // Make sure scene is available globally for the loader
                            window.scene = scene;
                            
                            const vrmModel = await window.AdvancedVRMLoader.loadVRMCharacter(`./assets/avatars/${characterFile}`);
                            
                            if (vrmModel && vrmModel.vrm) {
                                console.log('üé≠ VRM model loaded successfully, creating VRM-BVH adapter...');
                                console.log('VRM scene added to global scene:', !!vrmModel.scene);
                                
                                // Ensure VRM is added to the scene if not already
                                if (vrmModel.scene && !scene.children.includes(vrmModel.scene)) {
                                    scene.add(vrmModel.scene);
                                    console.log('‚úÖ VRM scene manually added to global scene');
                                }
                                
                                // Initialize Enhanced VRM-BVH adapter for proper rigging
                                if (window.EnhancedVRMBVHAdapter) {
                                    console.log('üîó Creating Enhanced VRM-BVH adapter with correct API usage');
                                    console.log('VRM model structure:', vrmModel);
                                    console.log('VRM object available:', !!vrmModel.vrm);
                                    console.log('VRM humanoid available:', !!vrmModel.vrm?.humanoid);
                                    
                                    try {
                                        // CRITICAL: Pass the VRM object directly, not the wrapper
                                        window.currentVRMAdapter = new window.EnhancedVRMBVHAdapter(vrmModel.vrm, scene);
                                        
                                        // Initialize the enhanced adapter
                                        const initialized = window.currentVRMAdapter.initialize();
                                        if (initialized) {
                                            console.log('‚úÖ Enhanced VRM-BVH adapter initialized successfully');
                                            console.log('Available bones:', window.currentVRMAdapter.getAvailableBones().length);
                                        } else {
                                            console.warn('‚ö†Ô∏è Enhanced VRM-BVH adapter initialization failed');
                                        }
                                    } catch (adapterError) {
                                        console.error('‚ùå Failed to create Enhanced VRM adapter:', adapterError.message);
                                        console.error('Full error:', adapterError);
                                        
                                        // Fallback: Try to create basic adapter
                                        console.log('üîÑ Attempting fallback adapter creation...');
                                        try {
                                            if (window.VRMBVHAdapter) {
                                                window.currentVRMAdapter = new window.VRMBVHAdapter(vrmModel, scene);
                                                console.log('‚úÖ Fallback VRM adapter created');
                                            }
                                        } catch (fallbackError) {
                                            console.error('‚ùå Fallback adapter also failed:', fallbackError.message);
                                        }
                                    }
                                    
                                    if (window.currentVRMAdapter && window.currentVRMAdapter.initialized) {
                                        console.log('üé≠ VRM-BVH adapter ready for animation');
                                        
                                        // Store the VRM model globally
                                        window.vrmCharacter = vrmModel;
                                        
                                        // Hide old skeleton completely
                                        if (skeletonGroup) {
                                            skeletonGroup.visible = false;
                                            console.log('üîÑ Old skeleton hidden - VRM character is primary animation target');
                                        }
                                        
                                        // Set display mode to VRM character only (deprecating skeleton)
                                        characterSystem.setDisplayMode('character');
                                        document.getElementById('display-mode').value = 'character';
                                        
                                        statusDiv.textContent = `VRM character loaded: ${characterFile.replace('.vrm', '')}`;
                                        currentCharacterFile = characterFile;
                                        
                                        // Update info panel
                                        const displayName = characterFile.replace('.vrm', '').replace(/^\w/, c => c.toUpperCase());
                                        document.getElementById('current-character').textContent = `${displayName} (VRM Character)`;
                                        
                                        console.log('‚úÖ VRM character loaded - will receive all BVH animations:', characterFile);
                                        console.log('üé≠ VRM-BVH adapter initialized with', window.currentVRMAdapter.getAvailableBones().length, 'bones');
                                        
                                        // Apply enhanced VRM lighting
                                        if (typeof enhanceVRMLighting === 'function') {
                                            enhanceVRMLighting(window.vrmCharacter);
                                        }
                                        
                                        // Apply VRM visibility fix to ensure all parts are visible
                                        if (typeof window.fixVRMVisibility === 'function') {
                                            console.log('üîß Applying VRM visibility fix...');
                                            window.fixVRMVisibility();
                                        }
                                        
                                        // Debug VRM structure
                                        if (typeof window.debugVRM === 'function') {
                                            window.debugVRM();
                                        }
                                        
                                        // Fix VRM scale and position for correct coordinate system
                                        if (window.vrmCharacter && window.vrmCharacter.vrm) {
                                            const vrmScene = window.vrmCharacter.vrm.scene;
                                            
                                            // Enhanced VRM scale and position correction for proper grounding
                                            const boundingBox = new THREE.Box3().setFromObject(vrmScene);
                                            const height = boundingBox.max.y - boundingBox.min.y;
                                            const groundOffset = -boundingBox.min.y; // Calculate offset to put feet on ground
                                            
                                            // Apply proper scale and position
                                            vrmScene.scale.setScalar(1.0); // Use 1:1 scale
                                            vrmScene.position.set(0, groundOffset * 0.98, 0); // Ground the character with slight adjustment
                                            vrmScene.rotation.set(0, 0, 0); // No rotation offset
                                            
                                            console.log('üîß VRM positioning enhanced:');
                                            console.log('  - Character height:', height.toFixed(2), 'units');
                                            console.log('  - Ground offset:', groundOffset.toFixed(2), 'units');
                                            console.log('  - Final position:', vrmScene.position);
                                            
                                            // Force an immediate render to apply position changes
                                            if (window.renderer && window.scene && window.camera) {
                                                window.renderer.render(window.scene, window.camera);
                                            }
                                        }
                                        
                                        // Enable debug mode for testing
                                        window.currentVRMAdapter.debugMode = true;
                                        
                                        return; // Success - exit early
                                    } else {
                                        console.warn('‚ö†Ô∏è Failed to initialize VRM-BVH adapter');
                                    }
                                } else {
                                    console.warn('‚ö†Ô∏è VRMBVHAdapter not available');
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Failed to load VRM model');
                            }
                        } else {
                            console.warn('‚ö†Ô∏è AdvancedVRMLoader not available');
                        }
                        
                        // Fallback to textured skeleton if VRM loading fails
                        console.log('‚ö†Ô∏è Falling back to textured skeleton approach');
                        
                        const characterName = characterFile.replace('.vrm', '');
                        
                        // Apply VRM textures to the BVH skeleton
                        await characterSystem.applyVRMTextureToSkeleton(`./assets/avatars/${characterFile}`);
                        
                        // Set display mode to textured skeleton
                        characterSystem.setDisplayMode('textured_skeleton');
                        document.getElementById('display-mode').value = 'textured_skeleton';
                        
                        statusDiv.textContent = `Textured skeleton: ${characterName}`;
                        currentCharacterFile = characterFile;
                        
                        // Update info panel
                        const displayName = characterName.replace(/^\w/, c => c.toUpperCase());
                        document.getElementById('current-character').textContent = `${displayName} (Textured Skeleton)`;
                        
                        console.log('‚úÖ Character textures applied to skeleton:', characterFile);
                        
                    } catch (error) {
                        console.error('‚ùå Failed to load VRM character:', error);
                        statusDiv.textContent = `Failed to load character: ${error.message}`;
                    }
                } else if (!characterFile) {
                    // Reset to default skeleton if no character selected
                    if (characterSystem) {
                        characterSystem.setDisplayMode('skeleton');
                        document.getElementById('display-mode').value = 'skeleton';
                        statusDiv.textContent = 'Default skeleton mode';
                        document.getElementById('current-character').textContent = 'Default Skeleton';
                    }
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                }
            };
            
            window.changeDisplayMode = function() {
                const select = document.getElementById('display-mode');
                const mode = select.value;
                
                if (characterSystem) {
                    characterSystem.setDisplayMode(mode);
                    statusDiv.textContent = `Display mode: ${mode}`;
                    
                    // Update info panel
                    document.getElementById('display-mode-info').textContent = mode;
                    
                    console.log('üé≠ Display mode changed to:', mode);
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                }
            };
            
            window.toggleClassroom = function() {
                if (characterSystem) {
                    const visible = characterSystem.toggleClassroomVisibility();
                    classroomVisible = visible;
                    statusDiv.textContent = classroomVisible ? 'Classroom ON' : 'Classroom OFF';
                    
                    // Update info panel
                    document.getElementById('classroom-status').textContent = visible ? 'Visible' : 'Hidden';
                    
                    console.log('üè´ Classroom visibility:', visible ? 'ON' : 'OFF');
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                }
            };
            
            window.resetCharacterPosition = function() {
                if (characterSystem) {
                    characterSystem.resetCharacterPosition();
                    statusDiv.textContent = 'Character position reset';
                    console.log('‚Ü∫ Character position reset');
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                }
            };
            
            // Camera control functions
            window.setCameraMode = function(mode) {
                if (cameraController) {
                    cameraController.setCameraMode(mode);
                    statusDiv.textContent = `Camera mode: ${mode}`;
                    
                    // Update info panel
                    document.getElementById('camera-mode-info').textContent = mode;
                    
                    console.log('üìπ Camera mode changed to:', mode);
                } else {
                    console.warn('‚ö†Ô∏è Camera controller not ready');
                }
            };
            
            window.focusOnFace = function() {
                if (cameraController) {
                    cameraController.focusOnFace();
                    statusDiv.textContent = 'Camera focused on face';
                    console.log('üë§ Camera focused on face');
                } else {
                    console.warn('‚ö†Ô∏è Camera controller not ready');
                }
            };
            
            window.toggleFacialExpressions = function() {
                facialExpressionsEnabled = !facialExpressionsEnabled;
                
                if (characterSystem && characterSystem.facialExpressionSystem) {
                    if (facialExpressionsEnabled) {
                        characterSystem.facialExpressionSystem.setEmotion('neutral', 0.2);
                    } else {
                        characterSystem.facialExpressionSystem.setEmotion('neutral', 0.0);
                    }
                }
                
                statusDiv.textContent = `Facial expressions: ${facialExpressionsEnabled ? 'ON' : 'OFF'}`;
                console.log('üòä Facial expressions:', facialExpressionsEnabled ? 'ON' : 'OFF');
            };
            
            window.testImports = async function() {
                statusDiv.textContent = 'Testing module imports...';
                console.log('üîß Testing module imports manually...');
                
                try {
                    // Test import map imports
                    console.log('Testing THREE.js import...');
                    const threeModule = await import('three');
                    console.log('‚úÖ THREE.js import successful:', !!threeModule);
                    
                    console.log('Testing GLTFLoader import...');
                    const gltfModule = await import('three/examples/jsm/loaders/GLTFLoader.js');
                    console.log('‚úÖ GLTFLoader import successful:', !!gltfModule.GLTFLoader);
                    
                    console.log('Testing VRM import...');
                    const vrmModule = await import('@pixiv/three-vrm');
                    console.log('‚úÖ VRM import successful:', !!vrmModule.VRMLoaderPlugin);
                    
                    // Test actual VRM loading using our loader structure
                    console.log('Testing VRM file loading...');
                    
                    // Use the loaders from our structure
                    const GLTFLoader = window.THREELoaders?.GLTFLoader || gltfModule.GLTFLoader;
                    const VRMLoaderPlugin = window.THREELoaders?.VRMLoaderPlugin || vrmModule.VRMLoaderPlugin;
                    
                    const loader = new GLTFLoader();
                    if (VRMLoaderPlugin) {
                        loader.register((parser) => new VRMLoaderPlugin(parser));
                        console.log('VRM plugin registered for test');
                    }
                    
                    loader.load(
                        './assets/avatars/ichika.vrm',
                        (gltf) => {
                            console.log('‚úÖ VRM file loaded successfully:', gltf);
                            console.log('VRM scene objects:', gltf.scene.children.length);
                            console.log('VRM userData:', gltf.userData);
                            statusDiv.textContent = 'All imports working! VRM loaded successfully.';
                        },
                        (progress) => {
                            const percent = (progress.loaded / progress.total * 100).toFixed(1);
                            console.log('Loading progress:', percent + '%');
                            statusDiv.textContent = `Loading VRM... ${percent}%`;
                        },
                        (error) => {
                            console.error('‚ùå VRM loading failed:', error);
                            statusDiv.textContent = `VRM loading failed: ${error.message}`;
                        }
                    );
                    
                } catch (error) {
                    console.error('‚ùå Import test failed:', error);
                    statusDiv.textContent = `Import test failed: ${error.message}`;
                }
            };
            
            window.initBasicTexturedSkeleton = async function() {
                if (characterSystem) {
                    try {
                        statusDiv.textContent = 'Creating basic textured skeleton...';
                        console.log('üéØ Creating basic textured skeleton without VRM...');
                        
                        // Load classroom first
                        await characterSystem.loadClassroomEnvironment();
                        
                        // Create basic textured skeleton without VRM loading
                        if (characterSystem.materialExtractor) {
                            characterSystem.materialExtractor.createDefaultMaterials();
                            characterSystem.materialExtractor.applyMaterialsToSkeleton(characterSystem.bvhSkeleton);
                        } else {
                            // Create material extractor with default materials
                            characterSystem.materialExtractor = new window.VRMMaterialExtractor();
                            characterSystem.materialExtractor.createDefaultMaterials();
                            characterSystem.materialExtractor.applyMaterialsToSkeleton(characterSystem.bvhSkeleton);
                        }
                        
                        characterSystem.setDisplayMode('textured_skeleton');
                        
                        statusDiv.textContent = 'Basic textured skeleton created successfully!';
                        console.log('‚úÖ Basic textured skeleton complete');
                    } catch (error) {
                        console.error('‚ùå Failed to create basic textured skeleton:', error);
                        statusDiv.textContent = `Failed to create basic skeleton: ${error.message}`;
                    }
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                    statusDiv.textContent = 'Character system not ready';
                }
            };
            
            window.initTexturedSkeleton = async function() {
                if (characterSystem) {
                    try {
                        statusDiv.textContent = 'Initializing textured skeleton in classroom...';
                        console.log('üé® Manually initializing textured skeleton...');
                        
                        await characterSystem.initializeTexturedSkeletonInClassroom('ichika');
                        
                        statusDiv.textContent = 'Textured skeleton initialized successfully!';
                        console.log('‚úÖ Textured skeleton initialization complete');
                    } catch (error) {
                        console.error('‚ùå Failed to initialize textured skeleton:', error);
                        statusDiv.textContent = `Failed to initialize: ${error.message}`;
                    }
                } else {
                    console.warn('‚ö†Ô∏è Character system not ready');
                    statusDiv.textContent = 'Character system not ready';
                }
            };
            
            console.log('‚úÖ Character control functions initialized');
            
            // Assign functions defined inside initializeRSMTViewer to global scope
            try {
                console.log('üîÑ Assigning internal functions to global scope...');
                
                // Functions defined inside this function
                if (typeof toggleAnimation === 'function') window.toggleAnimation = toggleAnimation;
                if (typeof updateAnimationSpeed === 'function') window.updateAnimationSpeed = updateAnimationSpeed;
                if (typeof resetAnimation === 'function') window.resetAnimation = resetAnimation;
                if (typeof debugFrame === 'function') window.debugFrame = debugFrame;
                if (typeof fixOrientation === 'function') window.fixOrientation = fixOrientation;
                if (typeof flipDirection === 'function') window.flipDirection = flipDirection;
                if (typeof updateJointIntensity === 'function') window.updateJointIntensity = updateJointIntensity;
                if (typeof toggleSimpleMode === 'function') window.toggleSimpleMode = toggleSimpleMode;
                if (typeof debugBVH === 'function') window.debugBVH = debugBVH;
                if (typeof resetCharacterDirection === 'function') window.resetCharacterDirection = resetCharacterDirection;
                
                console.log('‚úÖ Internal functions assigned to global scope');
            } catch (error) {
                console.error('‚ùå Error assigning internal functions to global scope:', error);
            }
            
            // Call function to assign real implementations to global functions
            assignFunctionsToGlobalScope();
        }
        
        // === END OF initializeRSMTViewer FUNCTION ===
        
        // Function to assign actual implementations to global functions
        function assignFunctionsToGlobalScope() {
            console.log('üîÑ Assigning real function implementations to global scope...');
            
            try {
                // Assign functions that are defined globally
                if (typeof randomizeStyle === 'function') window.randomizeStyle = randomizeStyle;
                if (typeof smoothStyle === 'function') window.smoothStyle = smoothStyle;
                if (typeof aggressiveStyle === 'function') window.aggressiveStyle = aggressiveStyle;
                if (typeof analyzeCurrentMotion === 'function') window.analyzeCurrentMotion = analyzeCurrentMotion;
                
                // Note: Functions defined inside initializeRSMTViewer (like debugFrame, toggleAnimation, etc.)
                // are already assigned to global scope inside that function
                
                console.log('‚úÖ Real function implementations assigned to global scope');
            } catch (error) {
                console.error('‚ùå Error assigning real functions to global scope:', error);
            }
        }
        
        // Make warmup functions globally accessible (these are already defined globally)
        window.testServerConnection = testServerConnectionReal;
        window.warmupStyleVAE = warmupStyleVAEReal;
        window.warmupTransitionNet = warmupTransitionNetReal;
        window.warmupAllModels = warmupAllModelsReal;
        
        // Initialize placeholder functions (will be replaced after initialization)
        window.toggleAIMode = function() { console.log('toggleAIMode not yet initialized'); };
        window.randomizeStyle = function() { console.log('randomizeStyle not yet initialized'); };
        window.smoothStyle = function() { console.log('smoothStyle not yet initialized'); };
        window.aggressiveStyle = function() { console.log('aggressiveStyle not yet initialized'); };
        window.analyzeCurrentMotion = function() { console.log('analyzeCurrentMotion not yet initialized'); };
        window.toggleAnimation = function() { console.log('toggleAnimation not yet initialized'); };
        window.updateAnimationSpeed = function() { console.log('updateAnimationSpeed not yet initialized'); };
        window.resetAnimation = function() { console.log('resetAnimation not yet initialized'); };
        window.debugFrame = function() { console.log('debugFrame not yet initialized'); };
        window.fixOrientation = function() { console.log('fixOrientation not yet initialized'); };
        window.flipDirection = function() { console.log('flipDirection not yet initialized'); };
        window.updateJointIntensity = function() { console.log('updateJointIntensity not yet initialized'); };
        window.toggleSimpleMode = function() { console.log('toggleSimpleMode not yet initialized'); };
        window.debugBVH = function() { console.log('debugBVH not yet initialized'); };
        window.resetCharacterDirection = function() { console.log('resetCharacterDirection not yet initialized'); };
        
        console.log('‚úÖ All global function assignments complete');
        
        // Note: initializeRSMTViewer() is called after THREE.js loads in the main script section
    </script>
</body>
</html>
