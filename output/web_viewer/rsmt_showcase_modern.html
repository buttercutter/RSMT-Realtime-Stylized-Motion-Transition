<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization - Modern (r177)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #0084ff);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 212, 255, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            color: #4caf50;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            font-weight: bold;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #scene-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            font-size: 14px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .migration-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #4caf50, #45a049);
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 1001;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="migration-banner">
        ‚úÖ Modern THREE.js with ES Modules - No Deprecation Warnings!
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Modern RSMT Viewer...</div>
        <div id="loading-status">Initializing THREE.js...</div>
    </div>
    
    <div id="container">
        <div id="ui-panel">
            <div class="title">üé≠ RSMT Neural Network Motion System (Modern)</div>
            
            <!-- AI Inference Monitoring Dashboard -->
            <div class="ai-monitoring-panel" id="ai-monitoring" style="background: rgba(0, 50, 100, 0.15); border: 1px solid #00d4ff; padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">üß† AI Inference Monitor</strong>
                    <button id="toggle-inference-details" style="background: none; border: 1px solid #00d4ff; color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">Show Details</button>
                </div>
                
                <div class="inference-summary" id="inference-summary">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div class="model-status" id="deephase-status">
                            <div style="color: #00ff88; font-weight: bold;">DeepPhase</div>
                            <div style="font-size: 10px;">Ready</div>
                        </div>
                        <div class="model-status" id="stylevae-status">
                            <div style="color: #ff8800; font-weight: bold;">StyleVAE</div>
                            <div style="font-size: 10px;">Standby</div>
                        </div>
                        <div class="model-status" id="transitionnet-status">
                            <div style="color: #ff4488; font-weight: bold;">TransitionNet</div>
                            <div style="font-size: 10px;">Idle</div>
                        </div>
                    </div>
                    
                    <div class="inference-metrics" id="inference-metrics" style="border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
                            <div>Inference Rate: <span id="inference-rate">60 FPS</span></div>
                            <div>Latency: <span id="inference-latency">16ms</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="inference-details" id="inference-details" style="display: none; border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px; margin-top: 8px;">
                    <div class="inference-log" id="inference-log" style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                        <div style="color: #00d4ff;">AI Inference Log:</div>
                        <div style="color: #00ff88;">‚úì DeepPhase model loaded</div>
                        <div style="color: #ffaa00;">‚ö† StyleVAE on standby</div>
                        <div style="color: #ff6666;">‚ö† TransitionNet not connected</div>
                        <div style="color: #888;">Tensor Shapes:</div>
                            <div id="tensor-shapes">Waiting for inference...</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="play-pause">Play/Pause</button>
                <button id="reset">Reset</button>
                <button id="cycle-animations">Cycle Animations</button>
                <button id="random-style">Random Style</button>
                <button id="transition-demo">Demo Transitions</button>
                <button id="speed-up">Speed Up</button>
                <button id="slow-down">Slow Down</button>
                <button id="toggle-wireframe">Toggle Wireframe</button>
            </div>
            <div id="status" class="status">Ready</div>
        </div>
        
        <div class="info-panel">
            <div id="scene-info">
                <div class="metric">
                    <span>THREE.js Version:</span>
                    <span id="three-version">Loading...</span>
                </div>
                <div class="metric">
                    <span>Animation Frame:</span>
                    <span id="current-frame">0</span>
                </div>
                <div class="metric">
                    <span>Current Style:</span>
                    <span id="current-style">Neutral</span>
                </div>
                <div class="metric">
                    <span>Animation Speed:</span>
                    <span id="animation-speed">1.0x</span>
                </div>
                <div class="metric">
                    <span>Transition State:</span>
                    <span id="transition-state">Idle</span>
                </div>
                <div class="metric">
                    <span>Skeleton Joints:</span>
                    <span id="joint-count">15</span>
                </div>
                <div class="metric">
                    <span>Bone Connections:</span>
                    <span id="bone-count">13</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        console.log('üöÄ Starting Modern RSMT Viewer with ES Modules...');
        
        const loadingDiv = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        // Update loading status
        function updateLoadingStatus(message) {
            loadingStatus.textContent = message;
            console.log('üìù', message);
        }
        
        // Global variables for animation and BVH data
        let isPlaying = true;
        let currentStyle = 'neutral';
        let animationSpeed = 1.0;
        let isWireframe = false;
        let bvhData = {};
        let currentAnimation = 'neutral_reference.bvh';
        let animationFrame = 0;
        
        // Global THREE.js objects (will be initialized in try block)
        let scene, camera, renderer, skeletonGroup;
        let jointMeshes = {};
        let boneCylinders = [];
        let jointWorldPositions = {};
        
        // Available BVH animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                duration: 120
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                duration: 100
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                duration: 110
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                duration: 140
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                duration: 115
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, precise walking style',
                duration: 90
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Confident, stylish walking motion',
                duration: 105
            }
        };
        
        try {
            updateLoadingStatus('Importing THREE.js module...');
            
            // Import THREE.js using ES modules
            const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js');
            
            updateLoadingStatus('THREE.js loaded successfully!');
            
            // Update version info
            document.getElementById('three-version').textContent = THREE.REVISION || 'ES Module';
            
            // Initialize 3D scene
            updateLoadingStatus('Creating 3D scene...');
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            const camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add renderer to container (below UI)
            container.appendChild(renderer.domElement);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '1';
            
            updateLoadingStatus('Setting up enhanced lighting and environment...');
            
            // Enhanced lighting setup like legacy version
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add additional lighting for better visibility
            const pointLight1 = new THREE.PointLight(0x4444ff, 0.5, 100);
            pointLight1.position.set(-5, 5, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff4444, 0.5, 100);
            pointLight2.position.set(5, 5, -5);
            scene.add(pointLight2);
            
            // Add grid floor and axes helpers like legacy version
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            updateLoadingStatus('Creating demo skeleton...');
            
            // Create a simple stick figure skeleton for demo
            skeletonGroup = new THREE.Group();
            
            // Create joints with proper geometry and materials (matching legacy)
            const jointGeometry = new THREE.SphereGeometry(0.04, 12, 12);
            const jointMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            
            // Create bone geometry and material (matching legacy style)
            const boneGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const boneMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0088ff,
                emissive: 0x001122
            });
            
            // ===== CORRECT BVH-MATCHING SKELETON =====
            // This skeleton matches the actual BVH file structure from 100STYLE dataset
            const bvhJoints = {
                // Root joint (world position)
                'Hips': { offset: [0.00, 0.00, 0.00], parent: null },
                
                // Spine chain
                'Chest': { offset: [0.00, 12.95, -0.03], parent: 'Hips' },
                'Chest2': { offset: [0.00, 10.28, 0.05], parent: 'Chest' },
                'Chest3': { offset: [0.00, 9.29, 0.00], parent: 'Chest2' },
                'Chest4': { offset: [0.00, 9.29, 0.00], parent: 'Chest3' },
                'Neck': { offset: [0.00, 13.30, 0.00], parent: 'Chest4' },
                'Head': { offset: [0.00, 8.96, 0.10], parent: 'Neck' },
                
                // Right arm chain
                'RightCollar': { offset: [-3.19, 7.45, 0.00], parent: 'Chest4' },
                'RightShoulder': { offset: [-15.79, 0.00, 0.00], parent: 'RightCollar' },
                'RightElbow': { offset: [-31.15, 0.00, 0.00], parent: 'RightShoulder' },
                'RightWrist': { offset: [-25.54, 0.00, 0.00], parent: 'RightElbow' },
                
                // Left arm chain
                'LeftCollar': { offset: [3.19, 7.45, 0.00], parent: 'Chest4' },
                'LeftShoulder': { offset: [15.79, 0.00, 0.00], parent: 'LeftCollar' },
                'LeftElbow': { offset: [31.15, 0.00, 0.00], parent: 'LeftShoulder' },
                'LeftWrist': { offset: [25.54, 0.00, 0.00], parent: 'LeftElbow' },
                
                // Right leg chain
                'RightHip': { offset: [-10.75, 0.14, 0.01], parent: 'Hips' },
                'RightKnee': { offset: [0.00, -43.74, -0.01], parent: 'RightHip' },
                'RightAnkle': { offset: [0.00, -43.21, 0.09], parent: 'RightKnee' },
                'RightToe': { offset: [0.00, -9.70, 19.15], parent: 'RightAnkle' },
                
                // Left leg chain
                'LeftHip': { offset: [10.75, 0.14, 0.01], parent: 'Hips' },
                'LeftKnee': { offset: [0.00, -43.74, -0.01], parent: 'LeftHip' },
                'LeftAnkle': { offset: [0.00, -43.21, 0.09], parent: 'LeftKnee' },
                'LeftToe': { offset: [0.00, -9.70, 19.15], parent: 'LeftAnkle' }
            };
            
            // Scale factor to convert BVH units to reasonable display size
            const bvhScale = 0.015; // Smaller scale for better proportions
            
            // Create hierarchical skeleton with proper parent-child relationships
            function createHierarchicalSkeleton(joints) {
                const jointMeshes = {};
                const processedJoints = new Set();
                
                function createJoint(jointName) {
                    if (processedJoints.has(jointName) || !joints[jointName]) {
                        return jointMeshes[jointName] || null;
                    }
                    
                    const jointData = joints[jointName];
                    
                    // Create joint mesh
                    const mesh = new THREE.Mesh(jointGeometry, jointMaterial);
                    mesh.userData.bvhJointName = jointName;
                    mesh.userData.isJoint = true;
                    
                    // Set local position relative to parent
                    mesh.position.set(
                        jointData.offset[0] * bvhScale,
                        jointData.offset[1] * bvhScale,
                        jointData.offset[2] * bvhScale
                    );
                    
                    jointMeshes[jointName] = mesh;
                    processedJoints.add(jointName);
                    
                    // Add to parent or root
                    if (jointData.parent && joints[jointData.parent]) {
                        // Ensure parent exists first
                        const parentMesh = createJoint(jointData.parent);
                        if (parentMesh) {
                            parentMesh.add(mesh);
                        } else {
                            skeletonGroup.add(mesh);
                        }
                    } else {
                        // Root joint
                        skeletonGroup.add(mesh);
                    }
                    
                    return mesh;
                }
                
                // Create all joints with proper hierarchy
                for (const jointName of Object.keys(joints)) {
                    createJoint(jointName);
                }
                
                return jointMeshes;
            }
            
            jointMeshes = createHierarchicalSkeleton(bvhJoints);
            
            // Create bones connecting parent-child joints
            boneCylinders = [];
            
            for (const [jointName, jointData] of Object.entries(bvhJoints)) {
                if (jointData.parent && jointMeshes[jointData.parent] && jointMeshes[jointName]) {
                    const parentMesh = jointMeshes[jointData.parent];
                    const childMesh = jointMeshes[jointName];
                    
                    // Calculate bone length from local position
                    const localPos = childMesh.position;
                    const length = localPos.length();
                    
                    if (length > 0.01) { // Only create visible bones
                        const cylinder = new THREE.Mesh(boneGeometry, boneMaterial);
                        
                        // Position bone at parent's origin, pointing toward child
                        cylinder.position.set(0, 0, 0);
                        cylinder.scale.set(1, length, 1);
                        
                        // Rotate to point toward child
                        const direction = localPos.clone().normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        cylinder.quaternion.setFromUnitVectors(up, direction);
                        
                        // Offset to start at parent center and extend to child
                        cylinder.position.copy(direction.multiplyScalar(length * 0.5));
                        
                        // Add bone to parent joint so it moves with the joint
                        parentMesh.add(cylinder);
                        
                        cylinder.userData = {
                            parentJoint: jointData.parent,
                            childJoint: jointName,
                            length: length
                        };
                        
                        boneCylinders.push(cylinder);
                    }
                }
            }
            
            // Function to update bone positions (simplified since bones are now parented to joints)
            function updateBones() {
                // Bones automatically follow their parent joints due to hierarchy
                // No manual updates needed - THREE.js handles this automatically
            }
            
            scene.add(skeletonGroup);
            
            // Fix BVH coordinate system - ensure character appears right-side up
            // Many BVH files use different coordinate conventions than THREE.js
            skeletonGroup.position.y = 0; // Start at ground level
            
            // Update skeleton metrics
            document.getElementById('joint-count').textContent = Object.keys(jointMeshes).length;
            document.getElementById('bone-count').textContent = boneCylinders.length;
            
            // Position camera
            camera.position.set(3, 2, 3);
            camera.lookAt(0, 0.5, 0);
            
            updateLoadingStatus('Starting animation...');
            
            // Animation styles with different parameters
            const animationStyles = {
                neutral: { speed: 1.0, intensity: 1.0, bounce: 0.1, description: 'Natural walking' },
                happy: { speed: 1.3, intensity: 1.5, bounce: 0.3, description: 'Bouncy, energetic' },
                sad: { speed: 0.7, intensity: 0.5, bounce: 0.05, description: 'Slow, heavy steps' },
                angry: { speed: 1.2, intensity: 2.0, bounce: 0.1, description: 'Aggressive, forceful' },
                energetic: { speed: 1.8, intensity: 1.8, bounce: 0.4, description: 'High energy' },
                graceful: { speed: 0.9, intensity: 0.8, bounce: 0.2, description: 'Smooth, elegant' },
                robotic: { speed: 1.0, intensity: 1.0, bounce: 0.0, description: 'Mechanical, stiff' }
            };
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                if (isPlaying) {
                    animationFrame++;
                    
                    // Use real BVH animation data if available
                    if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                        const frames = bvhData[currentAnimation].frames;
                        const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                        const frameData = frames[frameIndex];
                        
                        // Apply real BVH frame data to skeleton
                        applyBVHFrame(frameData);
                        
                        // Update bone connections to follow joint movements
                        updateBones();
                        
                        // Update frame counter
                        document.getElementById('current-frame').textContent = frameIndex + '/' + frames.length;
                        
                    } else {
                        // Fallback to procedural animation if BVH not loaded
                        const style = animationStyles[currentStyle] || animationStyles.neutral;
                        
                        // Enhanced walking animation with style variations
                        const time = animationFrame * 0.05 * style.speed * animationSpeed;
                        const walkCycle = Math.sin(time) * style.intensity;
                        const walkCycle2 = Math.sin(time + Math.PI) * style.intensity;
                        const bounce = Math.abs(Math.sin(time)) * style.bounce;
                        
                        // Animate leg swinging with style
                        if (jointMeshes.LeftLeg) {
                            const legSwing = currentStyle === 'robotic' ? 
                                Math.sign(walkCycle) * 0.3 : walkCycle * 0.3;
                            jointMeshes.LeftLeg.position.z = legSwing;
                            jointMeshes.LeftFoot.position.z = legSwing * 1.5;
                            jointMeshes.LeftFoot.position.y = 0.1 + Math.abs(legSwing) * 0.4 + bounce;
                        }
                        if (jointMeshes.RightLeg) {
                            const legSwing = currentStyle === 'robotic' ? 
                                Math.sign(walkCycle2) * 0.3 : walkCycle2 * 0.3;
                            jointMeshes.RightLeg.position.z = legSwing;
                            jointMeshes.RightFoot.position.z = legSwing * 1.5;
                            jointMeshes.RightFoot.position.y = 0.1 + Math.abs(legSwing) * 0.4 + bounce;
                        }
                        
                        // Update bone connections
                        updateBones();
                        
                        // Update frame counter for fallback
                        document.getElementById('current-frame').textContent = animationFrame;
                    }
                    
                    // Update UI displays
                    document.getElementById('animation-speed').textContent = `${animationSpeed.toFixed(1)}x`;
                }
                
                // Don't rotate the scene - let BVH data control all rotation
                // skeletonGroup.rotation.y += 0.005; // REMOVED: This was causing spinning
                
                renderer.render(scene, camera);
            }
            
            // Setup enhanced controls
            document.getElementById('play-pause').onclick = () => {
                isPlaying = !isPlaying;
                statusDiv.textContent = isPlaying ? 'Playing' : 'Paused';
            };
            
            document.getElementById('reset').onclick = () => {
                animationFrame = 0;
                skeletonGroup.rotation.y = 0;
                animationSpeed = 1.0;
                currentStyle = 'neutral';
                document.getElementById('current-style').textContent = currentStyle;
                statusDiv.textContent = 'Reset to neutral';
            };
            
            document.getElementById('cycle-animations').onclick = () => {
                // Cycle through real BVH animations
                const animFiles = Object.keys(animations);
                const currentIndex = animFiles.indexOf(currentAnimation);
                const nextFile = animFiles[(currentIndex + 1) % animFiles.length];
                
                loadAnimation(nextFile);
                statusDiv.textContent = `Loading: ${animations[nextFile].name}`;
            };
            
            document.getElementById('random-style').onclick = () => {
                // Load random BVH animation
                const animFiles = Object.keys(animations);
                const randomFile = animFiles[Math.floor(Math.random() * animFiles.length)];
                
                loadAnimation(randomFile);
                statusDiv.textContent = `Random: ${animations[randomFile].name}`;
            };
            
            document.getElementById('speed-up').onclick = () => {
                animationSpeed = Math.min(3.0, animationSpeed * 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('slow-down').onclick = () => {
                animationSpeed = Math.max(0.2, animationSpeed / 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('toggle-wireframe').onclick = () => {
                isWireframe = !isWireframe;
                // Toggle wireframe on joint materials
                Object.values(jointMeshes).forEach(joint => {
                    joint.material.wireframe = isWireframe;
                });
                statusDiv.textContent = isWireframe ? 'Wireframe ON' : 'Wireframe OFF';
            };
            
            document.getElementById('transition-demo').onclick = () => {
                statusDiv.textContent = 'Running animation transition demo...';
                document.getElementById('transition-state').textContent = 'Active';
                
                // Cycle through different BVH animations
                const animFiles = Object.keys(animations);
                let animIndex = 0;
                
                const transitionInterval = setInterval(() => {
                    const animFile = animFiles[animIndex];
                    loadAnimation(animFile);
                    const animData = animations[animFile];
                    document.getElementById('current-style').textContent = animData.name;
                    statusDiv.textContent = `Transition: ${animData.name} - ${animData.description}`;
                    animIndex = (animIndex + 1) % animFiles.length;
                    
                    if (animIndex === 0) {
                        clearInterval(transitionInterval);
                        document.getElementById('transition-state').textContent = 'Complete';
                        statusDiv.textContent = 'Animation transition demo completed';
                        loadAnimation('neutral_reference.bvh');
                        document.getElementById('current-style').textContent = 'Neutral Walking';
                    }
                }, 2000);
            };
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Start animation loop and load first animation
            animate();
            
            // Load default animation
            updateLoadingStatus('Loading default animation...');
            loadAnimation('neutral_reference.bvh');
            
            // Hide loading screen
            updateLoadingStatus('Complete!');
            setTimeout(() => {
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Modern RSMT Viewer Ready! Loading real BVH animations.';
            }, 1000);
            
        } catch (error) {
            console.error('‚ùå Error loading THREE.js:', error);
            updateLoadingStatus('Error: ' + error.message);
            statusDiv.textContent = 'Error loading 3D engine';
            statusDiv.className = 'error';
            
            // Hide loading screen even on error
            setTimeout(() => {
                loadingDiv.style.display = 'none';
            }, 3000);
        }
        
        // Load and parse BVH animation files
        async function loadAnimation(filename) {
            try {
                console.log('üé¨ Loading animation:', filename);
                statusDiv.textContent = `Loading ${filename}...`;
                
                // Try to load actual BVH data
                try {
                    console.log('üì° Fetching BVH file:', filename);
                    const response = await fetch(filename);
                    console.log('üîç Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const bvhText = await response.text();
                        console.log('üìÑ BVH text length:', bvhText.length, 'characters');
                        
                        bvhData[filename] = parseBVHData(bvhText);
                        console.log('‚úÖ BVH data parsed for', filename, '- Frames:', bvhData[filename].frames?.length);
                        
                        currentAnimation = filename;
                        animationFrame = 0;
                        statusDiv.textContent = `Loaded ${animations[filename]?.name || filename}`;
                        
                    } else {
                        throw new Error(`BVH file not found: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not load BVH file:', error);
                    statusDiv.textContent = `BVH load failed, using fallback animation`;
                }
                
            } catch (error) {
                console.error('‚ùå Failed to load animation:', error);
                statusDiv.textContent = 'Animation load failed';
            }
        }
        
        // Enhanced BVH parser
        function parseBVHData(bvhText) {
            const lines = bvhText.split('\n');
            let motionIndex = -1;
            let frameTimeIndex = -1;
            
            // Find MOTION section
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('MOTION')) {
                    motionIndex = i;
                    break;
                }
            }
            
            if (motionIndex === -1) {
                throw new Error('No MOTION section found in BVH');
            }
            
            // Find frame time
            for (let i = motionIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('Frame Time:')) {
                    frameTimeIndex = i;
                    break;
                }
            }
            
            // Parse frame data
            const frames = [];
            const frameTime = frameTimeIndex >= 0 ? 
                parseFloat(lines[frameTimeIndex].split(':')[1]) || 0.016667 : 0.016667;
            
            console.log('üìä Parsing BVH - Frame time:', frameTime);
            
            // Parse all frame data starting after Frame Time line
            const startLine = frameTimeIndex >= 0 ? frameTimeIndex + 1 : motionIndex + 3;
            
            for (let i = startLine; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && line.length > 0) {
                    const values = line.split(/\s+/).map(parseFloat);
                    if (values.length > 0 && !isNaN(values[0])) {
                        frames.push(values);
                    }
                }
            }
            
            console.log('üìä Parsed', frames.length, 'frames with', frames[0]?.length || 0, 'channels each');
            
            return {
                frames,
                frameTime,
                frameCount: frames.length,
                channelCount: frames[0]?.length || 0
            };
        }
        
        // Apply BVH frame data to skeleton
        function applyBVHFrame(frameData) {
            if (!frameData || frameData.length < 6) return;
            
            let channelIndex = 0;
            
            // Root position (first 3 channels)
            const rootX = frameData[channelIndex++] || 0;
            const rootY = frameData[channelIndex++] || 0;
            const rootZ = frameData[channelIndex++] || 0;
            
            // Root rotation (next 3 channels)
            const rootRotX = (frameData[channelIndex++] || 0) * Math.PI / 180;
            const rootRotY = (frameData[channelIndex++] || 0) * Math.PI / 180;
            const rootRotZ = (frameData[channelIndex++] || 0) * Math.PI / 180;
            
            // Apply root transformation to skeleton (with BVH coordinate conversion)
            if (skeletonGroup) {
                // Position: scale down and adjust coordinate system
                skeletonGroup.position.set(
                    rootX * 0.01,     // X: left/right
                    rootY * 0.01,     // Y: up/down (keep as-is for now)
                    -rootZ * 0.01     // Z: forward/back (flip for THREE.js)
                );
                
                // Rotation: DON'T apply to entire skeleton - this was causing the spinning!
                // skeletonGroup.rotation.set(-rootRotX, rootRotY, -rootRotZ);
                // Individual joint rotations will be applied below instead
            }
            
            // Apply joint rotations using correct BVH joint order
            const bvhJointOrder = [
                'Chest',          // 3 rotation channels
                'Chest2',         // 3 rotation channels  
                'Chest3',         // 3 rotation channels
                'Chest4',         // 3 rotation channels
                'Neck',           // 3 rotation channels
                'Head',           // 3 rotation channels
                'RightCollar',    // 3 rotation channels
                'RightShoulder',  // 3 rotation channels
                'RightElbow',     // 3 rotation channels
                'RightWrist',     // 3 rotation channels
                'LeftCollar',     // 3 rotation channels
                'LeftShoulder',   // 3 rotation channels
                'LeftElbow',      // 3 rotation channels
                'LeftWrist',      // 3 rotation channels
                'RightHip',       // 3 rotation channels
                'RightKnee',      // 3 rotation channels
                'RightAnkle',     // 3 rotation channels
                'RightToe',       // 3 rotation channels
                'LeftHip',        // 3 rotation channels
                'LeftKnee',       // 3 rotation channels
                'LeftAnkle',      // 3 rotation channels
                'LeftToe'         // 3 rotation channels
            ];
            
            bvhJointOrder.forEach(jointName => {
                if (jointMeshes[jointName] && channelIndex + 2 < frameData.length) {
                    const rotX = (frameData[channelIndex++] || 0) * Math.PI / 180;
                    const rotY = (frameData[channelIndex++] || 0) * Math.PI / 180;
                    const rotZ = (frameData[channelIndex++] || 0) * Math.PI / 180;
                    
                    // Apply rotation to individual joint (not the whole skeleton)
                    jointMeshes[jointName].rotation.set(rotX, rotY, rotZ);
                }
            });
        }
        
        // Toggle function for inference details (from legacy)
        function toggleInferenceDetails() {
            const details = document.getElementById('inference-details');
            const button = document.getElementById('toggle-inference-details');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                button.textContent = 'Hide Details';
            } else {
                details.style.display = 'none';
                button.textContent = 'Show Details';
            }
        }
        
        // Add event listener for the toggle button
        document.getElementById('toggle-inference-details').onclick = toggleInferenceDetails;
    </script>
</body>
</html>
