<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization - Modern (r177)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #0084ff);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 212, 255, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            color: #4caf50;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            font-weight: bold;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #scene-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            font-size: 14px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .migration-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #4caf50, #45a049);
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 1001;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="migration-banner">
        ✅ Modern THREE.js with ES Modules - No Deprecation Warnings!
    </div>
    
    <div class="migration-banner" style="background: rgba(0, 150, 0, 0.8); border-color: #00ff00;">
        🎯 Pure BVH Mode - All constraints removed, using 100% unmodified motion capture data
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Modern RSMT Viewer...</div>
        <div id="loading-status">Initializing THREE.js...</div>
    </div>
    
    <div id="container">
        <div id="ui-panel">
            <div class="title">🎭 RSMT Neural Network Motion System (Modern)</div>
            
            <!-- AI Inference Monitoring Dashboard -->
            <div class="ai-monitoring-panel" id="ai-monitoring" style="background: rgba(0, 50, 100, 0.15); border: 1px solid #00d4ff; padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">🧠 AI Inference Monitor</strong>
                    <button id="toggle-inference-details" style="background: none; border: 1px solid #00d4ff; color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">Show Details</button>
                </div>
                
                <div class="inference-summary" id="inference-summary">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div class="model-status" id="deephase-status">
                            <div style="color: #00ff88; font-weight: bold;">DeepPhase</div>
                            <div style="font-size: 10px;">Ready</div>
                        </div>
                        <div class="model-status" id="stylevae-status">
                            <div style="color: #ff8800; font-weight: bold;">StyleVAE</div>
                            <div style="font-size: 10px;">Standby</div>
                        </div>
                        <div class="model-status" id="transitionnet-status">
                            <div style="color: #ff4488; font-weight: bold;">TransitionNet</div>
                            <div style="font-size: 10px;">Idle</div>
                        </div>
                    </div>
                    
                    <div class="inference-metrics" id="inference-metrics" style="border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
                            <div>Inference Rate: <span id="inference-rate">60 FPS</span></div>
                            <div>Latency: <span id="inference-latency">16ms</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="inference-details" id="inference-details" style="display: none; border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px; margin-top: 8px;">
                    <div class="inference-log" id="inference-log" style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                        <div style="color: #00d4ff;">AI Inference Log:</div>
                        <div style="color: #00ff88;">✓ DeepPhase model loaded</div>
                        <div style="color: #ffaa00;">⚠ StyleVAE on standby</div>
                        <div style="color: #ff6666;">⚠ TransitionNet not connected</div>
                        <div style="color: #888;">Tensor Shapes:</div>
                            <div id="tensor-shapes">Waiting for inference...</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="play-pause">Play/Pause</button>
                <button id="reset">Reset</button>
                <button id="cycle-animations">Cycle Animations</button>
                <button id="random-style">Random Style</button>
                <button id="transition-demo">Demo Transitions</button>
                <button id="speed-up">Speed Up</button>
                <button id="slow-down">Slow Down</button>
                <button id="toggle-wireframe">Toggle Wireframe</button>
            </div>
            <div id="status" class="status">Ready</div>
        </div>
        
        <div class="info-panel">
            <div id="scene-info">
                <div class="metric">
                    <span>THREE.js Version:</span>
                    <span id="three-version">Loading...</span>
                </div>
                <div class="metric">
                    <span>Animation Frame:</span>
                    <span id="current-frame">0</span>
                </div>
                <div class="metric">
                    <span>Current Style:</span>
                    <span id="current-style">Neutral</span>
                </div>
                <div class="metric">
                    <span>Animation Speed:</span>
                    <span id="animation-speed">0.3x</span>
                </div>
                <div class="metric">
                    <span>Transition State:</span>
                    <span id="transition-state">Idle</span>
                </div>
                <div class="metric">
                    <span>Skeleton Joints:</span>
                    <span id="joint-count">15</span>
                </div>
                <div class="metric">
                    <span>Bone Connections:</span>
                    <span id="bone-count">13</span>
                </div>
            </div>
            
            <!-- Animation Controls -->
            <div class="controls" style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                <h3 style="margin: 0 0 10px 0; color: #fff;">Animation Controls</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <button onclick="toggleAnimation()" id="play-pause-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Pause</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Speed:</label>
                        <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="0.3" style="width: 100px;" onchange="updateAnimationSpeed(this.value)">
                        <span id="speed-value" style="color: #fff; min-width: 40px;">0.3x</span>
                    </div>
                    <button onclick="resetAnimation()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                    <button onclick="debugFrame()" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug Frame</button>
                    <button onclick="fixOrientation()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Fix Orientation (DISABLED)</button>
                    <button onclick="flipDirection()" style="padding: 8px 16px; background: #E91E63; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Flip Direction (DISABLED)</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Joint Intensity:</label>
                        <input type="range" id="intensity-slider" min="0.01" max="1.0" step="0.01" value="0.1" style="width: 100px;" onchange="updateJointIntensity(this.value)">
                        <span id="intensity-value" style="color: #fff; min-width: 40px;">0.1</span>
                    </div>
                    <button onclick="toggleSimpleMode()" id="simple-mode-btn" style="padding: 8px 16px; background: #607D8B; color: white; border: none; border-radius: 4px; cursor: pointer;">Simple Mode</button>
                    <button onclick="debugBVH()" style="padding: 8px 16px; background: #795548; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug BVH</button>
                    <button onclick="resetCharacterDirection()" style="padding: 8px 16px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Reset Direction</button>
                    <!-- REMOVED: Root Constraint slider - using pure BVH data with no constraints -->
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        console.log('🚀 Starting Modern RSMT Viewer with ES Modules...');
        
        const loadingDiv = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        // Update loading status
        function updateLoadingStatus(message) {
            loadingStatus.textContent = message;
            console.log('📝', message);
        }
        
        // Global variables for animation and BVH data
        let isPlaying = true;
        let currentStyle = 'neutral';
        let animationSpeed = 0.3; // Much slower default speed
        let isWireframe = false;
        let bvhData = {};
        let currentAnimation = 'neutral_reference.bvh';
        let animationFrame = 0;
        let bvhScale = 0.01; // Scale factor for BVH units
        
        // Global THREE.js objects (will be initialized in try block)
        let scene, camera, renderer, skeletonGroup;
        let jointMeshes = {};
        let boneCylinders = [];
        let jointWorldPositions = {};
        
        // Available BVH animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                duration: 120
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                duration: 100
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                duration: 110
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                duration: 140
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                duration: 115
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, precise walking style',
                duration: 90
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Confident, stylish walking motion',
                duration: 105
            }
        };
        
        try {
            updateLoadingStatus('Importing THREE.js module...');
            
            // Import THREE.js using ES modules
            const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js');
            
            updateLoadingStatus('THREE.js loaded successfully!');
            
            // Update version info
            document.getElementById('three-version').textContent = THREE.REVISION || 'ES Module';
            
            // Initialize 3D scene
            updateLoadingStatus('Creating 3D scene...');
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            const camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add renderer to container (below UI)
            container.appendChild(renderer.domElement);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '1';
            
            updateLoadingStatus('Setting up enhanced lighting and environment...');
            
            // Enhanced lighting setup like legacy version
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add additional lighting for better visibility
            const pointLight1 = new THREE.PointLight(0x4444ff, 0.5, 100);
            pointLight1.position.set(-5, 5, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff4444, 0.5, 100);
            pointLight2.position.set(5, 5, -5);
            scene.add(pointLight2);
            
            // Add grid floor and axes helpers like legacy version
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            updateLoadingStatus('Creating demo skeleton...');
            
            // Create a simple stick figure skeleton for demo
            skeletonGroup = new THREE.Group();
            
            // Create joints with proper geometry and materials (matching legacy)
            const jointGeometry = new THREE.SphereGeometry(0.04, 12, 12);
            const jointMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            
            // Create bone geometry and material (matching legacy style)
            const boneGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const boneMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0088ff,
                emissive: 0x001122
            });
            
            // ===== CORRECT BVH SKELETON FROM ACTUAL 100STYLE FILES =====
            // This matches the EXACT structure from Neutral_FW.bvh
            const bvhJoints = {
                // Root joint (world position) - 6 channels: pos + rot
                'Hips': { offset: [0.000000, 0.000000, 0.000000], parent: null },
                
                // Spine chain - exact offsets from BVH
                'Chest': { offset: [0.000000, 12.953391, -0.028419], parent: 'Hips' },
                'Chest2': { offset: [0.000000, 10.280254, 0.051622], parent: 'Chest' },
                'Chest3': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest2' },
                'Chest4': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest3' },
                'Neck': { offset: [0.000000, 13.296264, 0.000000], parent: 'Chest4' },
                'Head': { offset: [0.000000, 8.959264, 0.099003], parent: 'Neck' },
                
                // Right arm chain - exact offsets from BVH
                'RightCollar': { offset: [-3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'RightShoulder': { offset: [-15.792092, 0.000000, 0.000000], parent: 'RightCollar' },
                'RightElbow': { offset: [-31.151839, 0.000000, 0.000000], parent: 'RightShoulder' },
                'RightWrist': { offset: [-25.536298, 0.000000, 0.002321], parent: 'RightElbow' },
                
                // Left arm chain - will be mirrored
                'LeftCollar': { offset: [3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'LeftShoulder': { offset: [15.792092, 0.000000, 0.000000], parent: 'LeftCollar' },
                'LeftElbow': { offset: [31.151839, 0.000000, 0.000000], parent: 'LeftShoulder' },
                'LeftWrist': { offset: [25.536298, 0.000000, 0.002321], parent: 'LeftElbow' },
                
                // Right leg chain - exact offsets from BVH
                'RightHip': { offset: [-10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'RightKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'RightHip' },
                'RightAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'RightKnee' },
                'RightToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'RightAnkle' },
                
                // Left leg chain - mirrored from BVH
                'LeftHip': { offset: [10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'LeftKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'LeftHip' },
                'LeftAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'LeftKnee' },
                'LeftToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'LeftAnkle' }
            };
            
            
            // Create hierarchical skeleton with proper parent-child relationships
            function createHierarchicalSkeleton(joints) {
                const jointMeshes = {};
                const processedJoints = new Set();
                
                function createJoint(jointName) {
                    if (processedJoints.has(jointName) || !joints[jointName]) {
                        return jointMeshes[jointName] || null;
                    }
                    
                    const jointData = joints[jointName];
                    
                    // Create joint mesh
                    const mesh = new THREE.Mesh(jointGeometry, jointMaterial);
                    mesh.userData.bvhJointName = jointName;
                    mesh.userData.isJoint = true;
                    
                    // Set local position relative to parent
                    mesh.position.set(
                        jointData.offset[0] * bvhScale,
                        jointData.offset[1] * bvhScale,
                        jointData.offset[2] * bvhScale
                    );
                    
                    jointMeshes[jointName] = mesh;
                    processedJoints.add(jointName);
                    
                    // Add to parent or root
                    if (jointData.parent && joints[jointData.parent]) {
                        // Ensure parent exists first
                        const parentMesh = createJoint(jointData.parent);
                        if (parentMesh) {
                            parentMesh.add(mesh);
                        } else {
                            skeletonGroup.add(mesh);
                        }
                    } else {
                        // Root joint
                        skeletonGroup.add(mesh);
                    }
                    
                    return mesh;
                }
                
                // Create all joints with proper hierarchy
                for (const jointName of Object.keys(joints)) {
                    createJoint(jointName);
                }
                
                return jointMeshes;
            }
            
            jointMeshes = createHierarchicalSkeleton(bvhJoints);
            
            // Create bones connecting parent-child joints
            boneCylinders = [];
            
            for (const [jointName, jointData] of Object.entries(bvhJoints)) {
                if (jointData.parent && jointMeshes[jointData.parent] && jointMeshes[jointName]) {
                    const parentMesh = jointMeshes[jointData.parent];
                    const childMesh = jointMeshes[jointName];
                    
                    // Calculate bone length from local position
                    const localPos = childMesh.position;
                    const length = localPos.length();
                    
                    if (length > 0.01) { // Only create visible bones
                        const cylinder = new THREE.Mesh(boneGeometry, boneMaterial);
                        
                        // Position bone at parent's origin, pointing toward child
                        cylinder.position.set(0, 0, 0);
                        cylinder.scale.set(1, length, 1);
                        
                        // Rotate to point toward child
                        const direction = localPos.clone().normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        cylinder.quaternion.setFromUnitVectors(up, direction);
                        
                        // Offset to start at parent center and extend to child
                        cylinder.position.copy(direction.multiplyScalar(length * 0.5));
                        
                        // Add bone to parent joint so it moves with the joint
                        parentMesh.add(cylinder);
                        
                        cylinder.userData = {
                            parentJoint: jointData.parent,
                            childJoint: jointName,
                            length: length
                        };
                        
                        boneCylinders.push(cylinder);
                    }
                }
            }
            
            // Function to update bone positions (simplified since bones are now parented to joints)
            function updateBones() {
                // Bones automatically follow their parent joints due to hierarchy
                // No manual updates needed - THREE.js handles this automatically
            }
            
            scene.add(skeletonGroup);
            
            // DEBUG: Add a larger test sphere at skeleton origin
            const originGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const originSphere = new THREE.Mesh(originGeometry, originMaterial);
            originSphere.position.set(0, 0, 0); // At origin where skeleton should be
            originSphere.name = 'originSphere';
            scene.add(originSphere);
            
            // Let BVH data control the orientation - no manual corrections
            skeletonGroup.position.y = 0; // Start at ground level
            skeletonGroup.rotation.set(0, 0, 0); // No base rotation
            skeletonGroup.rotation.order = 'YXZ'; // Match BVH rotation order
            
            // Update skeleton metrics
            document.getElementById('joint-count').textContent = Object.keys(jointMeshes).length;
            document.getElementById('bone-count').textContent = boneCylinders.length;
            
            // Position camera
            camera.position.set(3, 2, 3);
            camera.lookAt(0, 0.5, 0);
            
            updateLoadingStatus('Starting animation...');
            
            // Animation styles with different parameters
            const animationStyles = {
                neutral: { speed: 1.0, intensity: 1.0, bounce: 0.1, description: 'Natural walking' },
                happy: { speed: 1.3, intensity: 1.5, bounce: 0.3, description: 'Bouncy, energetic' },
                sad: { speed: 0.7, intensity: 0.5, bounce: 0.05, description: 'Slow, heavy steps' },
                angry: { speed: 1.2, intensity: 2.0, bounce: 0.1, description: 'Aggressive, forceful' },
                energetic: { speed: 1.8, intensity: 1.8, bounce: 0.4, description: 'High energy' },
                graceful: { speed: 0.9, intensity: 0.8, bounce: 0.2, description: 'Smooth, elegant' },
                robotic: { speed: 1.0, intensity: 1.0, bounce: 0.0, description: 'Mechanical, stiff' }
            };
            
            // Animation control functions
            function toggleAnimation() {
                isPlaying = !isPlaying;
                const btn = document.getElementById('play-pause-btn');
                btn.textContent = isPlaying ? 'Pause' : 'Play';
                btn.style.background = isPlaying ? '#4CAF50' : '#f44336';
            }
            
            function updateAnimationSpeed(value) {
                animationSpeed = parseFloat(value);
                document.getElementById('speed-value').textContent = value + 'x';
                document.getElementById('animation-speed').textContent = value + 'x';
                console.log('Animation speed changed to:', animationSpeed);
            }
            
            function resetAnimation() {
                animationFrame = 0;
                currentFrame = 0;
                console.log('Animation reset');
            }
            
            function debugFrame() {
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const frames = bvhData[currentAnimation].frames;
                    const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                    const frameData = frames[frameIndex];
                    
                    console.log('🔍 Debug Frame Info:');
                    console.log('Current frame:', frameIndex);
                    console.log('Frame data length:', frameData.length);
                    console.log('First 12 values (root pos + rot):', frameData.slice(0, 12));
                    console.log('Animation speed:', animationSpeed);
                    console.log('Total frames:', frames.length);
                    console.log('Skeleton rotation:', skeletonGroup.rotation);
                    console.log('Skeleton position:', skeletonGroup.position);
                    
                    // Log some joint rotations
                    let channelIndex = 6; // Skip root pos and rot
                    console.log('Joint rotations:');
                    bvhJointOrder.slice(0, 3).forEach(jointName => {
                        if (channelIndex + 2 < frameData.length) {
                            const rotY = frameData[channelIndex++];
                            const rotX = frameData[channelIndex++];
                            const rotZ = frameData[channelIndex++];
                            console.log(`${jointName}: Y=${rotY.toFixed(2)}, X=${rotX.toFixed(2)}, Z=${rotZ.toFixed(2)}`);
                        }
                    });
                }
            }
            
            let orientationMode = 0;
            function fixOrientation() {
                // DISABLED: Let BVH data control all orientation
                console.log('⚠️ fixOrientation() disabled - using pure BVH data only');
            }
            
            let directionMultiplier = 1;
            function flipDirection() {
                // DISABLED: Let BVH data control all direction
                console.log('⚠️ flipDirection() disabled - using pure BVH data only');
            }
            
            // Make direction multiplier global
            window.directionMultiplier = directionMultiplier;
            
            let jointIntensity = 0.1;
            function updateJointIntensity(value) {
                jointIntensity = parseFloat(value);
                document.getElementById('intensity-value').textContent = value;
                console.log('Joint intensity changed to:', jointIntensity);
            }
            
            // Make intensity global
            window.jointIntensity = jointIntensity;
            
            // REMOVED: Root constraint functions - using pure BVH with no constraints
            
            let simpleMode = false;
            function toggleSimpleMode() {
                simpleMode = !simpleMode;
                const btn = document.getElementById('simple-mode-btn');
                btn.textContent = simpleMode ? 'Full Mode' : 'Simple Mode';
                btn.style.background = simpleMode ? '#4CAF50' : '#607D8B';
                console.log('Simple mode:', simpleMode);
            }
            
            function debugBVH() {
                console.log('🔍 BVH Debug Information:');
                console.log('Current animation:', currentAnimation);
                console.log('BVH data loaded:', Object.keys(bvhData));
                
                if (bvhData[currentAnimation]) {
                    const data = bvhData[currentAnimation];
                    console.log('Frames:', data.frames?.length || 0);
                    console.log('Frame time:', data.frameTime);
                    console.log('Channel count:', data.channelCount);
                    
                    if (data.frames && data.frames.length > 0) {
                        console.log('First frame data:', data.frames[0].slice(0, 12));
                        console.log('Sample middle frame:', data.frames[Math.floor(data.frames.length/2)].slice(0, 12));
                    }
                } else {
                    console.log('❌ No BVH data loaded for:', currentAnimation);
                }
                
                console.log('Skeleton joints created:', Object.keys(jointMeshes));
                console.log('Skeleton group position:', skeletonGroup.position);
                console.log('Skeleton group rotation:', skeletonGroup.rotation);
                console.log('Animation frame:', animationFrame);
                console.log('Animation speed:', animationSpeed);
                console.log('Is playing:', isPlaying);
            }
            
            function resetCharacterDirection() {
                console.log('🔄 Resetting character direction - PURE BVH MODE');
                window.characterHeading = 0;
                animationFrame = 0; // Reset animation to beginning
                
                // REMOVED: Do NOT manually set skeleton rotation/position
                // Let BVH data control everything when next frame is applied
                console.log('✅ Animation reset to frame 0 - BVH will control all transforms');
            }
            
            // Make functions global for onclick handlers
            window.toggleAnimation = toggleAnimation;
            window.updateAnimationSpeed = updateAnimationSpeed;
            window.resetAnimation = resetAnimation;
            window.debugFrame = debugFrame;
            window.fixOrientation = fixOrientation;
            window.flipDirection = flipDirection;
            window.updateJointIntensity = updateJointIntensity;
            window.toggleSimpleMode = toggleSimpleMode;
            window.debugBVH = debugBVH;
            window.resetCharacterDirection = resetCharacterDirection;
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                if (isPlaying) {
                    animationFrame++;
                    
                    // Use real BVH animation data if available
                    if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                        const frames = bvhData[currentAnimation].frames;
                        const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                        const frameData = frames[frameIndex];
                        
                        // Apply real BVH frame data to skeleton
                        applyBVHFrame(frameData);
                        
                        // Update bone connections to follow joint movements
                        updateBones();
                        
                        // Update frame counter
                        document.getElementById('current-frame').textContent = `${frameIndex + 1}/${frames.length} (BVH)`;
                        
                        // Log confirmation every 2 seconds
                        if (animationFrame % 120 === 0) {
                            console.log(`🎯 Pure BVH Mode: Frame ${frameIndex}/${frames.length} from ${currentAnimation}`);
                        }
                        
                    } else {
                        // DISABLED: No more procedural animation interference
                        // Only use pure BVH data - if BVH not loaded, show static pose
                        console.log('⚠️ BVH data not loaded - showing static skeleton');
                        
                        // Update frame counter for fallback (static)
                        document.getElementById('current-frame').textContent = 'No BVH data';
                    }
                    
                    // Update UI displays
                    document.getElementById('animation-speed').textContent = `${animationSpeed.toFixed(1)}x`;
                }
                
                // Don't rotate the scene - let BVH data control all rotation
                
                // DEBUG: Rotate test sphere to show animation is working
                const originSphere = scene.getObjectByName('originSphere');
                if (originSphere) {
                    originSphere.rotation.y += 0.02;
                }
                
                renderer.render(scene, camera);
            }
            
            // Setup enhanced controls
            document.getElementById('play-pause').onclick = () => {
                isPlaying = !isPlaying;
                statusDiv.textContent = isPlaying ? 'Playing' : 'Paused';
            };
            
            document.getElementById('reset').onclick = () => {
                animationFrame = 0;
                // REMOVED: skeletonGroup.rotation.y = 0; // Let BVH control rotation!
                animationSpeed = 1.0;
                currentStyle = 'neutral';
                document.getElementById('current-style').textContent = currentStyle;
                statusDiv.textContent = 'Reset to neutral (BVH-controlled)';
            };
            
            document.getElementById('cycle-animations').onclick = () => {
                // Cycle through real BVH animations
                const animFiles = Object.keys(animations);
                const currentIndex = animFiles.indexOf(currentAnimation);
                const nextFile = animFiles[(currentIndex + 1) % animFiles.length];
                
                loadAnimation(nextFile);
                statusDiv.textContent = `Loading: ${animations[nextFile].name}`;
            };
            
            document.getElementById('random-style').onclick = () => {
                // Load random BVH animation
                const animFiles = Object.keys(animations);
                const randomFile = animFiles[Math.floor(Math.random() * animFiles.length)];
                
                loadAnimation(randomFile);
                statusDiv.textContent = `Random: ${animations[randomFile].name}`;
            };
            
            document.getElementById('speed-up').onclick = () => {
                animationSpeed = Math.min(3.0, animationSpeed * 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('slow-down').onclick = () => {
                animationSpeed = Math.max(0.2, animationSpeed / 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('toggle-wireframe').onclick = () => {
                isWireframe = !isWireframe;
                // Toggle wireframe on joint materials
                Object.values(jointMeshes).forEach(joint => {
                    joint.material.wireframe = isWireframe;
                });
                statusDiv.textContent = isWireframe ? 'Wireframe ON' : 'Wireframe OFF';
            };
            
            document.getElementById('transition-demo').onclick = () => {
                statusDiv.textContent = 'Running animation transition demo...';
                document.getElementById('transition-state').textContent = 'Active';
                
                // Cycle through different BVH animations
                const animFiles = Object.keys(animations);
                let animIndex = 0;
                
                const transitionInterval = setInterval(() => {
                    const animFile = animFiles[animIndex];
                    loadAnimation(animFile);
                    const animData = animations[animFile];
                    document.getElementById('current-style').textContent = animData.name;
                    statusDiv.textContent = `Transition: ${animData.name} - ${animData.description}`;
                    animIndex = (animIndex + 1) % animFiles.length;
                    
                    if (animIndex === 0) {
                        clearInterval(transitionInterval);
                        document.getElementById('transition-state').textContent = 'Complete';
                        statusDiv.textContent = 'Animation transition demo completed';
                        loadAnimation('neutral_reference.bvh');
                        document.getElementById('current-style').textContent = 'Neutral Walking';
                    }
                }, 2000);
            };
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Start animation loop and load first animation
            animate();
            
            // Load default animation
            updateLoadingStatus('Loading default animation...');
            loadAnimation('neutral_reference.bvh');
            
            // Hide loading screen
            updateLoadingStatus('Complete!');
            setTimeout(() => {
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Modern RSMT Viewer Ready! Loading real BVH animations.';
            }, 1000);
            
        } catch (error) {
            console.error('❌ Error loading THREE.js:', error);
            updateLoadingStatus('Error: ' + error.message);
            statusDiv.textContent = 'Error loading 3D engine';
            statusDiv.className = 'error';
            
            // Hide loading screen even on error
            setTimeout(() => {
                loadingDiv.style.display = 'none';
            }, 3000);
        }
        
        // Load and parse BVH animation files
        async function loadAnimation(filename) {
            try {
                console.log('🎬 Loading animation:', filename);
                statusDiv.textContent = `Loading ${filename}...`;
                
                // Try to load actual BVH data
                try {
                    console.log('📡 Fetching BVH file:', filename);
                    const response = await fetch(filename);
                    console.log('🔍 Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const bvhText = await response.text();
                        console.log('📄 BVH text length:', bvhText.length, 'characters');
                        
                        bvhData[filename] = parseBVHData(bvhText);
                        console.log('✅ BVH data parsed for', filename, '- Frames:', bvhData[filename].frames?.length);
                        
                        currentAnimation = filename;
                        animationFrame = 0;
                        statusDiv.textContent = `Loaded ${animations[filename]?.name || filename}`;
                        
                    } else {
                        throw new Error(`BVH file not found: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn('⚠️ Could not load BVH file:', error);
                    statusDiv.textContent = `BVH load failed, using fallback animation`;
                }
                
            } catch (error) {
                console.error('❌ Failed to load animation:', error);
                statusDiv.textContent = 'Animation load failed';
            }
        }
        
        // Enhanced BVH parser
        function parseBVHData(bvhText) {
            const lines = bvhText.split('\n');
            let motionIndex = -1;
            let frameTimeIndex = -1;
            
            // Find MOTION section
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('MOTION')) {
                    motionIndex = i;
                    break;
                }
            }
            
            if (motionIndex === -1) {
                throw new Error('No MOTION section found in BVH');
            }
            
            // Find frame time
            for (let i = motionIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('Frame Time:')) {
                    frameTimeIndex = i;
                    break;
                }
            }
            
            // Parse frame data
            const frames = [];
            const frameTime = frameTimeIndex >= 0 ? 
                parseFloat(lines[frameTimeIndex].split(':')[1]) || 0.016667 : 0.016667;
            
            console.log('📊 Parsing BVH - Frame time:', frameTime);
            
            // Parse all frame data starting after Frame Time line
            const startLine = frameTimeIndex >= 0 ? frameTimeIndex + 1 : motionIndex + 3;
            
            for (let i = startLine; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && line.length > 0) {
                    const values = line.split(/\s+/).map(parseFloat);
                    if (values.length > 0 && !isNaN(values[0])) {
                        frames.push(values);
                    }
                }
            }
            
            console.log('📊 Parsed', frames.length, 'frames with', frames[0]?.length || 0, 'channels each');
            
            return {
                frames,
                frameTime,
                frameCount: frames.length,
                channelCount: frames[0]?.length || 0
            };
        }
        
        // Apply BVH frame data to skeleton
        function applyBVHFrame(frameData) {
            if (!frameData || frameData.length < 6) return;
            
            let channelIndex = 0;
            
            // Root position (first 3 channels)
            const rootX = frameData[channelIndex++] || 0;
            const rootY = frameData[channelIndex++] || 0;
            const rootZ = frameData[channelIndex++] || 0;
            
            // Root rotation (next 3 channels) - Try Y-first order (common in many BVH files)
            const rootRotY = (frameData[channelIndex++] || 0) * Math.PI / 180; // Y first (turning)
            const rootRotX = (frameData[channelIndex++] || 0) * Math.PI / 180; // X second (pitch)
            const rootRotZ = (frameData[channelIndex++] || 0) * Math.PI / 180; // Z third (roll)
            
            // Apply root transformation to skeleton - use BVH data naturally
            if (skeletonGroup) {
                // DEBUG: Log the values we're getting (more detailed)
                if (animationFrame % 60 === 0) { // Log every 60 frames
                    console.log('🎬 BVH Animation Debug (TESTING Y-AXIS TURNING):', {
                        frame: animationFrame,
                        rootPos: { x: rootX.toFixed(2), y: rootY.toFixed(2), z: rootZ.toFixed(2) },
                        rootRotDeg: { 
                            x: (rootRotX*180/Math.PI).toFixed(1) + '° (pitch/lean)', 
                            y: (rootRotY*180/Math.PI).toFixed(1) + '° (YAW/TURN - main direction)', 
                            z: (rootRotZ*180/Math.PI).toFixed(1) + '° (roll/side)' 
                        },
                        rootRotRad: { x: rootRotX.toFixed(3), y: rootRotY.toFixed(3), z: rootRotZ.toFixed(3) },
                        skeletonPos: {
                            x: skeletonGroup.position.x.toFixed(3),
                            y: skeletonGroup.position.y.toFixed(3), 
                            z: skeletonGroup.position.z.toFixed(3)
                        },
                        bvhScale: bvhScale,
                        jointCount: Object.keys(jointMeshes).length
                    });
                }
                
                // Position: scale BVH units to display size
                skeletonGroup.position.set(
                    rootX * bvhScale,      // X: as-is from BVH
                    rootY * bvhScale,      // Y: as-is from BVH (let it control height)
                    rootZ * bvhScale       // Z: as-is from BVH  
                );
                
                // Apply BVH root transformation - PURE BVH MODE (NO CONSTRAINTS)
                skeletonGroup.rotation.order = 'YXZ'; // Try Y-first order
                
                // Apply BVH rotations DIRECTLY - testing Y-axis for turning
                // Y: Turning left/right (heading/yaw) - THIS should control direction!
                // X: Leaning forward/back (pitch)  
                // Z: Rolling side to side (roll)
                skeletonGroup.rotation.set(
                    rootRotX,  // X: Forward/back lean (pitch)
                    rootRotY,  // Y: Left/right turning (yaw) - PRIMARY DIRECTION CONTROL
                    rootRotZ   // Z: Side roll
                );
            }
            
            // Apply joint rotations using correct BVH joint order
            const bvhJointOrder = [
                'Chest',          // 3 rotation channels
                'Chest2',         // 3 rotation channels  
                'Chest3',         // 3 rotation channels
                'Chest4',         // 3 rotation channels
                'Neck',           // 3 rotation channels
                'Head',           // 3 rotation channels
                'RightCollar',    // 3 rotation channels
                'RightShoulder',  // 3 rotation channels
                'RightElbow',     // 3 rotation channels
                'RightWrist',     // 3 rotation channels
                'LeftCollar',     // 3 rotation channels
                'LeftShoulder',   // 3 rotation channels
                'LeftElbow',      // 3 rotation channels
                'LeftWrist',      // 3 rotation channels
                'RightHip',       // 3 rotation channels
                'RightKnee',      // 3 rotation channels
                'RightAnkle',     // 3 rotation channels
                'RightToe',       // 3 rotation channels
                'LeftHip',        // 3 rotation channels
                'LeftKnee',       // 3 rotation channels
                'LeftAnkle',      // 3 rotation channels
                'LeftToe'         // 3 rotation channels
            ];
            
            bvhJointOrder.forEach(jointName => {
                if (jointMeshes[jointName] && channelIndex + 2 < frameData.length) {
                    // Try Y-first joint rotation order to match root
                    const rotY = (frameData[channelIndex++] || 0) * Math.PI / 180; // Y first
                    const rotX = (frameData[channelIndex++] || 0) * Math.PI / 180; // X second
                    const rotZ = (frameData[channelIndex++] || 0) * Math.PI / 180; // Z third
                    
                    // Set rotation order to match root (Y, X, Z)
                    jointMeshes[jointName].rotation.order = 'YXZ';
                    
                    // Apply rotations in Y-first order
                    jointMeshes[jointName].rotation.set(
                        rotX,   // X: pitch
                        rotY,   // Y: yaw (primary rotation)
                        rotZ    // Z: roll
                    );
                }
            });
        }
        
        // Toggle function for inference details (from legacy)
        function toggleInferenceDetails() {
            const details = document.getElementById('inference-details');
            const button = document.getElementById('toggle-inference-details');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                button.textContent = 'Hide Details';
            } else {
                details.style.display = 'none';
                button.textContent = 'Show Details';
            }
        }
        
        // Add event listener for the toggle button
        document.getElementById('toggle-inference-details').onclick = toggleInferenceDetails;
    </script>
</body>
</html>
