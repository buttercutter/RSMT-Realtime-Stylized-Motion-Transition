<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization (Simplified Demo)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .neural-status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 101;
        }
        
        .phase-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }
        
        .metrics-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .style-panel {
            position: absolute;
            top: 240px;
            left: 20px;
            z-index: 100;
        }
        
        .mocap-panel {
            position: absolute;
            top: 240px;
            right: 20px;
            z-index: 100;
        }
        
        .visualization-toggle {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        .toggle-btn {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .toggle-btn:hover {
            background: rgba(0, 212, 255, 0.4);
        }
        
        .toggle-btn.active {
            background: #00d4ff;
            color: #1a1a2e;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .control-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .control-title {
            color: #00d4ff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .animation-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .animation-btn {
            background: linear-gradient(135deg, #0066cc, #004499);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .animation-btn:hover {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            transform: translateY(-2px);
        }
        
        .animation-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        
        .transition-btn {
            background: linear-gradient(135deg, #ff6b00, #cc5500);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            width: 100%;
            margin: 5px 0;
        }
        
        .transition-btn:hover {
            background: linear-gradient(135deg, #ff8800, #ff6b00);
            transform: translateY(-2px);
        }
        
        .playback-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: #555;
            border-color: #00d4ff;
        }
        
        .control-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
            color: black;
        }
        
        #status-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            min-width: 300px;
        }
        
        .status-line {
            margin: 2px 0;
        }
        
        .highlight {
            color: #00ff88;
            font-weight: bold;
        }
        
        .transition-indicator {
            color: #ff6b00;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 18px;
            z-index: 200;
        }
        
        .error {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ff4444;
        }

        #transition-progress {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
        }

        .progress-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">Loading RSMT System...</div>
        
        <div id="ui-panel" style="display: none;">
            <div class="title">üé≠ RSMT Neural Network Motion System</div>
            
            <!-- AI Inference Monitoring Dashboard -->
            <div class="ai-monitoring-panel" id="ai-monitoring" style="background: rgba(0, 50, 100, 0.15); border: 1px solid #00d4ff; padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">üß† AI Inference Monitor</strong>
                    <button id="toggle-inference-details" onclick="toggleInferenceDetails()" style="background: none; border: 1px solid #00d4ff; color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">Show Details</button>
                </div>
                
                <div class="inference-summary" id="inference-summary">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 8px;">
                        <div class="model-status" id="deephase-status">
                            <div style="font-weight: bold; color: #4CAF50;">DeepPhase</div>
                            <div id="deephase-info">Initializing...</div>
                        </div>
                        <div class="model-status" id="stylevae-status">
                            <div style="font-weight: bold; color: #FF9800;">StyleVAE</div>
                            <div id="stylevae-info">Initializing...</div>
                        </div>
                        <div class="model-status" id="transitionnet-status">
                            <div style="font-weight: bold; color: #9C27B0;">TransitionNet</div>
                            <div id="transitionnet-info">Initializing...</div>
                        </div>
                    </div>
                    <div class="inference-metrics" id="inference-metrics" style="border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px;">
                        <div>Latest Processing: <span id="last-processing-time">N/A</span></div>
                        <div>AI Mode: <span id="ai-mode">Detecting...</span></div>
                    </div>
                </div>
                
                <div class="inference-details" id="inference-details" style="display: none; border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px; margin-top: 8px;">
                    <div class="inference-log" id="inference-log" style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                        <div style="color: #00d4ff;">AI Inference Log:</div>
                    </div>
                    <div style="margin-top: 8px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div class="tensor-info" id="tensor-info">
                            <strong>Tensor Shapes:</strong>
                            <div id="tensor-shapes">Waiting for inference...</div>
                        </div>
                        <div class="performance-info" id="performance-info">
                            <strong>Performance:</strong>
                            <div id="performance-metrics">Monitoring...</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls-grid">
                <div class="control-section">
                    <div class="control-title">üìÅ Available Animations</div>
                    <div class="animation-list" id="animation-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="control-title">üîÑ Style Interpolation (Simplified)</div>
                    <button class="transition-btn" onclick="preloadAllAnimations()">Preload All Animations</button>
                    <button class="transition-btn" onclick="performRandomTransition()">Random Style Blend</button>
                    <button class="transition-btn" onclick="performEmotionalJourney()">Emotional Journey</button>
                    <button class="transition-btn" onclick="performEnergySequence()">Energy Levels</button>
                    <button class="transition-btn" onclick="performStyleShow()">Character Showcase</button>
                </div>
                
                <div class="control-section">
                    <div class="control-title">üéÆ Playback Controls</div>
                    <div class="playback-controls">
                        <button class="control-btn" onclick="togglePlay()" id="play-btn">Play</button>
                        <button class="control-btn" onclick="resetAnimation()">Reset</button>
                        <button class="control-btn" onclick="stepFrame()">Step</button>
                        <button class="control-btn" onclick="toggleSpeed()" id="speed-btn">1.0x</button>
                        <button class="control-btn" onclick="toggleLoop()" id="loop-btn">Loop: ON</button>
                        <button class="control-btn" onclick="testAnimationSystem()" title="Debug animation system">üß™ Test</button>
                    </div>
                </div>
            </div>        </div>
        
        <div class="neural-status" id="neural-status">
            <!-- Neural network status indicator will be added here -->
        </div>
        
        <div class="phase-panel" id="phase-panel" style="display: none;">
            <canvas id="phase-canvas"></canvas>
        </div>
        
        <div class="metrics-panel" id="metrics-panel" style="display: none;">
            <!-- Quality metrics dashboard will be added here -->
        </div>
        
        <div class="style-panel" id="style-panel" style="display: none;">
            <div id="style-controller-container"></div>
        </div>
        
        <div class="mocap-panel" id="mocap-panel" style="display: none;">
            <canvas id="mocap-canvas"></canvas>
        </div>
        
        <div class="visualization-toggle">
            <button class="toggle-btn" onclick="togglePhaseView()">Phase View</button>
            <button class="toggle-btn" onclick="toggleMetricsView()">Quality Metrics</button>
            <button class="toggle-btn" onclick="toggleStyleController()">Style Controller</button>
            <button class="toggle-btn" onclick="toggleMotionCapture()">Motion Capture</button>
            <button class="toggle-btn" onclick="toggleAdvancedMode()">Advanced Mode</button>
        </div>

        <div id="status-info">
            <div class="status-line">Animation: <span class="highlight" id="current-animation">Loading...</span></div>
            <div class="status-line">Frame: <span id="current-frame">0</span> / <span id="total-frames">0</span></div>
            <div class="status-line">Time: <span id="current-time">0.00</span>s</div>
            <div class="status-line">Speed: <span id="speed-display">1.0x</span></div>
            <div class="status-line">Status: <span id="status-display">Ready</span></div>
        </div>

        <div id="transition-progress">
            <div>Transitioning: <span id="transition-status">Preparing...</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div>Progress: <span id="transition-percent">0%</span></div>
        </div>
    </div>

    <script src="three.min.js"></script>
    <script>
        // Ensure THREE.js is loaded before proceeding
        let threeJsLoaded = false;
        let threeJsCheckCount = 0;
        
        function waitForThreeJs(callback) {
            threeJsCheckCount++;
            if (typeof THREE !== 'undefined') {
                console.log('‚úÖ THREE.js loaded successfully on attempt', threeJsCheckCount);
                threeJsLoaded = true;
                callback();
            } else if (threeJsCheckCount < 50) {
                console.log('‚è≥ Waiting for THREE.js... attempt', threeJsCheckCount);
                setTimeout(() => waitForThreeJs(callback), 100);
            } else {
                console.error('‚ùå THREE.js failed to load after 50 attempts (5 seconds)');
                console.log('Trying to continue without 3D functionality...');
                callback(); // Continue anyway for UI functionality
            }
        }
        
        // Start waiting for THREE.js immediately
        waitForThreeJs(() => {
            console.log('THREE.js ready, initializing main application...');
        });
    </script>
    <script src="rsmt_client.js"></script>
    <script src="phase_visualizer.js"></script>
    <script src="motion_analyzer.js"></script>
    <script src="style_controller.js"></script>
    <script src="motion_capture.js"></script>
    <script>
        // IMMEDIATE EMERGENCY FALLBACK - runs right away
        setTimeout(() => {
            console.log('IMMEDIATE fallback - hiding loading screen');
            const loading = document.getElementById('loading');
            const ui = document.getElementById('ui-panel');
            if (loading) {
                loading.style.display = 'none';
                console.log('Loading hidden by immediate fallback');
            }
            if (ui) {
                ui.style.display = 'block';
                console.log('UI shown by immediate fallback');
            }
        }, 10);

        // Global variables
        let scene, camera, renderer;
        let bvhData = {};
        let rsmtClient = null;
        let rsmtStatus = null;
        let phaseVisualizer = null;
        let qualityDashboard = null;
        let styleController = null;
        let motionCapture = null;
        let motionAnalyzer = null;
        let performanceMonitor = null;
        let showPhaseView = false;
        let showMetricsView = false;
        let showStyleController = false;
        let showMotionCapture = false;
        let advancedMode = false;
        let currentAnimation = null;
        let currentFrame = 0;
        let isPlaying = false;
        let playbackSpeed = 1.0;
        let loopEnabled = true;
        let joints = {};
        let bones = [];
        let skeleton = null;
        let isTransitioning = false;
        let transitionData = null;

        // Enhanced global motion data for transitions
        let currentMotionData = null;

        // Simple initialization function to handle loading screen
        function initializeBasicUI() {
            console.log('Starting basic UI initialization...');
            
            // Hide loading screen and show UI panel
            const loadingElement = document.getElementById('loading');
            const uiPanel = document.getElementById('ui-panel');
            
            if (loadingElement) {
                loadingElement.style.display = 'none';
                console.log('Loading screen hidden');
            }
            
            if (uiPanel) {
                uiPanel.style.display = 'block';
                console.log('UI panel shown');
            }
            
            // Initialize AI monitoring
            if (typeof updateAIMonitoring === 'function') {
                updateAIMonitoring();
                console.log('AI monitoring initialized');
            }
            
            console.log('Basic UI initialization complete');
        }

        // IMMEDIATE Emergency initialization - force show UI right away
        setTimeout(() => {
            console.log('IMMEDIATE emergency UI activation');
            initializeBasicUI();
        }, 100);

        // Emergency initialization - force show UI after 2 seconds
        setTimeout(() => {
            const loadingElement = document.getElementById('loading');
            if (loadingElement && loadingElement.style.display !== 'none') {
                console.log('Emergency UI activation');
                initializeBasicUI();
            }
        }, 2000);

        // ULTRA Emergency - brute force UI show
        setTimeout(() => {
            console.log('ULTRA emergency - brute force UI');
            const loading = document.getElementById('loading');
            const ui = document.getElementById('ui-panel');
            if (loading) loading.style.display = 'none';
            if (ui) ui.style.display = 'block';
        }, 50);

        // Available animations with metadata - Updated with proper 100STYLE reference animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                category: 'base',
                duration: 92
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                category: 'emotional',
                duration: 58
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                category: 'emotional',
                duration: 62
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                category: 'emotional',
                duration: 113
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                category: 'character',
                duration: 77
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, stiff walking style',
                category: 'character',
                duration: 189
            },
            'old_reference.bvh': {
                name: 'Elderly Walking',
                description: 'Slow, careful walking style',
                category: 'character',
                duration: 187
            },
            'rushed_reference.bvh': {
                name: 'Rushed Walking',
                description: 'Fast, hurried walking style',
                category: 'energy',
                duration: 43
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Stylish, confident strut',
                category: 'energy',
                duration: 105
            },
            'neutral_walking.bvh': {
                name: 'Extended Neutral',
                description: 'Long neutral walking sequence',
                category: 'base',
                duration: 131
            }
        };

        // AI Inference Monitoring System
        let inferenceLog = [];
        let showingInferenceDetails = false;
        let lastInferenceTime = null;
        let inferenceCounter = 0;
        
        function toggleInferenceDetails() {
            showingInferenceDetails = !showingInferenceDetails;
            const detailsPanel = document.getElementById('inference-details');
            const toggleBtn = document.getElementById('toggle-inference-details');
            
            if (showingInferenceDetails) {
                detailsPanel.style.display = 'block';
                toggleBtn.textContent = 'Hide Details';
            } else {
                detailsPanel.style.display = 'none';
                toggleBtn.textContent = 'Show Details';
            }
        }
        
        function logInference(message, type = 'info') {
            const timestamp = new Date().toISOString().substr(11, 12);
            const logEntry = `[${timestamp}] ${message}`;
            inferenceLog.push(logEntry);
            
            // Keep only last 50 entries
            if (inferenceLog.length > 50) {
                inferenceLog.shift();
            }
            
            // Update the log display
            const logElement = document.getElementById('inference-log');
            if (logElement) {
                const colorMap = {
                    'info': '#00d4ff',
                    'success': '#4CAF50', 
                    'warning': '#FF9800',
                    'error': '#f44336',
                    'neural': '#9C27B0'
                };
                
                logElement.innerHTML = '<div style="color: #00d4ff;">AI Inference Log:</div>' + 
                    inferenceLog.map(entry => `<div style="color: ${colorMap[type] || '#ccc'}">${entry}</div>`).join('');
                logElement.scrollTop = logElement.scrollHeight;
            }
        }
        
        async function updateAIMonitoring() {
            try {
                // Try multiple possible status endpoints
                let response;
                let status = null;
                
                // Try different endpoints
                const endpoints = ['/api/status', '/status', 'http://localhost:8001/api/status', 'http://localhost:8001/status'];
                
                for (const endpoint of endpoints) {
                    try {
                        response = await fetch(endpoint);
                        if (response.ok) {
                            status = await response.json();
                            console.log('‚úÖ Found working status endpoint:', endpoint);
                            break;
                        }
                    } catch (e) {
                        // Try next endpoint
                        continue;
                    }
                }
                
                if (status) {
                    
                    // Update model status displays
                    updateModelStatus('deephase', status.models.deephase);
                    updateModelStatus('stylevae', status.models.stylevae);
                    updateModelStatus('transitionnet', status.models.transitionnet);
                    
                    // Update AI mode
                    const aiModeElement = document.getElementById('ai-mode');
                    if (aiModeElement) {
                        aiModeElement.textContent = status.performance_mode || 'Unknown';
                        aiModeElement.style.color = status.ai_status === 'Full AI' ? '#4CAF50' : 
                                                   status.ai_status === 'Partial AI' ? '#FF9800' : '#f44336';
                    }
                    
                    // Log status update
                    if (status.ai_status === 'Full AI') {
                        logInference(`‚úÖ All neural networks active (${status.models_using_ai})`, 'success');
                    } else if (status.ai_status === 'Partial AI') {
                        logInference(`‚ö° Partial AI mode (${status.models_using_ai})`, 'warning');
                    } else {
                        logInference(`üì¶ Fallback mode active`, 'info');
                    }
                } else {
                    // No working status endpoint found - create mock status
                    logInference(`‚ö†Ô∏è No status endpoint available - using fallback mode`, 'warning');
                    
                    // Update with fallback status
                    const aiModeElement = document.getElementById('ai-mode');
                    if (aiModeElement) {
                        aiModeElement.textContent = 'Standalone Mode';
                        aiModeElement.style.color = '#FF9800';
                    }
                    
                    // Update model status with fallback
                    updateModelStatus('deephase', { type: 'Standalone', parameters: 'Local' });
                    updateModelStatus('stylevae', { type: 'Standalone', parameters: 'Local' });
                    updateModelStatus('transitionnet', { type: 'Standalone', parameters: 'Local' });
                }
            } catch (error) {
                logInference(`‚ùå Status check failed: ${error.message}`, 'error');
                
                // Fallback mode
                const aiModeElement = document.getElementById('ai-mode');
                if (aiModeElement) {
                    aiModeElement.textContent = 'Error - Fallback Mode';
                    aiModeElement.style.color = '#f44336';
                }
            }
        }
        
        function updateModelStatus(modelName, modelInfo) {
            const infoElement = document.getElementById(`${modelName}-info`);
            if (!infoElement || !modelInfo) return;
            
            let statusText = '';
            let statusColor = '#666';
            
            if (modelInfo.type === 'Neural Network (PyTorch)') {
                statusText = `üß† ${modelInfo.parameters} params`;
                statusColor = '#4CAF50';
            } else if (modelInfo.type === 'Enhanced Model') {
                statusText = '‚ö° Enhanced Processing';
                statusColor = '#FF9800';
            } else if (modelInfo.type === 'Placeholder') {
                statusText = 'üì¶ Fallback Mode';
                statusColor = '#f44336';
            } else {
                statusText = '‚ùå Not Available';
                statusColor = '#666';
            }
            
            infoElement.innerHTML = statusText;
            infoElement.style.color = statusColor;
        }
        
        async function testNeuralInference() {
            if (!rsmtClient || !rsmtClient.isConnected) {
                logInference('üîå No server connection for neural testing', 'warning');
                return;
            }
            
            try {
                inferenceCounter++;
                logInference(`üß™ Starting inference test #${inferenceCounter}`, 'info');
                
                // Test phase encoding
                const testMotion = Array(10).fill().map(() => Array(63).fill(0).map(() => Math.random() * 0.1));
                const startTime = performance.now();
                
                try {
                    const phaseResult = await rsmtClient.encodePhase(testMotion);
                    const phaseTime = performance.now() - startTime;
                    logInference(`üéØ DeepPhase: ${phaseTime.toFixed(1)}ms, output: ${phaseResult.length} coords`, 'neural');
                    
                    // Update tensor info
                    updateTensorInfo('DeepPhase', `Input: [${testMotion.length}, ${testMotion[0].length}] ‚Üí Output: [${phaseResult.length}, 2]`);
                } catch (error) {
                    logInference(`‚ùå DeepPhase failed: ${error.message}`, 'error');
                }
                
                // Test style encoding
                try {
                    const styleResult = await rsmtClient.encodeStyle(testMotion);
                    const styleTime = performance.now() - startTime;
                    logInference(`üé® StyleVAE: ${styleTime.toFixed(1)}ms, dims: ${styleResult.length}`, 'neural');
                    
                    updateTensorInfo('StyleVAE', `Input: [${testMotion.length}, ${testMotion[0].length}] ‚Üí Output: [${styleResult.length}]`);
                } catch (error) {
                    logInference(`‚ùå StyleVAE failed: ${error.message}`, 'error');
                }
                
                lastInferenceTime = performance.now() - startTime;
                document.getElementById('last-processing-time').textContent = `${lastInferenceTime.toFixed(1)}ms`;
                
                // Update performance metrics
                updatePerformanceMetrics();
                
            } catch (error) {
                logInference(`üí• Inference test failed: ${error.message}`, 'error');
            }
        }
        
        // Test neural networks with actual animation data
        async function testNeuralInferenceWithAnimation(filename) {
            if (!rsmtClient || !rsmtClient.isConnected || !bvhData[filename]) {
                return;
            }
            
            try {
                logInference(`üé≠ Testing neural networks with ${filename}`, 'info');
                
                const frames = bvhData[filename].frames;
                if (frames.length === 0) return;
                
                // Take first 10 frames for testing
                const testFrames = frames.slice(0, Math.min(10, frames.length));
                const startTime = performance.now();
                
                // Test phase encoding with real animation data
                try {
                    const phaseResult = await rsmtClient.encodePhase(testFrames);
                    const phaseTime = performance.now() - startTime;
                    logInference(`üéØ Real animation ‚Üí DeepPhase: ${phaseTime.toFixed(1)}ms, ${phaseResult.length} phase coords`, 'neural');
                } catch (error) {
                    logInference(`‚ùå Real animation DeepPhase failed: ${error.message}`, 'error');
                }
                
                // Test style encoding with real animation data
                try {
                    const styleResult = await rsmtClient.encodeStyle(testFrames);
                    const styleTime = performance.now() - startTime;
                    logInference(`üé® Real animation ‚Üí StyleVAE: ${styleTime.toFixed(1)}ms, ${styleResult.length}D style vector`, 'neural');
                } catch (error) {
                    logInference(`‚ùå Real animation StyleVAE failed: ${error.message}`, 'error');
                }
                
                const totalTime = performance.now() - startTime;
                logInference(`‚úÖ Real animation processing complete in ${totalTime.toFixed(1)}ms`, 'success');
                
            } catch (error) {
                logInference(`üí• Real animation inference failed: ${error.message}`, 'error');
            }
        }
        
        function updateTensorInfo(modelName, info) {
            const tensorElement = document.getElementById('tensor-shapes');
            if (tensorElement) {
                const currentContent = tensorElement.innerHTML;
                const newLine = `<div style="color: #00d4ff;">${modelName}:</div><div style="margin-left: 10px; color: #ccc;">${info}</div>`;
                
                if (currentContent === 'Waiting for inference...') {
                    tensorElement.innerHTML = newLine;
                } else {
                    tensorElement.innerHTML = currentContent + '<br>' + newLine;
                }
            }
        }
        
        function updatePerformanceMetrics() {
            const perfElement = document.getElementById('performance-metrics');
            if (perfElement && lastInferenceTime) {
                const fps = lastInferenceTime > 0 ? (1000 / lastInferenceTime).toFixed(1) : 'N/A';
                const throughput = lastInferenceTime > 0 ? (1000 / lastInferenceTime * 10).toFixed(0) : 'N/A'; // frames per second * 10 frame batches
                
                perfElement.innerHTML = `
                    <div>Latency: ${lastInferenceTime.toFixed(1)}ms</div>
                    <div>Throughput: ~${throughput} frames/sec</div>
                    <div>Tests Run: ${inferenceCounter}</div>
                `;
            }
        }
        
        // Enhanced RSMT client wrapper to log all neural network calls
        function wrapRSMTClient(client) {
            if (!client) return;
            
            const originalEncodePhase = client.encodePhase;
            const originalEncodeStyle = client.encodeStyle;
            const originalGenerateTransition = client.generateTransition;
            
            client.encodePhase = async function(...args) {
                logInference('üéØ DeepPhase encoding started...', 'neural');
                const start = performance.now();
                try {
                    const result = await originalEncodePhase.apply(this, args);
                    const time = performance.now() - start;
                    logInference(`‚úÖ DeepPhase completed in ${time.toFixed(1)}ms`, 'success');
                    return result;
                } catch (error) {
                    logInference(`‚ùå DeepPhase error: ${error.message}`, 'error');
                    throw error;
                }
            };
            
            client.encodeStyle = async function(...args) {
                logInference('üé® StyleVAE encoding started...', 'neural');
                const start = performance.now();
                try {
                    const result = await originalEncodeStyle.apply(this, args);
                    const time = performance.now() - start;
                    logInference(`‚úÖ StyleVAE completed in ${time.toFixed(1)}ms`, 'success');
                    return result;
                } catch (error) {
                    logInference(`‚ùå StyleVAE error: ${error.message}`, 'error');
                    throw error;
                }
            };
            
            client.generateTransition = async function(...args) {
                logInference('üîÑ TransitionNet generation started...', 'neural');
                const start = performance.now();
                try {
                    const result = await originalGenerateTransition.apply(this, args);
                    const time = performance.now() - start;
                    logInference(`‚úÖ TransitionNet completed in ${time.toFixed(1)}ms`, 'success');
                    return result;
                } catch (error) {
                    logInference(`‚ùå TransitionNet error: ${error.message}`, 'error');
                    throw error;
                }
            };
        }

        // Initialize AI Monitoring when page loads
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM loaded, starting RSMT initialization...');
            
            // First, initialize basic UI to get out of loading screen
            initializeBasicUI();
            
            // Initialize basic Three.js scene - with proper loading detection
            setTimeout(() => {
                waitForThreeJs(() => {
                    try {
                        if (typeof THREE !== 'undefined') {
                            console.log('THREE.js confirmed available, initializing scene...');
                            const success = setupBasicScene();
                            if (success) {
                                console.log('‚úÖ Scene initialization completed successfully');
                            } else {
                                console.warn('‚ö†Ô∏è Scene initialization failed');
                            }
                        } else {
                            console.warn('THREE.js still not available even after loading check');
                        }
                    } catch (error) {
                        console.error('3D scene initialization failed:', error);
                    }
                });
            }, 100);
            
            // Create animation buttons
            createAnimationButtons();
            
            // Initialize RSMT client status indicator
            if (window.RSMTClient && window.RSMTStatusIndicator) {
                try {
                    rsmtClient = new RSMTClient();
                    rsmtStatus = new RSMTStatusIndicator('#neural-status', rsmtClient);
                } catch (error) {
                    console.warn('RSMT client initialization failed:', error);
                }
            }
            
            // Initialize AI monitoring
            console.log('Initializing AI Inference Monitoring...');
            logInference('üöÄ RSMT AI Monitoring System Starting...', 'info');
            
            // Start status monitoring
            updateAIMonitoring();
            setInterval(updateAIMonitoring, 10000); // Update every 10 seconds
            
            // Initialize RSMT client and wrap it for monitoring
            if (window.RSMTClient) {
                setTimeout(() => {
                    if (rsmtClient) {
                        wrapRSMTClient(rsmtClient);
                        logInference('üîó RSMT client wrapped for inference monitoring', 'success');
                        
                        // Run initial inference test
                        setTimeout(() => {
                            testNeuralInference();
                        }, 2000);
                        
                        // Schedule periodic inference tests
                        setInterval(() => {
                            if (document.getElementById('ai-monitoring').style.display !== 'none') {
                                testNeuralInference();
                            }
                        }, 30000); // Test every 30 seconds
                    }
                }, 1000);
            }
            
            // Add test button for manual inference testing
            const testBtn = document.createElement('button');
            testBtn.textContent = 'üß™ Test AI';
            testBtn.style.cssText = 'position: absolute; top: 10px; right: 150px; background: rgba(0, 212, 255, 0.2); border: 1px solid #00d4ff; color: #00d4ff; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; z-index: 102;';
            testBtn.onclick = testNeuralInference;
            document.body.appendChild(testBtn);
            
            // Add scene debug button
            const sceneBtn = document.createElement('button');
            sceneBtn.textContent = 'üé¨ Fix Scene';
            sceneBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: rgba(255, 100, 0, 0.2); border: 1px solid #ff6400; color: #ff6400; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; z-index: 103;';
            sceneBtn.onclick = function() {
                console.log('üîß Manual scene initialization attempt...');
                
                waitForThreeJs(() => {
                    console.log('THREE.js available:', typeof THREE !== 'undefined');
                    console.log('Current scene:', scene);
                    console.log('Container exists:', !!document.getElementById('container'));
                    
                    if (typeof THREE !== 'undefined') {
                        createBasicSkeleton.warningCount = 0; // Reset counter
                        const success = setupBasicScene();
                        if (success) {
                            console.log('‚úÖ Manual scene creation successful!');
                            createBasicSkeleton();
                            alert('Scene created successfully! Check the 3D view.');
                        } else {
                            console.error('‚ùå Manual scene creation failed');
                            alert('Scene creation failed. Check console for errors.');
                        }
                    } else {
                        alert('THREE.js not loaded. Check three_test_simple.html to verify THREE.js works.');
                    }
                });
            };
            document.body.appendChild(sceneBtn);
            
            logInference('‚úÖ AI Monitoring System Ready', 'success');
            
            // Load initial animation
            setTimeout(() => {
                loadAnimation('neutral_reference.bvh');
            }, 1000);
        });
        
        // Basic 3D scene setup with enhanced visibility
        function setupBasicScene() {
            try {
                // Check if THREE.js is available
                if (typeof THREE === 'undefined') {
                    console.error('THREE.js library not loaded - cannot create 3D scene');
                    return false;
                }
                
                console.log('Initializing THREE.js scene...');
                
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111122);

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(3, 3, 5);
                camera.lookAt(0, 1, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                const container = document.getElementById('container');
                if (container) {
                    // Remove any existing canvas
                    const existingCanvas = container.querySelector('canvas');
                    if (existingCanvas) {
                        container.removeChild(existingCanvas);
                    }
                    container.appendChild(renderer.domElement);
                } else {
                    console.warn('Container element not found for renderer');
                }

                // Enhanced lighting for better skeleton visibility
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Add additional lighting for better visibility
                const pointLight1 = new THREE.PointLight(0x4444ff, 0.5, 100);
                pointLight1.position.set(-5, 5, 5);
                scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0xff4444, 0.5, 100);
                pointLight2.position.set(5, 5, -5);
                scene.add(pointLight2);
                
                // Add grid and axes helpers for reference
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                scene.add(gridHelper);
                
                const axesHelper = new THREE.AxesHelper(2);
                scene.add(axesHelper);
                
                // Start render loop
                function animate() {
                    requestAnimationFrame(animate);
                    if (scene && camera && renderer) {
                        renderer.render(scene, camera);
                    }
                }
                animate();
                
                console.log('‚úÖ Basic 3D scene initialized successfully');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to setup basic scene:', error);
                // Reset scene to null if initialization failed
                scene = null;
                camera = null;
                renderer = null;
                return false;
            }
        }
        
        // Create animation buttons and populate the list
        function createAnimationButtons() {
            const animationList = document.getElementById('animation-list');
            if (!animationList) return;
            
            animationList.innerHTML = '';
            
            Object.entries(animations).forEach(([filename, data]) => {
                const button = document.createElement('button');
                button.className = 'animation-btn';
                button.textContent = data.name;
                button.title = `${data.description} (${data.duration} frames)`;
                button.onclick = () => loadAnimation(filename);
                animationList.appendChild(button);
            });
            
            console.log('Animation buttons created');
        }
        
        // Basic skeleton creation and visualization
        function createBasicSkeleton() {
            // If we've tried many times and failed, don't keep trying
            if (createBasicSkeleton.warningCount > 50) {
                return;
            }
            
            if (!scene) {
                // Try to initialize the scene first
                waitForThreeJs(() => {
                    if (typeof THREE !== 'undefined') {
                        console.log('üîß THREE.js available, attempting scene initialization...');
                        const success = setupBasicScene();
                        if (!success) {
                            console.warn('Scene initialization failed, stopping skeleton creation attempts');
                            if (!createBasicSkeleton.warningCount) createBasicSkeleton.warningCount = 0;
                            createBasicSkeleton.warningCount = 100; // Stop trying
                            return;
                        } else {
                            // Scene created successfully, now create skeleton
                            setTimeout(() => createBasicSkeleton(), 100);
                        }
                    } else {
                        console.warn('THREE.js still not available, stopping skeleton creation');
                        if (!createBasicSkeleton.warningCount) createBasicSkeleton.warningCount = 0;
                        createBasicSkeleton.warningCount = 100; // Stop trying
                    }
                });
                return;
            }
            
            console.log('Creating basic skeleton...');
            
            // Clear existing skeleton
            if (skeleton) {
                scene.remove(skeleton);
                skeleton = null;
                joints = {};
                bones = [];
            }
            
            // Create basic humanoid skeleton structure
            const skeletonGroup = new THREE.Group();
            skeletonGroup.name = 'skeleton';
            
            // Joint positions (basic T-pose) - made larger and more visible
            const jointPositions = {
                'Root': [0, 0, 0],
                'Hip': [0, 1, 0],
                'Spine': [0, 1.2, 0],
                'Spine1': [0, 1.4, 0],
                'Neck': [0, 1.6, 0],
                'Head': [0, 1.8, 0],
                'LeftShoulder': [-0.2, 1.5, 0],
                'LeftArm': [-0.5, 1.5, 0],
                'LeftForeArm': [-0.8, 1.5, 0],
                'LeftHand': [-1.1, 1.5, 0],
                'RightShoulder': [0.2, 1.5, 0],
                'RightArm': [0.5, 1.5, 0],
                'RightForeArm': [0.8, 1.5, 0],
                'RightHand': [1.1, 1.5, 0],
                'LeftUpLeg': [-0.15, 0.9, 0],
                'LeftLeg': [-0.15, 0.5, 0],
                'LeftFoot': [-0.15, 0.1, 0],
                'LeftToe': [-0.15, 0, 0.1],
                'RightUpLeg': [0.15, 0.9, 0],
                'RightLeg': [0.15, 0.5, 0],
                'RightFoot': [0.15, 0.1, 0],
                'RightToe': [0.15, 0, 0.1]
            };
            
            // Create joint spheres - larger and more colorful
            const jointGeometry = new THREE.SphereGeometry(0.04, 12, 12);
            const jointMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            
            Object.entries(jointPositions).forEach(([name, pos]) => {
                const joint = new THREE.Mesh(jointGeometry, jointMaterial);
                joint.position.set(pos[0], pos[1], pos[2]);
                joint.name = name;
                joints[name] = joint;
                skeletonGroup.add(joint);
            });
            
            // Create bones (connections between joints) - thicker and more visible
            const boneConnections = [
                ['Root', 'Hip'],
                ['Hip', 'Spine'],
                ['Spine', 'Spine1'],
                ['Spine1', 'Neck'],
                ['Neck', 'Head'],
                ['Spine1', 'LeftShoulder'],
                ['LeftShoulder', 'LeftArm'],
                ['LeftArm', 'LeftForeArm'],
                ['LeftForeArm', 'LeftHand'],
                ['Spine1', 'RightShoulder'],
                ['RightShoulder', 'RightArm'],
                ['RightArm', 'RightForeArm'],
                ['RightForeArm', 'RightHand'],
                ['Hip', 'LeftUpLeg'],
                ['LeftUpLeg', 'LeftLeg'],
                ['LeftLeg', 'LeftFoot'],
                ['LeftFoot', 'LeftToe'],
                ['Hip', 'RightUpLeg'],
                ['RightUpLeg', 'RightLeg'],
                ['RightLeg', 'RightFoot'],
                ['RightFoot', 'RightToe']
            ];
            
            boneConnections.forEach(([start, end]) => {
                if (joints[start] && joints[end]) {
                    // Create cylinder for bones instead of lines for better visibility
                    const startPos = joints[start].position;
                    const endPos = joints[end].position;
                    const distance = startPos.distanceTo(endPos);
                    
                    const boneGeometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 8);
                    const boneMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x0088ff,
                        emissive: 0x001122
                    });
                    
                    const bone = new THREE.Mesh(boneGeometry, boneMaterial);
                    
                    // Position and orient the bone
                    bone.position.copy(startPos).add(endPos).multiplyScalar(0.5);
                    bone.lookAt(endPos);
                    bone.rotateX(Math.PI / 2);
                    
                    bone.name = `${start}-${end}`;
                    bones.push(bone);
                    skeletonGroup.add(bone);
                }
            });
            
            skeleton = skeletonGroup;
            skeleton.visible = true;
            scene.add(skeleton);
            
            console.log('‚úÖ Skeleton created successfully with', Object.keys(joints).length, 'joints and', bones.length, 'bones');
            logInference(`ü¶¥ Skeleton created: ${Object.keys(joints).length} joints, ${bones.length} bones`, 'success');
            
            // Make sure camera can see the skeleton
            if (camera) {
                camera.lookAt(0, 1, 0);
            }
        }
        
        // Load and display animation with persistent skeleton
        async function loadAnimation(filename) {
            try {
                console.log('üé¨ Loading animation:', filename);
                
                // Ensure scene is ready
                if (!scene) {
                    console.log('Scene not ready, initializing...');
                    setupBasicScene();
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                // Create or ensure skeleton exists BEFORE loading animation
                if (!skeleton) {
                    console.log('Creating skeleton for animation...');
                    createBasicSkeleton();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Ensure skeleton is visible
                if (skeleton) {
                    skeleton.visible = true;
                    console.log('‚úÖ Skeleton visibility confirmed');
                }
                
                // Update current animation display
                currentAnimation = filename;
                document.getElementById('current-animation').textContent = animations[filename].name;
                
                // Mark button as active
                document.querySelectorAll('.animation-btn').forEach(btn => btn.classList.remove('active'));
                const clickedButton = event && event.target;
                if (clickedButton && clickedButton.classList.contains('animation-btn')) {
                    clickedButton.classList.add('active');
                }
                
                // Try to load actual BVH data
                try {
                    console.log('üì° Fetching BVH file:', filename);
                    const response = await fetch(filename);
                    console.log('üîç Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const bvhText = await response.text();
                        console.log('üìÑ BVH text length:', bvhText.length, 'characters');
                        
                        bvhData[filename] = parseBVHData(bvhText);
                        console.log('‚úÖ BVH data parsed for', filename, '- Frames:', bvhData[filename].frames?.length);
                        
                        document.getElementById('total-frames').textContent = bvhData[filename].frames?.length || 0;
                        logInference(`üìÅ Loaded ${filename}: ${bvhData[filename].frames?.length || 0} frames`, 'success');
                    } else {
                        throw new Error(`BVH file not found: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not load BVH file:', error);
                    // Create mock animation data
                    bvhData[filename] = createMockAnimation(animations[filename]);
                    console.log('üì¶ Created mock data with', bvhData[filename].frames.length, 'frames');
                    document.getElementById('total-frames').textContent = bvhData[filename].frames.length;
                    logInference(`üì¶ Using mock data for ${filename}`, 'warning');
                }
                
                currentFrame = 0;
                document.getElementById('current-frame').textContent = '0';
                
                // Force initial animation display update
                updateAnimationDisplay();
                
                // Auto-start playback for better user experience
                isPlaying = true;
                document.getElementById('play-btn').textContent = 'Pause';
                console.log('üé¨ Auto-starting animation playback');
                setTimeout(() => {
                    playAnimation();
                }, 100);
                
                // Test neural network with this animation
                if (rsmtClient && rsmtClient.isConnected && bvhData[filename].frames.length > 0) {
                    setTimeout(() => {
                        testNeuralInferenceWithAnimation(filename);
                    }, 500);
                }
                
                console.log('‚úÖ Animation loaded successfully, skeleton should be visible and animating');
                
            } catch (error) {
                console.error('‚ùå Failed to load animation:', error);
                logInference(`‚ùå Animation load failed: ${error.message}`, 'error');
            }
        }
        
        // Enhanced BVH parser with joint mapping
        function parseBVHData(bvhText) {
            const lines = bvhText.split('\n');
            let motionIndex = -1;
            let frameTimeIndex = -1;
            
            // Find MOTION section
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('MOTION')) {
                    motionIndex = i;
                    break;
                }
            }
            
            if (motionIndex === -1) {
                throw new Error('No MOTION section found in BVH');
            }
            
            // Find frame time
            for (let i = motionIndex + 1; i < lines.length; i++) {
                if (lines[i].trim().startsWith('Frame Time:')) {
                    frameTimeIndex = i;
                    break;
                }
            }
            
            // Parse frame data
            const frames = [];
            const frameTime = frameTimeIndex >= 0 ? 
                parseFloat(lines[frameTimeIndex].split(':')[1]) || 0.016667 : 0.016667;
            
            console.log('üìä Parsing BVH - Frame time:', frameTime);
            
            // Parse all frame data starting after Frame Time line
            const startLine = frameTimeIndex >= 0 ? frameTimeIndex + 1 : motionIndex + 3;
            
            for (let i = startLine; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && line.length > 0) {
                    const values = line.split(/\s+/).map(parseFloat);
                    if (values.length > 0 && !isNaN(values[0])) {
                        frames.push(values);
                    }
                }
            }
            
            console.log('üìä Parsed', frames.length, 'frames with', frames[0]?.length || 0, 'channels each');
            
            return {
                frames,
                frameTime,
                frameCount: frames.length,
                channelCount: frames[0]?.length || 0
            };
        }
        
        // Create enhanced mock animation data with realistic joint rotations
        function createMockAnimation(animData) {
            const frameCount = animData.duration || 60;
            const frames = [];
            
            console.log('üì¶ Creating mock animation with', frameCount, 'frames for', animData.name);
            
            for (let i = 0; i < frameCount; i++) {
                const t = i / frameCount;
                const frame = [];
                
                // Root position (simulate walking forward)
                frame.push(
                    t * 3,  // X movement (forward)
                    0,      // Y position (keep at ground level)
                    Math.sin(t * Math.PI * 4) * 0.2  // Z position (slight side-to-side)
                );
                
                // Root rotation
                frame.push(
                    0,      // X rotation
                    Math.sin(t * Math.PI * 8) * 5,  // Y rotation (turning slightly)
                    0       // Z rotation
                );
                
                // Simulate walking cycle with realistic joint rotations
                const walkCycle = t * Math.PI * 4; // 4 complete cycles
                
                // Hip rotation
                frame.push(
                    Math.sin(walkCycle) * 10,     // Hip X rotation
                    0,                            // Hip Y rotation  
                    Math.cos(walkCycle) * 3       // Hip Z rotation
                );
                
                // Spine rotation
                frame.push(
                    Math.sin(walkCycle * 0.5) * 5,  // Spine X rotation
                    Math.cos(walkCycle * 0.3) * 3,  // Spine Y rotation
                    Math.sin(walkCycle * 0.7) * 2   // Spine Z rotation
                );
                
                // Left shoulder
                frame.push(
                    Math.sin(walkCycle + Math.PI) * 8,  // Left shoulder X
                    Math.cos(walkCycle) * 5,            // Left shoulder Y
                    Math.sin(walkCycle * 2) * 3         // Left shoulder Z
                );
                
                // Left arm (swings opposite to right leg)
                frame.push(
                    Math.sin(walkCycle + Math.PI) * 25,  // Left arm X rotation
                    Math.cos(walkCycle) * 10,            // Left arm Y rotation
                    Math.sin(walkCycle + Math.PI/2) * 5  // Left arm Z rotation
                );
                
                // Left forearm
                frame.push(
                    Math.max(0, Math.sin(walkCycle + Math.PI) * 15),  // Left forearm X (always bend forward)
                    0,                                               // Left forearm Y
                    0                                                // Left forearm Z
                );
                
                // Right shoulder
                frame.push(
                    Math.sin(walkCycle) * 8,        // Right shoulder X
                    Math.cos(walkCycle + Math.PI) * 5,  // Right shoulder Y
                    Math.sin(walkCycle * 2 + Math.PI) * 3  // Right shoulder Z
                );
                
                // Right arm (swings opposite to left leg)
                frame.push(
                    Math.sin(walkCycle) * 25,           // Right arm X rotation
                    Math.cos(walkCycle + Math.PI) * 10, // Right arm Y rotation
                    Math.sin(walkCycle - Math.PI/2) * 5 // Right arm Z rotation
                );
                
                // Right forearm
                frame.push(
                    Math.max(0, Math.sin(walkCycle) * 15),  // Right forearm X (always bend forward)
                    0,                                      // Right forearm Y
                    0                                       // Right forearm Z
                );
                
                // Left upper leg
                frame.push(
                    Math.sin(walkCycle) * 30,        // Left leg X rotation (forward/back)
                    Math.cos(walkCycle) * 5,         // Left leg Y rotation (in/out)
                    Math.sin(walkCycle * 2) * 3      // Left leg Z rotation
                );
                
                // Left lower leg
                frame.push(
                    Math.max(0, -Math.cos(walkCycle) * 45), // Left lower leg X (always bend back)
                    0,                                      // Left lower leg Y
                    0                                       // Left lower leg Z
                );
                
                // Right upper leg
                frame.push(
                    Math.sin(walkCycle + Math.PI) * 30,  // Right leg X rotation (opposite to left)
                    Math.cos(walkCycle + Math.PI) * 5,   // Right leg Y rotation
                    Math.sin(walkCycle * 2 + Math.PI) * 3 // Right leg Z rotation
                );
                
                // Right lower leg
                frame.push(
                    Math.max(0, -Math.cos(walkCycle + Math.PI) * 45), // Right lower leg X
                    0,                                               // Right lower leg Y
                    0                                                // Right lower leg Z
                );
                
                // Add style variations based on animation type
                if (animData.category === 'emotional') {
                    // More expressive movements
                    for (let j = 6; j < frame.length; j += 3) {
                        frame[j] *= 1.5;     // Amplify X rotations
                        frame[j + 1] *= 1.3; // Amplify Y rotations
                        frame[j + 2] *= 1.2; // Amplify Z rotations
                    }
                } else if (animData.category === 'character' && animData.name.includes('Robot')) {
                    // More mechanical, discrete movements
                    for (let j = 6; j < frame.length; j++) {
                        frame[j] = Math.round(frame[j] / 5) * 5; // Quantize to 5-degree increments
                    }
                } else if (animData.category === 'character' && animData.name.includes('Old')) {
                    // Slower, more constrained movements
                    for (let j = 6; j < frame.length; j++) {
                        frame[j] *= 0.6; // Reduce range of motion
                    }
                } else if (animData.category === 'energy' && animData.name.includes('Rushed')) {
                    // Faster, more urgent movements
                    for (let j = 6; j < frame.length; j++) {
                        frame[j] *= 1.8; // Increase range and speed
                    }
                }
                
                frames.push(frame);
            }
            
            console.log('üì¶ Mock animation created:', frames.length, 'frames with', frames[0].length, 'channels each');
            
            return {
                frames,
                frameTime: 0.033333, // 30 FPS
                frameCount: frames.length,
                channelCount: frames[0].length
            };
        }
        
        // Enhanced animation display with proper joint animation
        function updateAnimationDisplay() {
            if (!currentAnimation || !bvhData[currentAnimation]) {
                return;
            }
            
            const data = bvhData[currentAnimation];
            const frame = data.frames[currentFrame];
            
            // Ensure skeleton exists and is visible
            if (!skeleton) {
                // Only try to create skeleton if we haven't exceeded the attempt limit
                if (!createBasicSkeleton.warningCount || createBasicSkeleton.warningCount <= 50) {
                    createBasicSkeleton();
                } else {
                    // If skeleton creation has failed too many times, skip animation
                    return;
                }
            }
            
            if (skeleton) {
                skeleton.visible = true;
                
                if (frame && frame.length >= 6) {
                    // Apply root position and reduce movement scale
                    const rootX = frame[0] * 0.002; // Much smaller movement
                    const rootY = frame[1] * 0.002;
                    const rootZ = frame[2] * 0.002;
                    skeleton.position.set(rootX, rootY, rootZ);
                    
                    // Animate joints with BVH data - use larger rotation multipliers for visibility
                    let channelIndex = 6; // Start after root position and rotation
                    
                    // Hip rotation
                    if (joints['Hip'] && channelIndex + 2 < frame.length) {
                        joints['Hip'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 2),     // Amplify rotation
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 2)
                        );
                        channelIndex += 3;
                    }
                    
                    // Spine rotation
                    if (joints['Spine'] && channelIndex + 2 < frame.length) {
                        joints['Spine'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 2)
                        );
                        channelIndex += 3;
                    }
                    
                    // Left shoulder
                    if (joints['LeftShoulder'] && channelIndex + 2 < frame.length) {
                        joints['LeftShoulder'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 3),     // Even more amplification for arms
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 3)
                        );
                        channelIndex += 3;
                    }
                    
                    // Left arm - make it very visible
                    if (joints['LeftArm'] && channelIndex + 2 < frame.length) {
                        const armRotX = (frame[channelIndex] || 0) * 4;      // 4x amplification
                        const armRotY = (frame[channelIndex + 1] || 0) * 4;
                        const armRotZ = (frame[channelIndex + 2] || 0) * 4;
                        
                        joints['LeftArm'].rotation.set(
                            THREE.MathUtils.degToRad(armRotX),
                            THREE.MathUtils.degToRad(armRotY),
                            THREE.MathUtils.degToRad(armRotZ)
                        );
                        channelIndex += 3;
                        
                        // Log every 30 frames
                        if (currentFrame % 30 === 0) {
                            console.log('ü§≤ Left arm:', armRotX.toFixed(1), armRotY.toFixed(1), armRotZ.toFixed(1));
                        }
                    }
                    
                    // Left forearm
                    if (joints['LeftForeArm'] && channelIndex + 2 < frame.length) {
                        joints['LeftForeArm'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 3)
                        );
                        channelIndex += 3;
                    }
                    
                    // Right shoulder
                    if (joints['RightShoulder'] && channelIndex + 2 < frame.length) {
                        joints['RightShoulder'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 3)
                        );
                        channelIndex += 3;
                    }
                    
                    // Right arm - make it very visible
                    if (joints['RightArm'] && channelIndex + 2 < frame.length) {
                        const armRotX = (frame[channelIndex] || 0) * 4;      // 4x amplification
                        const armRotY = (frame[channelIndex + 1] || 0) * 4;
                        const armRotZ = (frame[channelIndex + 2] || 0) * 4;
                        
                        joints['RightArm'].rotation.set(
                            THREE.MathUtils.degToRad(armRotX),
                            THREE.MathUtils.degToRad(armRotY),
                            THREE.MathUtils.degToRad(armRotZ)
                        );
                        channelIndex += 3;
                        
                        // Log every 30 frames
                        if (currentFrame % 30 === 0) {
                            console.log('ü§≤ Right arm:', armRotX.toFixed(1), armRotY.toFixed(1), armRotZ.toFixed(1));
                        }
                    }
                    
                    // Right forearm
                    if (joints['RightForeArm'] && channelIndex + 2 < frame.length) {
                        joints['RightForeArm'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 3),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 3)
                        );
                        channelIndex += 3;
                    }
                    
                    // Left upper leg - make it very visible
                    if (joints['LeftUpLeg'] && channelIndex + 2 < frame.length) {
                        const legRotX = (frame[channelIndex] || 0) * 3;      // 3x amplification for legs
                        const legRotY = (frame[channelIndex + 1] || 0) * 3;
                        const legRotZ = (frame[channelIndex + 2] || 0) * 3;
                        
                        joints['LeftUpLeg'].rotation.set(
                            THREE.MathUtils.degToRad(legRotX),
                            THREE.MathUtils.degToRad(legRotY),
                            THREE.MathUtils.degToRad(legRotZ)
                        );
                        channelIndex += 3;
                        
                        // Log every 30 frames
                        if (currentFrame % 30 === 0) {
                            console.log('ü¶µ Left leg:', legRotX.toFixed(1), legRotY.toFixed(1), legRotZ.toFixed(1));
                        }
                    }
                    
                    // Left lower leg
                    if (joints['LeftLeg'] && channelIndex + 2 < frame.length) {
                        joints['LeftLeg'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 2)
                        );
                        channelIndex += 3;
                    }
                    
                    // Right upper leg - make it very visible
                    if (joints['RightUpLeg'] && channelIndex + 2 < frame.length) {
                        const legRotX = (frame[channelIndex] || 0) * 3;      // 3x amplification for legs
                        const legRotY = (frame[channelIndex + 1] || 0) * 3;
                        const legRotZ = (frame[channelIndex + 2] || 0) * 3;
                        
                        joints['RightUpLeg'].rotation.set(
                            THREE.MathUtils.degToRad(legRotX),
                            THREE.MathUtils.degToRad(legRotY),
                            THREE.MathUtils.degToRad(legRotZ)
                        );
                        channelIndex += 3;
                        
                        // Log every 30 frames
                        if (currentFrame % 30 === 0) {
                            console.log('ü¶µ Right leg:', legRotX.toFixed(1), legRotY.toFixed(1), legRotZ.toFixed(1));
                        }
                    }
                    
                    // Right lower leg
                    if (joints['RightLeg'] && channelIndex + 2 < frame.length) {
                        joints['RightLeg'].rotation.set(
                            THREE.MathUtils.degToRad((frame[channelIndex] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 1] || 0) * 2),
                            THREE.MathUtils.degToRad((frame[channelIndex + 2] || 0) * 2)
                        );
                        channelIndex += 3;
                    }
                    
                    // Log frame info occasionally
                    if (currentFrame % 30 === 0) {
                        console.log('üé¨ Frame', currentFrame, '- Processed', channelIndex, 'channels');
                    }
                    
                } else {
                    // Fallback: Enhanced procedural animation with dramatic movement
                    const t = currentFrame * 0.2; // Faster animation
                    
                    if (joints['LeftArm']) {
                        joints['LeftArm'].rotation.x = Math.sin(t) * 1.2;      // Much larger rotations
                        joints['LeftArm'].rotation.y = Math.cos(t * 0.7) * 0.8;
                        joints['LeftArm'].rotation.z = Math.sin(t * 1.3) * 0.6;
                    }
                    if (joints['RightArm']) {
                        joints['RightArm'].rotation.x = Math.sin(t + Math.PI) * 1.2;
                        joints['RightArm'].rotation.y = Math.cos(t * 0.7 + Math.PI) * 0.8;
                        joints['RightArm'].rotation.z = Math.sin(t * 1.3 + Math.PI) * 0.6;
                    }
                    if (joints['LeftUpLeg']) {
                        joints['LeftUpLeg'].rotation.x = Math.sin(t + Math.PI/2) * 0.8;
                        joints['LeftUpLeg'].rotation.z = Math.cos(t) * 0.3;
                    }
                    if (joints['RightUpLeg']) {
                        joints['RightUpLeg'].rotation.x = Math.sin(t - Math.PI/2) * 0.8;
                        joints['RightUpLeg'].rotation.z = Math.cos(t + Math.PI) * 0.3;
                    }
                    if (joints['Hip']) {
                        joints['Hip'].rotation.y = Math.sin(t * 0.5) * 0.3;
                        joints['Hip'].rotation.x = Math.cos(t * 0.3) * 0.2;
                    }
                    if (joints['Spine']) {
                        joints['Spine'].rotation.y = Math.sin(t * 0.4) * 0.2;
                        joints['Spine'].rotation.x = Math.cos(t * 0.6) * 0.15;
                    }
                    
                    if (currentFrame % 30 === 0) {
                        console.log('üìç Using enhanced procedural animation');
                    }
                }
            }
            
            // Update UI
            document.getElementById('current-frame').textContent = currentFrame;
            document.getElementById('current-time').textContent = (currentFrame * data.frameTime).toFixed(2);
        }
        
        // Playback controls
        function togglePlay() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('play-btn');
            playBtn.textContent = isPlaying ? 'Pause' : 'Play';
            
            if (isPlaying && currentAnimation) {
                playAnimation();
            }
        }
        
        function playAnimation() {
            if (!isPlaying) return;
            if (!currentAnimation) return;
            if (!bvhData[currentAnimation]) return;
            
            const data = bvhData[currentAnimation];
            currentFrame++;
            
            // Only log every 30 frames to reduce console spam
            if (currentFrame % 30 === 0) {
                console.log(`üé¨ Playing frame ${currentFrame}/${data.frames.length} for ${currentAnimation}`);
            }
            
            if (currentFrame >= data.frames.length) {
                if (loopEnabled) {
                    currentFrame = 0;
                } else {
                    console.log('‚èπÔ∏è Animation finished, stopping playback');
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = 'Play';
                    return;
                }
            }
            
            updateAnimationDisplay();
            
            if (isPlaying) {
                const delay = (data.frameTime * 1000) / playbackSpeed;
                setTimeout(() => playAnimation(), delay);
            }
        }
        
        function resetAnimation() {
            currentFrame = 0;
            updateAnimationDisplay();
        }
        
        function stepFrame() {
            if (currentAnimation && bvhData[currentAnimation]) {
                currentFrame = (currentFrame + 1) % bvhData[currentAnimation].frames.length;
                updateAnimationDisplay();
            }
        }
        
        function toggleSpeed() {
            const speeds = [0.5, 1.0, 1.5, 2.0];
            const currentIndex = speeds.indexOf(playbackSpeed);
            playbackSpeed = speeds[(currentIndex + 1) % speeds.length];
            document.getElementById('speed-btn').textContent = `${playbackSpeed}x`;
            document.getElementById('speed-display').textContent = `${playbackSpeed}x`;
        }
        
        function toggleLoop() {
            loopEnabled = !loopEnabled;
            document.getElementById('loop-btn').textContent = `Loop: ${loopEnabled ? 'ON' : 'OFF'}`;
        }
        
        // Placeholder functions for missing functionality
        function togglePhaseView() {
            showPhaseView = !showPhaseView;
            const panel = document.getElementById('phase-panel');
            panel.style.display = showPhaseView ? 'block' : 'none';
            logInference(`Phase view ${showPhaseView ? 'enabled' : 'disabled'}`, 'info');
        }
        
        function toggleMetricsView() {
            showMetricsView = !showMetricsView;
            const panel = document.getElementById('metrics-panel');
            panel.style.display = showMetricsView ? 'block' : 'none';
            logInference(`Metrics view ${showMetricsView ? 'enabled' : 'disabled'}`, 'info');
        }
        
        function toggleStyleController() {
            showStyleController = !showStyleController;
            const panel = document.getElementById('style-panel');
            panel.style.display = showStyleController ? 'block' : 'none';
            logInference(`Style controller ${showStyleController ? 'enabled' : 'disabled'}`, 'info');
        }
        
        function toggleMotionCapture() {
            showMotionCapture = !showMotionCapture;
            const panel = document.getElementById('mocap-panel');
            panel.style.display = showMotionCapture ? 'block' : 'none';
            logInference(`Motion capture ${showMotionCapture ? 'enabled' : 'disabled'}`, 'info');
        }
        
        function toggleAdvancedMode() {
            advancedMode = !advancedMode;
            logInference(`Advanced mode ${advancedMode ? 'enabled' : 'disabled'}`, 'info');
        }
        
        // Transition functions
        function preloadAllAnimations() {
            logInference('üîÑ Preloading all animations...', 'info');
            Object.keys(animations).forEach(filename => {
                if (!bvhData[filename]) {
                    bvhData[filename] = createMockAnimation(animations[filename]);
                }
            });
            logInference('‚úÖ All animations preloaded', 'success');
        }
        
        function performRandomTransition() {
            const animList = Object.keys(animations);
            const randomAnim = animList[Math.floor(Math.random() * animList.length)];
            loadAnimation(randomAnim);
            logInference(`üé≤ Random transition to ${animations[randomAnim].name}`, 'info');
        }
        
        function performEmotionalJourney() {
            const emotionalAnims = ['neutral_reference.bvh', 'angry_reference.bvh', 'elated_reference.bvh', 'depressed_reference.bvh'];
            const nextAnim = emotionalAnims[Math.floor(Math.random() * emotionalAnims.length)];
            loadAnimation(nextAnim);
            logInference(`üòä Emotional journey: ${animations[nextAnim].name}`, 'info');
        }
        
        function performEnergySequence() {
            const energyAnims = ['neutral_walking.bvh', 'rushed_reference.bvh', 'strutting_reference.bvh'];
            const nextAnim = energyAnims[Math.floor(Math.random() * energyAnims.length)];
            loadAnimation(nextAnim);
            logInference(`‚ö° Energy sequence: ${animations[nextAnim].name}`, 'info');
        }
        
        function performStyleShow() {
            const characterAnims = ['proud_reference.bvh', 'robot_reference.bvh', 'old_reference.bvh'];
            const nextAnim = characterAnims[Math.floor(Math.random() * characterAnims.length)];
            loadAnimation(nextAnim);
            logInference(`üé≠ Style showcase: ${animations[nextAnim].name}`, 'info');
        }

        // Test animation system
        function testAnimationSystem() {
            console.log('üß™ TESTING ANIMATION SYSTEM');
            console.log('Scene:', scene);
            console.log('Skeleton:', skeleton);
            console.log('Current Animation:', currentAnimation);
            console.log('BVH Data keys:', Object.keys(bvhData));
            console.log('Is Playing:', isPlaying);
            console.log('Current Frame:', currentFrame);
            console.log('Playback Speed:', playbackSpeed);
            console.log('Loop Enabled:', loopEnabled);
            
            if (skeleton) {
                console.log('Skeleton Position:', skeleton.position);
                console.log('Skeleton Visible:', skeleton.visible);
                console.log('Skeleton Children:', skeleton.children.length);
            }
            
            if (currentAnimation && bvhData[currentAnimation]) {
                console.log('Animation Data:', {
                    name: animations[currentAnimation].name,
                    frames: bvhData[currentAnimation].frames.length,
                    frameTime: bvhData[currentAnimation].frameTime
                });
            }
            
            // Force a manual animation step
            if (currentAnimation && bvhData[currentAnimation]) {
                console.log('üîß Manually stepping animation...');
                currentFrame = (currentFrame + 1) % bvhData[currentAnimation].frames.length;
                updateAnimationDisplay();
            }
            
            alert('Check console for detailed animation system status!');
        }

        // Test function to verify joint animations are working
        function testJointAnimations() {
            console.log('üîß Testing joint animations...');
            
            if (!skeleton) {
                console.error('‚ùå No skeleton found');
                return;
            }
            
            console.log('‚úÖ Skeleton exists');
        }
    </script>
</body>
</html>