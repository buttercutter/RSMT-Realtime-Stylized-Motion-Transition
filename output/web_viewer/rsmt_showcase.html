<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization (Simplified Demo)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .neural-status {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 101;
        }
        
        .phase-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }
        
        .metrics-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .style-panel {
            position: absolute;
            top: 240px;
            left: 20px;
            z-index: 100;
        }
        
        .mocap-panel {
            position: absolute;
            top: 240px;
            right: 20px;
            z-index: 100;
        }
        
        .visualization-toggle {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        .toggle-btn {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .toggle-btn:hover {
            background: rgba(0, 212, 255, 0.4);
        }
        
        .toggle-btn.active {
            background: #00d4ff;
            color: #1a1a2e;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .control-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .control-title {
            color: #00d4ff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .animation-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .animation-btn {
            background: linear-gradient(135deg, #0066cc, #004499);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .animation-btn:hover {
            background: linear-gradient(135deg, #0088ff, #0066cc);
            transform: translateY(-2px);
        }
        
        .animation-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }
        
        .transition-btn {
            background: linear-gradient(135deg, #ff6b00, #cc5500);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            width: 100%;
            margin: 5px 0;
        }
        
        .transition-btn:hover {
            background: linear-gradient(135deg, #ff8800, #ff6b00);
            transform: translateY(-2px);
        }
        
        .playback-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .control-btn:hover {
            background: #555;
            border-color: #00d4ff;
        }
        
        .control-btn.active {
            background: #00d4ff;
            border-color: #00d4ff;
            color: black;
        }
        
        #status-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            min-width: 300px;
        }
        
        .status-line {
            margin: 2px 0;
        }
        
        .highlight {
            color: #00ff88;
            font-weight: bold;
        }
        
        .transition-indicator {
            color: #ff6b00;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d4ff;
            font-size: 18px;
            z-index: 200;
        }
        
        .error {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #ff4444;
        }

        #transition-progress {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
        }

        .progress-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="loading" id="loading">Loading RSMT System...</div>
        
        <div id="ui-panel" style="display: none;">
            <div class="title">üé≠ RSMT Motion Visualization (Simplified Demo)</div>
            <div class="disclaimer" style="background: rgba(255, 165, 0, 0.1); border: 1px solid #ffa500; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 12px; color: #ffa500;">
                <strong>‚ö†Ô∏è Important Note:</strong> This demo shows motion style variations from the 100STYLE dataset using basic interpolation. 
                The actual RSMT system uses sophisticated neural networks (DeepPhase + StyleVAE + TransitionNet) for phase-aware style transitions.
                <br><a href="RSMT_TRANSITION_EXPLANATION.md" target="_blank" style="color: #00d4ff;">Learn about real RSMT transitions ‚Üí</a>
            </div>
            
            <div class="controls-grid">
                <div class="control-section">
                    <div class="control-title">üìÅ Available Animations</div>
                    <div class="animation-list" id="animation-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <div class="control-section">
                    <div class="control-title">üîÑ Style Interpolation (Simplified)</div>
                    <button class="transition-btn" onclick="preloadAllAnimations()">Preload All Animations</button>
                    <button class="transition-btn" onclick="performRandomTransition()">Random Style Blend</button>
                    <button class="transition-btn" onclick="performEmotionalJourney()">Emotional Journey</button>
                    <button class="transition-btn" onclick="performEnergySequence()">Energy Levels</button>
                    <button class="transition-btn" onclick="performStyleShow()">Character Showcase</button>
                </div>
                
                <div class="control-section">
                    <div class="control-title">üéÆ Playback Controls</div>
                    <div class="playback-controls">
                        <button class="control-btn" onclick="togglePlay()" id="play-btn">Play</button>
                        <button class="control-btn" onclick="resetAnimation()">Reset</button>
                        <button class="control-btn" onclick="stepFrame()">Step</button>
                        <button class="control-btn" onclick="toggleSpeed()" id="speed-btn">1.0x</button>
                        <button class="control-btn" onclick="toggleLoop()" id="loop-btn">Loop: ON</button>
                    </div>
                </div>
            </div>        </div>
        
        <div class="neural-status" id="neural-status">
            <!-- Neural network status indicator will be added here -->
        </div>
        
        <div class="phase-panel" id="phase-panel" style="display: none;">
            <canvas id="phase-canvas"></canvas>
        </div>
        
        <div class="metrics-panel" id="metrics-panel" style="display: none;">
            <!-- Quality metrics dashboard will be added here -->
        </div>
        
        <div class="style-panel" id="style-panel" style="display: none;">
            <div id="style-controller-container"></div>
        </div>
        
        <div class="mocap-panel" id="mocap-panel" style="display: none;">
            <canvas id="mocap-canvas"></canvas>
        </div>
        
        <div class="visualization-toggle">
            <button class="toggle-btn" onclick="togglePhaseView()">Phase View</button>
            <button class="toggle-btn" onclick="toggleMetricsView()">Quality Metrics</button>
            <button class="toggle-btn" onclick="toggleStyleController()">Style Controller</button>
            <button class="toggle-btn" onclick="toggleMotionCapture()">Motion Capture</button>
            <button class="toggle-btn" onclick="toggleAdvancedMode()">Advanced Mode</button>
        </div>

        <div id="status-info">
            <div class="status-line">Animation: <span class="highlight" id="current-animation">Loading...</span></div>
            <div class="status-line">Frame: <span id="current-frame">0</span> / <span id="total-frames">0</span></div>
            <div class="status-line">Time: <span id="current-time">0.00</span>s</div>
            <div class="status-line">Speed: <span id="speed-display">1.0x</span></div>
            <div class="status-line">Status: <span id="status-display">Ready</span></div>
        </div>

        <div id="transition-progress">
            <div>Transitioning: <span id="transition-status">Preparing...</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div>Progress: <span id="transition-percent">0%</span></div>
        </div>
    </div>

    <script src="three.min.js"></script>
    <script src="rsmt_client.js"></script>
    <script src="phase_visualizer.js"></script>
    <script src="motion_analyzer.js"></script>
    <script src="style_controller.js"></script>
    <script src="motion_capture.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let bvhData = {};
        let rsmtClient = null;
        let rsmtStatus = null;
        let phaseVisualizer = null;
        let qualityDashboard = null;
        let styleController = null;
        let motionCapture = null;
        let motionAnalyzer = null;
        let performanceMonitor = null;
        let showPhaseView = false;
        let showMetricsView = false;
        let showStyleController = false;
        let showMotionCapture = false;
        let advancedMode = false;
        let currentAnimation = null;
        let currentFrame = 0;
        let isPlaying = false;
        let playbackSpeed = 1.0;
        let loopEnabled = true;
        let joints = {};
        let bones = [];
        let skeleton = null;
        let isTransitioning = false;
        let transitionData = null;

        // Enhanced global motion data for transitions
        let currentMotionData = null;

        // Available animations with metadata - Updated with proper 100STYLE reference animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                category: 'base',
                duration: 92
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                category: 'emotional',
                duration: 58
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                category: 'emotional',
                duration: 62
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                category: 'emotional',
                duration: 113
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                category: 'character',
                duration: 77
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, stiff walking style',
                category: 'character',
                duration: 189
            },
            'old_reference.bvh': {
                name: 'Elderly Walking',
                description: 'Slow, careful walking style',
                category: 'character',
                duration: 187
            },
            'rushed_reference.bvh': {
                name: 'Rushed Walking',
                description: 'Fast, hurried walking style',
                category: 'energy',
                duration: 43
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Stylish, confident strut',
                category: 'energy',
                duration: 105
            },
            'neutral_walking.bvh': {
                name: 'Extended Neutral',
                description: 'Long neutral walking sequence',
                category: 'base',
                duration: 131
            }
        };

        // Initialize the application
        async function init() {
            try {
                // Initialize RSMT neural network client
                rsmtClient = new RSMTClient();
                rsmtStatus = new RSMTStatusIndicator('#neural-status', rsmtClient);
                
                // Initialize phase visualizer and quality dashboard
                phaseVisualizer = new PhaseManifoldVisualizer('phase-canvas', 300, 300);
                qualityDashboard = new QualityMetricsDashboard('metrics-panel');
                
                // Initialize motion analysis tools
                motionAnalyzer = new MotionAnalyzer();
                performanceMonitor = new PerformanceMonitor();
                
                setupScene();
                createAnimationButtons();
                
                // Try to load initial animation, but don't block on it
                try {
                    await loadInitialAnimation();
                } catch (error) {
                    console.error('Initial animation load failed:', error);
                    updateStatus('Ready - Select an animation to begin');
                }
                
                hideLoading();
                startRenderLoop();
                
                // Initialize RSMT client for neural network features
                if (window.RSMTClient) {
                    rsmtClient = new RSMTClient();
                    // Give it time to connect, but don't wait
                    setTimeout(() => {
                        if (rsmtClient && rsmtClient.isConnected) {
                            updateStatus('Neural network server connected - Full RSMT features available');
                        } else {
                            updateStatus('Offline mode - Enhanced interpolation active');
                        }
                    }, 1000);
                }
                
                // Start preloading animations in background
                setTimeout(() => {
                    preloadAllAnimations().then(() => {
                        console.log('All animations preloaded successfully');
                        updateStatus('All animations ready for transitions');
                    }).catch(error => {
                        console.error('Some animations failed to preload:', error);
                    });
                }, 1000); // Give the initial animation time to load first
                
            } catch (error) {
                showError('Failed to initialize RSMT system: ' + error.message);
            }
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 3, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Grid floor
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Mouse controls
            setupMouseControls();
        }

        function setupMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;

            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;

                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 3, 0);

                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.radius += event.deltaY * 0.01;
                spherical.radius = Math.max(2, Math.min(50, spherical.radius));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 3, 0);
            });
        }

        function createAnimationButtons() {
            const animationList = document.getElementById('animation-list');
            
            Object.keys(animations).forEach(filename => {
                const anim = animations[filename];
                const button = document.createElement('button');
                button.className = 'animation-btn';
                button.textContent = anim.name;
                button.title = `${anim.description} (${anim.duration}s)`;
                button.onclick = () => loadAnimation(filename);
                animationList.appendChild(button);
            });
        }

        async function loadInitialAnimation() {
            try {
                await loadAnimation('neutral_reference.bvh');
                console.log('Initial animation loaded successfully');
            } catch (error) {
                console.error('Failed to load initial animation:', error);
                updateStatus('Demo ready - Click an animation to begin');
                // Don't throw the error, just continue with empty state
            }
        }

        async function loadAnimation(filename, forceLoad = false) {
            // Allow loading during transitions when explicitly requested
            if (isTransitioning && !forceLoad) return;

            try {
                updateStatus('Loading ' + animations[filename].name + '...');
                
                if (!bvhData[filename]) {
                    const response = await fetch(filename);
                    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    
                    const bvhText = await response.text();
                    console.log(`Fetched ${filename}, text length:`, bvhText.length);
                    
                    const parsedData = parseBVH(bvhText);
                    console.log(`Parsed ${filename}:`, parsedData);
                    
                    // Validate parsed data
                    if (!parsedData) {
                        throw new Error('Failed to parse BVH data - parseBVH returned null/undefined');
                    }
                    if (!parsedData.motion) {
                        throw new Error('Failed to parse BVH data - missing motion section');
                    }
                    if (!parsedData.motion.frames) {
                        throw new Error('Failed to parse BVH data - missing frames array');
                    }
                    if (parsedData.motion.frames.length === 0) {
                        throw new Error('BVH file contains no frame data');
                    }
                    
                    console.log(`Successfully loaded ${filename}: ${parsedData.motion.frames.length} frames`);
                    bvhData[filename] = parsedData;
                }

                // Only update UI if not in transition mode
                if (!isTransitioning) {
                    currentAnimation = filename;
                    currentFrame = 0;
                    createSkeleton(bvhData[filename]);
                    updateSkeleton(); // Add this to immediately show the skeleton
                    updateAnimationButtons();
                    updateStatus('Loaded ' + animations[filename].name);
                    document.getElementById('current-animation').textContent = animations[filename].name;
                    document.getElementById('total-frames').textContent = bvhData[filename].motion.frames.length;
                }

            } catch (error) {
                console.error('Load error for', filename, ':', error);
                showError('Failed to load ' + filename + ': ' + error.message);
                
                // Re-throw the error so transition functions can handle it
                throw error;
            }
        }

        function parseBVH(bvhText) {
            console.log('Parsing BVH text, length:', bvhText.length);
            const lines = bvhText.split('\n').map(line => line.trim()).filter(line => line);
            console.log('Total lines after filtering:', lines.length);
            
            let i = 0;
            let jointHierarchy = {};
            let motionData = { frames: [], frameTime: 0.016667 };

            // Parse HIERARCHY section
            while (i < lines.length && lines[i] !== 'MOTION') {
                if (lines[i].startsWith('ROOT') || lines[i].startsWith('JOINT')) {
                    const jointName = lines[i].split(' ')[1];
                    jointHierarchy[jointName] = { channels: [], children: [] };
                    
                    // Find CHANNELS line
                    while (i < lines.length && !lines[i].startsWith('CHANNELS')) {
                        i++;
                    }
                    
                    if (i < lines.length) {
                        const channelInfo = lines[i].split(' ');
                        const channelCount = parseInt(channelInfo[1]);
                        jointHierarchy[jointName].channels = channelInfo.slice(2, 2 + channelCount);
                    }
                }
                i++;
            }

            console.log('Found MOTION section at line:', i);
            
            // Parse MOTION section
            i++; // Skip MOTION line
            while (i < lines.length && !lines[i].startsWith('Frames:')) i++;
            
            if (i < lines.length) {
                const frameCount = parseInt(lines[i].split(' ')[1]);
                console.log('Expected frame count:', frameCount);
                i++; // Move to Frame Time line
                if (i < lines.length && lines[i].startsWith('Frame Time:')) {
                    motionData.frameTime = parseFloat(lines[i].split(' ')[2]);
                    console.log('Frame time:', motionData.frameTime);
                }
                i++; // Move to first frame data
                
                let parsedFrames = 0;
                for (let frame = 0; frame < frameCount && i < lines.length; frame++) {
                    if (lines[i] && lines[i].trim() !== '') {
                        const frameData = lines[i].split(' ').filter(val => val !== '').map(parseFloat);
                        if (frameData.length > 0 && !frameData.some(isNaN)) {
                            motionData.frames.push(frameData);
                            parsedFrames++;
                        } else {
                            console.warn('Skipping invalid frame data at line', i, ':', lines[i]);
                        }
                    }
                    i++;
                }
                console.log('Parsed frames:', parsedFrames, 'out of', frameCount);
            }

            console.log('Final motion data frames:', motionData.frames.length);
            return { joints: jointHierarchy, motion: motionData };
        }

        function createSkeleton(bvhData) {
            // Clear existing skeleton
            bones.forEach(bone => scene.remove(bone.line));
            bones = [];
            if (skeleton) scene.remove(skeleton);
            joints = {};

            // Create skeleton group
            skeleton = new THREE.Group();
            scene.add(skeleton);
            
            // Create joints based on BVH hierarchy with proper offsets - EXACT match to working viewer
            const jointDefinitions = {
                'Hips': { color: 0xff0000, size: 3, offset: [0, 0, 0], parent: null },
                'Chest': { color: 0x00ff00, size: 2, offset: [0, 13, 0], parent: 'Hips' },
                'Head': { color: 0x0000ff, size: 2, offset: [0, 35, 0], parent: 'Chest' },
                'RightShoulder': { color: 0x00ff00, size: 1.5, offset: [-16, 0, 0], parent: 'Chest' },
                'RightElbow': { color: 0x00ff00, size: 1.5, offset: [-31, 0, 0], parent: 'RightShoulder' },
                'LeftShoulder': { color: 0x00ff00, size: 1.5, offset: [16, 0, 0], parent: 'Chest' },
                'LeftElbow': { color: 0x00ff00, size: 1.5, offset: [31, 0, 0], parent: 'LeftShoulder' },
                'RightHip': { color: 0x00ff00, size: 1.5, offset: [-11, 0, 0], parent: 'Hips' },
                'RightKnee': { color: 0x00ff00, size: 1.5, offset: [0, -44, 0], parent: 'RightHip' },
                'RightAnkle': { color: 0x00ff00, size: 1.5, offset: [0, -43, 0], parent: 'RightKnee' },
                'LeftHip': { color: 0x00ff00, size: 1.5, offset: [11, 0, 0], parent: 'Hips' },
                'LeftKnee': { color: 0x00ff00, size: 1.5, offset: [0, -44, 0], parent: 'LeftHip' },
                'LeftAnkle': { color: 0x00ff00, size: 1.5, offset: [0, -43, 0], parent: 'LeftKnee' }
            };
            
            // Create joints
            Object.entries(jointDefinitions).forEach(([name, def]) => {
                const geometry = new THREE.SphereGeometry(def.size, 8, 6);
                const material = new THREE.MeshPhongMaterial({ color: def.color });
                const mesh = new THREE.Mesh(geometry, material);
                
                skeleton.add(mesh);
                
                joints[name] = {
                    mesh: mesh,
                    offset: new THREE.Vector3(def.offset[0], def.offset[1], def.offset[2]).multiplyScalar(0.1),
                    parent: def.parent,
                    worldMatrix: new THREE.Matrix4(),
                    localMatrix: new THREE.Matrix4(),
                    position: new THREE.Vector3(),
                    rotation: new THREE.Euler()
                };
            });
            
            // Create bones
            const boneConnections = [
                ['Hips', 'Chest'],
                ['Chest', 'Head'],
                ['Chest', 'RightShoulder'],
                ['RightShoulder', 'RightElbow'],
                ['Chest', 'LeftShoulder'],
                ['LeftShoulder', 'LeftElbow'],
                ['Hips', 'RightHip'],
                ['RightHip', 'RightKnee'],
                ['RightKnee', 'RightAnkle'],
                ['Hips', 'LeftHip'],
                ['LeftHip', 'LeftKnee'],
                ['LeftKnee', 'LeftAnkle']
            ];
            
            boneConnections.forEach(([start, end]) => {
                if (joints[start] && joints[end]) {
                    const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(6);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    const bone = new THREE.Line(geometry, material);
                    skeleton.add(bone);
                    bones.push({ line: bone, start: start, end: end });
                }
            });
            
            console.log('Skeleton created with', Object.keys(joints).length, 'joints and', bones.length, 'bones');
        }

        function updateSkeleton() {
            if (!currentAnimation || !bvhData[currentAnimation]) return;

            let frameData = bvhData[currentAnimation].motion.frames[currentFrame];
            if (!frameData) return;

            // Check if we have transition data to use instead
            if (currentMotionData && currentMotionData.frames && currentMotionData.frames[currentFrame]) {
                frameData = currentMotionData.frames[currentFrame];
            }
            
            // Apply real-time style modifications if style controller is active
            if (showStyleController && styleController) {
                const styleParams = styleController.getCurrentStyle();
                frameData = applyStyleToFrame(frameData, styleParams);
            }

            const scale = 0.1; // Scale factor for positions - match working viewer
            
            // Apply real BVH data to joints using EXACT channel mapping from working viewer
            const channelMapping = {
                'Hips': { channels: [0, 1, 2, 3, 4, 5], hasPosition: true },
                'Chest': { channels: [6, 7, 8], hasPosition: false },
                'Head': { channels: [21, 22, 23], hasPosition: false },
                'RightShoulder': { channels: [27, 28, 29], hasPosition: false },
                'RightElbow': { channels: [30, 31, 32], hasPosition: false },
                'LeftShoulder': { channels: [39, 40, 41], hasPosition: false },
                'LeftElbow': { channels: [42, 43, 44], hasPosition: false },
                'RightHip': { channels: [48, 49, 50], hasPosition: false },
                'RightKnee': { channels: [51, 52, 53], hasPosition: false },
                'RightAnkle': { channels: [54, 55, 56], hasPosition: false },
                'LeftHip': { channels: [60, 61, 62], hasPosition: false },
                'LeftKnee': { channels: [63, 64, 65], hasPosition: false },
                'LeftAnkle': { channels: [66, 67, 68], hasPosition: false }
            };

            // Apply frame data to joints
            Object.entries(channelMapping).forEach(([jointName, mapping]) => {
                if (!joints[jointName]) return;
                
                const joint = joints[jointName];
                
                // Apply position (only for Hips/root)
                if (mapping.hasPosition && mapping.channels.length >= 6) {
                    joint.position.set(
                        frameData[mapping.channels[0]] * scale,
                        frameData[mapping.channels[1]] * scale,
                        frameData[mapping.channels[2]] * scale
                    );
                    
                    // Apply rotation (channels 3,4,5 for hips)
                    joint.rotation.set(
                        frameData[mapping.channels[4]] * Math.PI / 180, // X
                        frameData[mapping.channels[3]] * Math.PI / 180, // Y
                        frameData[mapping.channels[5]] * Math.PI / 180, // Z
                        'YXZ'
                    );
                } else if (mapping.channels.length >= 3) {
                    // Apply rotation only (most joints)
                    joint.rotation.set(
                        frameData[mapping.channels[1]] * Math.PI / 180, // X
                        frameData[mapping.channels[0]] * Math.PI / 180, // Y
                        frameData[mapping.channels[2]] * Math.PI / 180, // Z
                        'YXZ'
                    );
                }
            });
            
            // Update world positions using proper hierarchy
            updateJointPositions();
            updateBones();

            // Update UI
            document.getElementById('current-frame').textContent = currentFrame;
            const currentTime = currentFrame * bvhData[currentAnimation].motion.frameTime;
            document.getElementById('current-time').textContent = currentTime.toFixed(2);
        }

        function updateJointPositions() {
            // Start with hips
            if (joints.Hips) {
                joints.Hips.mesh.position.copy(joints.Hips.position);
                joints.Hips.mesh.rotation.copy(joints.Hips.rotation);
                
                joints.Hips.worldMatrix.compose(
                    joints.Hips.position,
                    new THREE.Quaternion().setFromEuler(joints.Hips.rotation),
                    new THREE.Vector3(1, 1, 1)
                );
            }
            
            // Update other joints based on hierarchy
            Object.entries(joints).forEach(([name, joint]) => {
                if (name === 'Hips' || !joint.parent) return;
                
                const parent = joints[joint.parent];
                if (!parent) return;
                
                // Create local transform
                joint.localMatrix.compose(
                    joint.offset,
                    new THREE.Quaternion().setFromEuler(joint.rotation),
                    new THREE.Vector3(1, 1, 1)
                );
                
                // Combine with parent transform
                joint.worldMatrix.multiplyMatrices(parent.worldMatrix, joint.localMatrix);
                
                // Extract world position and rotation
                const worldPos = new THREE.Vector3();
                const worldRot = new THREE.Quaternion();
                const worldScale = new THREE.Vector3();
                joint.worldMatrix.decompose(worldPos, worldRot, worldScale);
                
                joint.mesh.position.copy(worldPos);
                joint.mesh.quaternion.copy(worldRot);
            });
        }

        function updateBones() {
            bones.forEach(bone => {
                const startPos = joints[bone.start].mesh.position;
                const endPos = joints[bone.end].mesh.position;
                
                const positions = bone.line.geometry.attributes.position.array;
                positions[0] = startPos.x;
                positions[1] = startPos.y;
                positions[2] = startPos.z;
                positions[3] = endPos.x;
                positions[4] = endPos.y;
                positions[5] = endPos.z;
                
                bone.line.geometry.attributes.position.needsUpdate = true;
            });
        }

        function updateAnimationButtons() {
            document.querySelectorAll('.animation-btn').forEach((btn, index) => {
                const filename = Object.keys(animations)[index];
                btn.classList.toggle('active', filename === currentAnimation);
            });
        }

        // Preload all animations function
        async function preloadAllAnimations() {
            const animationFiles = Object.keys(animations);
            console.log('Preloading animations:', animationFiles);
            
            for (const filename of animationFiles) {
                try {
                    console.log(`Preloading ${filename}...`);
                    await loadAnimation(filename, true);
                    console.log(`Successfully preloaded ${filename}`);
                } catch (error) {
                    console.error(`Failed to preload ${filename}:`, error);
                }
            }
            console.log('Preloading complete. Loaded animations:', Object.keys(bvhData));
        }

        // Transition functions
        async function performRandomTransition() {
            try {
                const availableAnimations = Object.keys(animations).filter(f => f !== currentAnimation);
                const randomAnimation = availableAnimations[Math.floor(Math.random() * availableAnimations.length)];
                await performTransition(currentAnimation, randomAnimation);
            } catch (error) {
                console.error('Random transition failed:', error);
                showError('Random transition failed: ' + error.message);
            }
        }

        async function performEmotionalJourney() {
            const emotionalSequence = [
                'neutral_reference.bvh',
                'elated_reference.bvh', 
                'angry_reference.bvh',
                'depressed_reference.bvh'
            ];
            
            try {
                for (let i = 0; i < emotionalSequence.length; i++) {
                    if (i > 0) {
                        await performTransition(emotionalSequence[i-1], emotionalSequence[i]);
                    } else {
                        await loadAnimation(emotionalSequence[i], true);
                    }
                    await playAnimationFor(5000); // Play each for 5 seconds
                }
            } catch (error) {
                console.error('Emotional journey failed:', error);
                showError('Emotional journey failed: ' + error.message);
            }
        }

        async function performEnergySequence() {
            const energySequence = [
                'depressed_reference.bvh', // Low energy
                'neutral_reference.bvh',   // Normal energy  
                'rushed_reference.bvh',    // High energy
                'strutting_reference.bvh'  // Very high energy
            ];
            
            try {
                for (let i = 0; i < energySequence.length; i++) {
                    if (i > 0) {
                        await performTransition(energySequence[i-1], energySequence[i]);
                    } else {
                        await loadAnimation(energySequence[i], true);
                    }
                    await playAnimationFor(5000);
                }
            } catch (error) {
                console.error('Energy sequence failed:', error);
                showError('Energy sequence failed: ' + error.message);
            }
        }

        async function performStyleShow() {
            const styleSequence = [
                'neutral_reference.bvh',
                'proud_reference.bvh',
                'robot_reference.bvh', 
                'old_reference.bvh'
            ];
            
            try {
                for (let i = 0; i < styleSequence.length; i++) {
                    if (i > 0) {
                        await performTransition(styleSequence[i-1], styleSequence[i]);
                    } else {
                        await loadAnimation(styleSequence[i], true);
                    }
                    await playAnimationFor(6000); // Play each for 6 seconds
                }
            } catch (error) {
                console.error('Style show failed:', error);
                showError('Style show failed: ' + error.message);
            }
        }

        async function playAnimationFor(duration) {
            return new Promise(resolve => {
                isPlaying = true;
                setTimeout(() => {
                    resolve();
                }, duration);
            });
        }

        async function performTransition(fromAnim, toAnim) {
            if (isTransitioning) return;
            
            isTransitioning = true;
            showTransitionProgress();
            
            try {
                updateTransitionStatus('Loading animations...');
                
                // Load both animations and ensure they're properly parsed
                if (!bvhData[fromAnim]) {
                    await loadAnimation(fromAnim, true);
                }
                if (!bvhData[toAnim]) {
                    await loadAnimation(toAnim, true);
                }
                
                // Validate BVH data structure
                if (!bvhData[fromAnim]) {
                    throw new Error(`BVH data not loaded for ${fromAnim}`);
                }
                if (!bvhData[fromAnim].motion) {
                    throw new Error(`No motion section found in ${fromAnim}`);
                }
                if (!bvhData[fromAnim].motion.frames) {
                    throw new Error(`No frames array found in ${fromAnim}`);
                }
                if (!bvhData[toAnim]) {
                    throw new Error(`BVH data not loaded for ${toAnim}`);
                }
                if (!bvhData[toAnim].motion) {
                    throw new Error(`No motion section found in ${toAnim}`);
                }
                if (!bvhData[toAnim].motion.frames) {
                    throw new Error(`No frames array found in ${toAnim}`);
                }
                
                if (bvhData[fromAnim].motion.frames.length === 0 || bvhData[toAnim].motion.frames.length === 0) {
                    throw new Error('One or both animations have no frame data');
                }
                
                // Create transition frames
                updateTransitionStatus('Creating style interpolation...');
                const transitionResult = await createTransitionFrames(bvhData[fromAnim], bvhData[toAnim]);
                
                // Update quality metrics if available
                if (transitionResult.qualityMetrics && showMetricsView) {
                    qualityDashboard.updateMetrics(transitionResult.qualityMetrics);
                }
                
                // Update phase visualization if available
                if (transitionResult.phaseTrajectory && showPhaseView) {
                    phaseVisualizer.clearHistory();
                    transitionResult.phaseTrajectory.forEach((phase, index) => {
                        setTimeout(() => {
                            phaseVisualizer.updatePhase(phase[0], phase[1]);
                        }, index * 16.67); // 60 FPS timing
                    });
                }
                
                // Play transition
                updateTransitionStatus('Playing style blend...');
                await playTransitionFrames(transitionResult.frames || transitionResult);
                
                // Switch to target animation
                currentAnimation = toAnim;
                currentFrame = 0;
                updateAnimationButtons();
                updateStatus('Transition completed to ' + animations[toAnim].name);
                
            } catch (error) {
                console.error('Transition error:', error);
                showError('Transition failed: ' + error.message);
                // Fall back to direct loading if transition fails
                try {
                    updateTransitionStatus('Falling back to direct load...');
                    await loadAnimation(toAnim);
                } catch (fallbackError) {
                    showError('Fallback load also failed: ' + fallbackError.message);
                }
            } finally {
                isTransitioning = false;
                hideTransitionProgress();
            }
        }

        async function createTransitionFrames(fromBvh, toBvh) {
            // ‚ö†Ô∏è IMPORTANT: This attempts to use neural networks if available, otherwise falls back to basic interpolation!
            // Real RSMT uses sophisticated neural networks:
            // - DeepPhase: Encodes temporal motion patterns on a 2D manifold
            // - StyleVAE: Encodes motion style in latent space
            // - TransitionNet: Generates natural transitions using learned representations
            
            // Validate input data
            if (!fromBvh || !fromBvh.motion || !fromBvh.motion.frames || fromBvh.motion.frames.length === 0) {
                throw new Error('Invalid source animation data');
            }
            if (!toBvh || !toBvh.motion || !toBvh.motion.frames || toBvh.motion.frames.length === 0) {
                throw new Error('Invalid target animation data');
            }
            
            const transitionLength = 60; // 1 second at 60fps
            
            // Use the first 60 frames of each animation for neural network input
            const sourceFrames = fromBvh.motion.frames.slice(0, Math.min(60, fromBvh.motion.frames.length));
            const targetFrames = toBvh.motion.frames.slice(0, Math.min(60, toBvh.motion.frames.length));
            
            // Try to use neural network transition generation
            if (rsmtClient) {
                try {
                    updateTransitionStatus('Running neural transition generation...');
                    
                    const transitionResult = await rsmtClient.generateTransition(sourceFrames, targetFrames, {
                        transitionLength: transitionLength,
                        phaseSchedule: 1.0,
                        styleBlendCurve: 'smooth'
                    });
                    
                    if (transitionResult.usingNeuralNetwork) {
                        updateTransitionStatus(`Neural transition complete (${transitionResult.processingTime.toFixed(3)}s)`);
                        console.log('Quality metrics:', transitionResult.qualityMetrics);
                        
                        // Display quality metrics briefly
                        setTimeout(() => {
                            const qualityText = `Quality: ${(transitionResult.qualityMetrics.overall_quality * 100).toFixed(1)}%`;
                            updateTransitionStatus(qualityText);
                        }, 500);
                        
                        return transitionResult.frames;
                    } else {
                        updateTransitionStatus('Using enhanced interpolation...');
                        return transitionResult.frames;
                    }
                } catch (error) {
                    console.warn('Neural transition failed, using fallback:', error);
                    updateTransitionStatus('Neural transition failed, using fallback...');
                }
            }
            
            // Fallback: Basic interpolation with improved blending
            updateTransitionStatus('Using basic interpolation fallback...');
            return createFallbackTransition(fromBvh, toBvh, transitionLength);
        }
        
        function createFallbackTransition(fromBvh, toBvh, transitionLength) {
            const transitionFrames = [];
            
            // Use the first frame of each animation as reference points
            const fromFrame = fromBvh.motion.frames[0];
            const toFrame = toBvh.motion.frames[0];
            
            if (!fromFrame || !toFrame) {
                throw new Error('Missing frame data in animations');
            }
            
            // Ensure both frames have data
            const minChannels = Math.min(fromFrame.length, toFrame.length);
            if (minChannels === 0) {
                throw new Error('No channel data found in frames');
            }
            
            console.log(`Creating transition: ${fromFrame.length} ‚Üí ${toFrame.length} channels (using ${minChannels})`);
            
            for (let i = 0; i <= transitionLength; i++) {
                const t = i / transitionLength;
                const frame = [];
                
                for (let j = 0; j < minChannels; j++) {
                    // Spherical interpolation for smoother transitions
                    const fromValue = fromFrame[j] || 0;
                    const toValue = toFrame[j] || 0;
                    const value = fromValue + (toValue - fromValue) * smoothstep(t);
                    frame.push(value);
                }
                
                transitionFrames.push(frame);
            }
            
            console.log(`Generated ${transitionFrames.length} transition frames`);
            
            // Generate mock quality metrics for fallback
            const qualityMetrics = {
                smoothness: 0.75 + Math.random() * 0.2,
                style_preservation: 0.7 + Math.random() * 0.25,
                foot_skating: Math.random() * 0.15,
                overall_quality: 0.72 + Math.random() * 0.18
            };
            
            // Generate mock phase trajectory
            const phaseTrajectory = [];
            for (let i = 0; i < transitionLength; i++) {
                const t = i / transitionLength;
                const sx = Math.cos(t * Math.PI);
                const sy = Math.sin(t * Math.PI * 1.3);
                phaseTrajectory.push([sx, sy]);
            }
            
            return {
                frames: transitionFrames,
                qualityMetrics: qualityMetrics,
                phaseTrajectory: phaseTrajectory,
                usingNeuralNetwork: false
            };
        }

        function smoothstep(t) {
            return t * t * (3 - 2 * t);
        }

        async function playTransitionFrames(frames) {
            // Create temporary motion data
            const tempMotionData = {
                frames: frames,
                frameTime: 0.016667
            };
            
            // Store original data
            const originalAnimation = currentAnimation;
            const originalBvhData = bvhData[currentAnimation];
            
            // Temporarily replace motion data
            bvhData[currentAnimation] = {
                joints: originalBvhData.joints,
                motion: tempMotionData
            };
            
            // Play transition
            currentFrame = 0;
            const frameCount = frames.length;
            
            return new Promise(resolve => {
                const playTransition = () => {
                    if (currentFrame >= frameCount) {
                        // Restore original data
                        bvhData[currentAnimation] = originalBvhData;
                        resolve();
                        return;
                    }
                    
                    updateSkeleton();
                    updateTransitionProgress(currentFrame / frameCount);
                    currentFrame++;
                    
                    setTimeout(playTransition, tempMotionData.frameTime * 1000);
                };
                
                playTransition();
            });
        }

        // UI Controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? 'Pause' : 'Play';
            updateStatus(isPlaying ? 'Playing' : 'Paused');
        }

        function resetAnimation() {
            currentFrame = 0;
            updateSkeleton();
        }

        function stepFrame() {
            if (!currentAnimation) return;
            currentFrame = (currentFrame + 1) % bvhData[currentAnimation].motion.frames.length;
            updateSkeleton();
        }

        function toggleSpeed() {
            playbackSpeed = playbackSpeed === 1.0 ? 0.25 : playbackSpeed === 0.25 ? 2.0 : 1.0;
            document.getElementById('speed-btn').textContent = playbackSpeed + 'x';
            document.getElementById('speed-display').textContent = playbackSpeed + 'x';
        }

        function toggleLoop() {
            loopEnabled = !loopEnabled;
            document.getElementById('loop-btn').textContent = 'Loop: ' + (loopEnabled ? 'ON' : 'OFF');
        }

        // Global functions for motion capture integration
        window.applyMotionCapture = function(motionData) {
            if (!motionData || !Array.isArray(motionData)) return;
            
            // Replace current animation with captured motion
            currentMotionData = {
                frames: motionData,
                frameTime: 0.016667, // 60 FPS
                frameRate: 60
            };
            
            // Update frame count
            if (motionData.length > 0) {
                document.getElementById('total-frames').textContent = motionData.length;
                updateStatus('Applied motion capture with ' + motionData.length + ' frames');
            }
        };
        
        window.applyMotionCaptureFrame = function(frameData) {
            if (!frameData || !Array.isArray(frameData)) return;
            
            // Override current frame with motion capture data
            if (!currentMotionData) {
                currentMotionData = {
                    frames: [],
                    frameTime: 0.016667,
                    frameRate: 60
                };
            }
            
            // Replace current frame
            currentMotionData.frames[currentFrame] = frameData;
            
            // Update skeleton immediately
            updateSkeleton();
        };
        
        window.updateMotionFromCapture = function(frameData) {
            // Real-time motion capture update
            if (frameData && showMotionCapture) {
                window.applyMotionCaptureFrame(frameData);
            }
        };

        // Global functions for RSMT client integration
        window.updateServerStatus = function(status) {
            updateStatus(status);
            console.log('Server status update:', status);
        };
        
        // Animation loop
        function animate() {
            if (isPlaying && currentAnimation && !isTransitioning) {
                const frameCount = bvhData[currentAnimation].motion.frames.length;
                currentFrame++;
                
                if (currentFrame >= frameCount) {
                    if (loopEnabled) {
                        currentFrame = 0;
                    } else {
                        isPlaying = false;
                        document.getElementById('play-btn').textContent = 'Play';
                    }
                }
                
                updateSkeleton();
            }
        }

        function render() {
            requestAnimationFrame(render);
            animate();
            renderer.render(scene, camera);
        }

        function startRenderLoop() {
            // Animation timer based on playback speed
            setInterval(() => {
                if (isPlaying && currentAnimation && !isTransitioning) {
                    animate();
                }
            }, (bvhData[currentAnimation]?.motion.frameTime || 0.016667) * 1000 / playbackSpeed);
            
            render();
        }

        // Utility functions
        function updateStatus(status) {
            document.getElementById('status-display').textContent = status;
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.getElementById('ui-panel').appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui-panel').style.display = 'block';
        }

        function showTransitionProgress() {
            document.getElementById('transition-progress').style.display = 'block';
        }

        function hideTransitionProgress() {
            document.getElementById('transition-progress').style.display = 'none';
        }

        function updateTransitionStatus(status) {
            document.getElementById('transition-status').textContent = status;
        }

        function updateTransitionProgress(progress) {
            const percent = Math.round(progress * 100);
            document.getElementById('progress-fill').style.width = percent + '%';
            document.getElementById('transition-percent').textContent = percent + '%';
        }

        // Enhanced transition function with style application
        function performStyleTransition(fromMotion, toMotion, progress) {
            if (!fromMotion || !toMotion) return null;
            
            let transitionData = null;
            
            // Try neural network first
            if (isServerConnected && window.rsmt_client) {
                try {
                    const styleParams = styleController ? styleController.getCurrentStyle() : {};
                    transitionData = window.rsmt_client.generateTransition(
                        fromMotion, toMotion, progress, styleParams
                    );
                } catch (error) {
                    console.warn('Neural transition failed, using enhanced interpolation:', error);
                }
            }
            
            // Fallback to enhanced interpolation
            if (!transitionData) {
                transitionData = enhancedInterpolation(fromMotion, toMotion, progress);
                
                // Apply style modifications if controller is available
                if (styleController) {
                    const styleParams = styleController.getCurrentStyle();
                    transitionData = applyStyleToMotion(transitionData, styleParams);
                }
            }
            
            // Update quality metrics
            if (showMetricsView && phaseVisualizer) {
                const quality = phaseVisualizer.analyzeTransitionQuality(
                    fromMotion, transitionData, toMotion
                );
                phaseVisualizer.updateQualityMetrics(quality);
            }
            
            return transitionData;
        }
        
        function applyStyleToMotion(motionData, styleParams) {
            if (!motionData || !styleParams) return motionData;
            
            // Create a copy to avoid modifying original
            const styledMotion = JSON.parse(JSON.stringify(motionData));
            
            // Apply emotional characteristics
            if (styleParams.emotional) {
                styledMotion = applyEmotionalStyle(styledMotion, styleParams.emotional);
            }
            
            // Apply physical characteristics
            if (styleParams.physical) {
                styledMotion = applyPhysicalStyle(styledMotion, styleParams.physical);
            }
            
            // Apply energy characteristics
            if (styleParams.energy) {
                styledMotion = applyEnergyStyle(styledMotion, styleParams.energy);
            }
            
            return styledMotion;
        }
        
        function applyEmotionalStyle(motion, emotionalParams) {
            // Modify pose based on emotional parameters
            const intensity = emotionalParams.intensity || 1.0;
            const valence = emotionalParams.valence || 0.0; // -1 (negative) to 1 (positive)
            
            // Adjust spine curvature for emotional expression
            if (motion.frames) {
                motion.frames.forEach(frame => {
                    if (frame.spine) {
                        // Positive emotions - straighter spine
                        // Negative emotions - more curved spine
                        frame.spine.x *= (1 + valence * 0.2 * intensity);
                    }
                    
                    // Adjust arm positions for emotional state
                    if (frame.leftArm && frame.rightArm) {
                        const armFactor = intensity * (valence > 0 ? 1.1 : 0.9);
                        frame.leftArm.y *= armFactor;
                        frame.rightArm.y *= armFactor;
                    }
                });
            }
            
            return motion;
        }
        
        function applyPhysicalStyle(motion, physicalParams) {
            // Apply physical characteristics like age, build, etc.
            const age = physicalParams.age || 0.5; // 0 (young) to 1 (old)
            const build = physicalParams.build || 0.5; // 0 (light) to 1 (heavy)
            
            if (motion.frames) {
                motion.frames.forEach(frame => {
                    // Older characters - less range of motion
                    const ageFactor = 1 - (age * 0.3);
                    
                    // Heavier build - slower, more deliberate movements
                    const buildFactor = 1 - (build * 0.2);
                    
                    Object.keys(frame).forEach(joint => {
                        if (frame[joint] && typeof frame[joint] === 'object') {
                            ['x', 'y', 'z'].forEach(axis => {
                                if (frame[joint][axis] !== undefined) {
                                    frame[joint][axis] *= ageFactor * buildFactor;
                                }
                            });
                        }
                    });
                });
            }
            
            return motion;
        }
        
        function applyEnergyStyle(motion, energyParams) {
            // Apply energy-based modifications
            const energy = energyParams.level || 0.5; // 0 (low) to 1 (high)
            const tempo = energyParams.tempo || 1.0;
            
            if (motion.frames) {
                motion.frames.forEach((frame, index) => {
                    // High energy - more exaggerated movements
                    const energyFactor = 1 + (energy - 0.5) * 0.4;
                    
                    Object.keys(frame).forEach(joint => {
                        if (frame[joint] && typeof frame[joint] === 'object') {
                            ['x', 'y', 'z'].forEach(axis => {
                                if (frame[joint][axis] !== undefined) {
                                    frame[joint][axis] *= energyFactor;
                                }
                            });
                        }
                    });
                });
                
                // Adjust frame rate based on tempo
                if (tempo !== 1.0) {
                    motion.frameRate = (motion.frameRate || 30) * tempo;
                }
            }
            
            return motion;
        }

        function applyStyleToFrame(frameData, styleParams) {
            if (!frameData || !styleParams) return frameData;
            
            // Create a copy to avoid modifying original
            const styledFrame = [...frameData];
            
            // Apply emotional characteristics to frame
            if (styleParams.emotional) {
                styledFrame = applyEmotionalToFrame(styledFrame, styleParams.emotional);
            }
            
            // Apply physical characteristics
            if (styleParams.physical) {
                styledFrame = applyPhysicalToFrame(styledFrame, styleParams.physical);
            }
            
            // Apply energy characteristics
            if (styleParams.energy) {
                styledFrame = applyEnergyToFrame(styledFrame, styleParams.energy);
            }
            
            return styledFrame;
        }
        
        function applyEmotionalToFrame(frame, emotionalParams) {
            const intensity = emotionalParams.intensity || 1.0;
            const valence = emotionalParams.valence || 0.0; // -1 (negative) to 1 (positive)
            
            // Modify spine rotation (channels 6,7,8 for Chest)
            if (frame.length > 8) {
                const spineFactor = 1 + (valence * 0.2 * intensity);
                frame[6] *= spineFactor; // Chest X rotation
                frame[7] *= spineFactor; // Chest Y rotation
            }
            
            // Modify shoulder positions (channels 27-29 for RightShoulder, 39-41 for LeftShoulder)
            if (frame.length > 41) {
                const shoulderFactor = intensity * (valence > 0 ? 1.1 : 0.9);
                frame[28] *= shoulderFactor; // Right shoulder Y
                frame[40] *= shoulderFactor; // Left shoulder Y
            }
            
            return frame;
        }
        
        function applyPhysicalToFrame(frame, physicalParams) {
            const age = physicalParams.age || 0.5; // 0 (young) to 1 (old)
            const build = physicalParams.build || 0.5; // 0 (light) to 1 (heavy)
            
            // Older characters - less range of motion
            const ageFactor = 1 - (age * 0.3);
            
            // Heavier build - more deliberate movements
            const buildFactor = 1 - (build * 0.1);
            
            const combinedFactor = ageFactor * buildFactor;
            
            // Apply to all rotation channels (skip position channels 0,1,2)
            for (let i = 3; i < frame.length; i++) {
                frame[i] *= combinedFactor;
            }
            
            return frame;
        }
        
        function applyEnergyToFrame(frame, energyParams) {
            const energy = energyParams.level || 0.5; // 0 (low) to 1 (high)
            
            // High energy - more exaggerated movements
            const energyFactor = 1 + (energy - 0.5) * 0.4;
            
            // Apply to rotation channels, skip position
            for (let i = 3; i < frame.length; i++) {
                frame[i] *= energyFactor;
            }
            
            return frame;
        }
        
        // Immediate initialization when page loads
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM loaded, starting RSMT initialization...');
            
            // Force show interface after 3 seconds if initialization fails
            setTimeout(() => {
                if (document.getElementById('loading').style.display !== 'none') {
                    console.log('Emergency timeout - forcing interface display');
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('ui-panel').style.display = 'block';
                    updateStatus('Ready - Select an animation to begin');
                }
            }, 3000);
            
            try {
                // Initialize basic components
                console.log('Initializing Three.js scene...');
                setupScene();
                createAnimationButtons();
                
                // Initialize advanced components (optional)
                try {
                    if (window.PhaseVisualizer) {
                        phaseVisualizer = new PhaseVisualizer('phase-panel');
                    }
                    if (window.QualityMetricsDashboard) {
                        qualityDashboard = new QualityMetricsDashboard('metrics-panel');
                    }
                    if (window.StyleInterpolationController) {
                        styleController = new StyleInterpolationController('style-panel');
                    }
                    if (window.MotionCaptureInterface) {
                        motionCapture = new MotionCaptureInterface('mocap-canvas');
                    }
                } catch (error) {
                    console.warn('Some advanced components failed to load:', error);
                }
                
                // Try to load initial animation
                try {
                    await loadInitialAnimation();
                } catch (error) {
                    console.warn('Initial animation failed to load:', error);
                }
                
                // Always show the interface
                hideLoading();
                startRenderLoop();
                
                // Initialize RSMT client
                if (window.RSMTClient) {
                    rsmtClient = new RSMTClient();
                }
                
                updateStatus('RSMT Viewer Ready - Select an animation');
                console.log('RSMT initialization complete!');
                
            } catch (error) {
                console.error('RSMT initialization failed:', error);
                // Force show interface even on error
                document.getElementById('loading').style.display = 'none';
                document.getElementById('ui-panel').style.display = 'block';
                updateStatus('Basic viewer ready - Some features may be unavailable');
            }
        });
    </script>
</body>
</html>
