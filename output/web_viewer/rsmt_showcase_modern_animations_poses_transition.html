<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSMT Motion Visualization - Modern (r177)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00d4ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .title {
            color: #00d4ff;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #0084ff);
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 212, 255, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            color: #4caf50;
            font-weight: bold;
        }
        
        .error {
            color: #f44336;
            font-weight: bold;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #scene-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            font-size: 14px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .migration-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #4caf50, #45a049);
            color: white;
            padding: 10px;
            text-align: center;
            z-index: 1001;
            font-weight: bold;
        }

        .transition-section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 100, 200, 0.1);
            border: 1px solid #00d4ff;
            border-radius: 10px;
        }
        
        .transition-iframe {
            width: 100%;
            height: 700px;
            border: none;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .integration-controls {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .message-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="migration-banner">
        ‚úÖ Modern THREE.js with ES Modules - No Deprecation Warnings!
    </div>
    
    <div class="migration-banner" style="background: rgba(0, 150, 0, 0.8); border-color: #00ff00;">
        üéØ Pure BVH Mode - All constraints removed, using 100% unmodified motion capture data
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Modern RSMT Viewer...</div>
        <div id="loading-status">Initializing THREE.js...</div>
    </div>
    
    <div id="container">
        <div id="ui-panel">
            <div class="title">üé≠ RSMT Neural Network Motion System (Modern)</div>
            
            <!-- AI Inference Monitoring Dashboard -->
            <div class="ai-monitoring-panel" id="ai-monitoring" style="background: rgba(0, 50, 100, 0.15); border: 1px solid #00d4ff; padding: 12px; border-radius: 8px; margin: 10px 0; font-size: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="color: #00d4ff;">üß† AI Inference Monitor</strong>
                    <button id="toggle-inference-details" style="background: none; border: 1px solid #00d4ff; color: #00d4ff; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">Show Details</button>
                </div>
                
                <div class="inference-summary" id="inference-summary">
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <div class="model-status" id="deephase-status">
                            <div style="color: #00ff88; font-weight: bold;">DeepPhase</div>
                            <div style="font-size: 10px;">Ready</div>
                        </div>
                        <div class="model-status" id="stylevae-status">
                            <div style="color: #ff8800; font-weight: bold;">StyleVAE</div>
                            <div style="font-size: 10px;">Standby</div>
                        </div>
                        <div class="model-status" id="transitionnet-status">
                            <div style="color: #ff4488; font-weight: bold;">TransitionNet</div>
                            <div style="font-size: 10px;">Idle</div>
                        </div>
                    </div>
                    
                    <!-- Model Warmup Controls -->
                    <div style="display: flex; gap: 5px; margin-bottom: 8px; flex-wrap: wrap;">
                        <button id="warmup-all-btn" onclick="warmupAllModels()" style="background: #4CAF50; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üî• Warm Up All</button>
                        <button id="warmup-stylevae-btn" onclick="warmupStyleVAE()" style="background: #ff8800; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üé® Wake StyleVAE</button>
                        <button id="warmup-transitionnet-btn" onclick="warmupTransitionNet()" style="background: #ff4488; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üîÑ Wake TransitionNet</button>
                        <!-- <button id="test-server-btn" onclick="testServerConnection()" style="background: #2196F3; border: none; color: white; padding: 4px 8px; border-radius: 3px; font-size: 10px; cursor: pointer;">üåê Test Server</button> -->
                    </div>
                    
                    <div class="inference-metrics" id="inference-metrics" style="border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
                            <div>Inference Rate: <span id="inference-rate">60 FPS</span></div>
                            <div>Latency: <span id="inference-latency">16ms</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="inference-details" id="inference-details" style="display: none; border-top: 1px solid rgba(0, 212, 255, 0.3); padding-top: 8px; margin-top: 8px;">
                    <div class="inference-log" id="inference-log" style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 10px;">
                        <div style="color: #00d4ff;">AI Inference Log:</div>
                        <div style="color: #00ff88;">‚úì DeepPhase model loaded</div>
                        <div style="color: #ffaa00;">‚ö† StyleVAE on standby</div>
                        <div style="color: #ff6666;">‚ö† TransitionNet not connected</div>
                        <div style="color: #888;">Tensor Shapes:</div>
                            <div id="tensor-shapes">Waiting for inference...</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="play-pause">Play/Pause</button>
                <button id="reset">Reset</button>
                <button id="cycle-animations">Cycle Animations</button>
                <button id="random-style">Random Style</button>
                <button id="transition-demo">Demo Transitions</button>
                <button id="speed-up">Speed Up</button>
                <button id="slow-down">Slow Down</button>
                <button id="toggle-wireframe">Toggle Wireframe</button>
            </div>



            <!-- Add this in the controls section -->
            <div class="controls" style="margin-top: 15px; padding: 15px; background: rgba(0, 100, 200, 0.1); border-radius: 8px; border: 1px solid #00d4ff;">
                <h3 style="margin: 0 0 10px 0; color: #00d4ff;">üß† AI Motion Control</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <button onclick="checkONNXRuntimeSetup()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">üîç Check ONNX Setup</button>
                    <button onclick="toggleAIMode()" id="ai-mode-btn" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">üé¨ BVH Mode: ON</button>
                    <button onclick="randomizeStyle()" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">üé® Random Style</button>
                    <button onclick="smoothStyle()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ú® Smooth Style</button>
                    <button onclick="aggressiveStyle()" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">üî• Aggressive Style</button>
                    <button onclick="analyzeCurrentMotion()" style="padding: 8px 16px; background: #607D8B; color: white; border: none; border-radius: 4px; cursor: pointer;">üîç Analyze Motion</button>
                </div>
            </div>



            <div id="status" class="status">Ready</div>

            <!-- Add toggle button for BVH Transition System -->
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="toggleTransitionSystem()" id="transition-toggle-btn" style="background: #9C27B0; border: none; color: white; padding: 12px 20px; border-radius: 4px; cursor: pointer; font-weight: bold;">üîÑ Show BVH Transition System</button>
            </div>
        </div>
       

        <!-- Hidden transition system that can be toggled -->
        <div id="transition-system" class="transition-section" style="display: none; position: fixed; top: 100px; left: 50px; right: 50px; bottom: 50px; background: rgba(0, 0, 0, 0.95); border: 2px solid #00d4ff; border-radius: 10px; z-index: 1000; overflow-y: auto; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #00d4ff; margin: 0;">üîÑ BVH Transition System</h2>
                <button onclick="toggleTransitionSystem()" style="background: #f44336; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">‚úï Close</button>
            </div>
            
            <div class="integration-controls" style="margin: 15px 0; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 5px;">
                <h3 style="margin: 0 0 10px 0;">üéÆ Integration Controls</h3>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="sendCurrentPoseToTransition()" style="background: #4CAF50; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">üì§ Send Current Pose</button>
                    <button onclick="sendBVHDataToTransition()" style="background: #2196F3; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">üìä Send BVH Data</button>
                    <button onclick="syncAnimations()" style="background: #FF9800; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">üîÑ Sync Animations</button>
                    <button onclick="requestTransitionAnalysis()" style="background: #9C27B0; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer;">üéØ Analyze Transitions</button>
                </div>
                
                <div id="transitionMessages" style="background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 4px; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 12px; margin-top: 10px;">
                    <div style="color: #00d4ff;">üì° Transition System Communication Log:</div>
                </div>
            </div>
            
            <iframe 
                id="transitionFrame"
                style="width: 100%; height: 60%; border: none; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);"
                src="bvh-transition-system.html"
                title="BVH Transition System">
            </iframe>
        </div>


        <div class="info-panel">
            <div id="scene-info">
                <div class="metric">
                    <span>THREE.js Version:</span>
                    <span id="three-version">Loading...</span>
                </div>
                <div class="metric">
                    <span>Animation Frame:</span>
                    <span id="current-frame">0</span>
                </div>
                <div class="metric">
                    <span>Current Style:</span>
                    <span id="current-style">Neutral</span>
                </div>
                <div class="metric">
                    <span>Animation Speed:</span>
                    <span id="animation-speed">0.3x</span>
                </div>
                <div class="metric">
                    <span>Transition State:</span>
                    <span id="transition-state">Idle</span>
                </div>
                <div class="metric">
                    <span>Skeleton Joints:</span>
                    <span id="joint-count">15</span>
                </div>
                <div class="metric">
                    <span>Bone Connections:</span>
                    <span id="bone-count">13</span>
                </div>
            </div>
            
            <!-- Animation Controls -->
            <div class="controls" style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                <h3 style="margin: 0 0 10px 0; color: #fff;">Animation Controls</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <button onclick="toggleAnimation()" id="play-pause-btn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Pause</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Speed:</label>
                        <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="0.3" style="width: 100px;" onchange="updateAnimationSpeed(this.value)">
                        <span id="speed-value" style="color: #fff; min-width: 40px;">0.3x</span>
                    </div>
                    <button onclick="resetAnimation()" style="padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                    <button onclick="debugFrame()" style="padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug Frame</button>
                    <button onclick="fixOrientation()" style="padding: 8px 16px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Fix Orientation (DISABLED)</button>
                    <button onclick="flipDirection()" style="padding: 8px 16px; background: #E91E63; color: white; border: none; border-radius: 4px; cursor: pointer;" title="DISABLED - Using pure BVH data">Flip Direction (DISABLED)</button>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label style="color: #fff;">Joint Intensity:</label>
                        <input type="range" id="intensity-slider" min="0.01" max="1.0" step="0.01" value="0.1" style="width: 100px;" onchange="updateJointIntensity(this.value)">
                        <span id="intensity-value" style="color: #fff; min-width: 40px;">0.1</span>
                    </div>
                    <button onclick="toggleSimpleMode()" id="simple-mode-btn" style="padding: 8px 16px; background: #607D8B; color: white; border: none; border-radius: 4px; cursor: pointer;">Simple Mode</button>
                    <button onclick="debugBVH()" style="padding: 8px 16px; background: #795548; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug BVH</button>
                    <button onclick="resetCharacterDirection()" style="padding: 8px 16px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Reset Direction</button>
                    <!-- REMOVED: Root Constraint slider - using pure BVH data with no constraints -->
                </div>
            </div>
        </div>
    </div>


    <!-- ONNX Runtime Web with WebGPU support -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.webgpu.min.js"></script>

    <script type="module">
        console.log('üöÄ Starting Modern RSMT Viewer with ES Modules...');
        
        const loadingDiv = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const statusDiv = document.getElementById('status');
        const container = document.getElementById('container');
        
        // Update loading status
        function updateLoadingStatus(message) {
            loadingStatus.textContent = message;
            console.log('üìù', message);
        }



        // === GLOBAL FUNCTION PLACEHOLDERS (Available immediately) ===

        // Define placeholder functions first so onclick handlers work
        window.toggleAIMode = function() { console.log('AI Mode not ready yet'); };
        window.randomizeStyle = function() { console.log('Style functions not ready yet'); };
        window.smoothStyle = function() { console.log('Style functions not ready yet'); };
        window.aggressiveStyle = function() { console.log('Style functions not ready yet'); };
        window.analyzeCurrentMotion = function() { console.log('Analysis not ready yet'); };
        window.toggleAnimation = function() { console.log('Animation controls not ready yet'); };
        window.updateAnimationSpeed = function() { console.log('Animation controls not ready yet'); };
        window.resetAnimation = function() { console.log('Animation controls not ready yet'); };
        window.debugFrame = function() { console.log('Debug functions not ready yet'); };
        window.fixOrientation = function() { console.log('Orientation functions not ready yet'); };
        window.flipDirection = function() { console.log('Direction functions not ready yet'); };
        window.updateJointIntensity = function() { console.log('Joint functions not ready yet'); };
        window.toggleSimpleMode = function() { console.log('Mode functions not ready yet'); };
        window.debugBVH = function() { console.log('BVH functions not ready yet'); };
        window.resetCharacterDirection = function() { console.log('Direction functions not ready yet'); };
        window.testServerConnection = function() { console.log('Server functions not ready yet'); };
        window.warmupStyleVAE = function() { console.log('Warmup functions not ready yet'); };
        window.warmupTransitionNet = function() { console.log('Warmup functions not ready yet'); };
        window.warmupAllModels = function() { console.log('Warmup functions not ready yet'); };
        window.checkONNXRuntimeSetup = function() { console.log('checkONNXRuntimeSetup not ready yet'); };


        // Global variables for animation and BVH data
        let isPlaying = true;
        let currentStyle = 'neutral';
        let animationSpeed = 0.3; // Much slower default speed
        let isWireframe = false;
        let bvhData = {};
        let currentAnimation = 'neutral_reference.bvh';
        let animationFrame = 0;
        let bvhScale = 0.01; // Scale factor for BVH units
        window.aiMode = false;
       
        // This flag will be controlled by the iframe.
        let isParentAnimationPaused = false;

        // Global THREE.js objects (will be initialized in try block)
        let scene, camera, renderer, skeletonGroup;
        let jointMeshes = {};
        let boneCylinders = [];
        let jointWorldPositions = {};
        
        // Available BVH animations
        const animations = {
            'neutral_reference.bvh': {
                name: 'Neutral Walking',
                description: 'Natural forward walking motion',
                duration: 120
            },
            'angry_reference.bvh': {
                name: 'Angry Walking',
                description: 'Aggressive, forceful walking style',
                duration: 100
            },
            'elated_reference.bvh': {
                name: 'Elated Walking',
                description: 'Happy, bouncy walking style',
                duration: 110
            },
            'depressed_reference.bvh': {
                name: 'Depressed Walking',
                description: 'Slow, heavy walking style',
                duration: 140
            },
            'proud_reference.bvh': {
                name: 'Proud Walking',
                description: 'Confident, upright walking style',
                duration: 115
            },
            'robot_reference.bvh': {
                name: 'Robot Walking',
                description: 'Mechanical, precise walking style',
                duration: 90
            },
            'strutting_reference.bvh': {
                name: 'Strutting Walk',
                description: 'Confident, stylish walking motion',
                duration: 105
            }
        };
    



        // === SERVER-BASED BVH PROCESSOR ===
        class ServerBVHProcessor {
            constructor(serverUrl = 'http://localhost:8000') {
                this.serverUrl = serverUrl;
                this.isInitialized = false;
            }

            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    logInferenceEvent('üåê Connecting to RSMT server...', 'info');
                    
                    // Test server connection
                    const response = await fetch(`${this.serverUrl}/`);
                    if (!response.ok) {
                        throw new Error(`Server not responding: ${response.status}`);
                    }
                    
                    const serverInfo = await response.text();
                    logInferenceEvent(`‚úÖ Connected to: ${serverInfo}`, 'success');
                    
                    this.isInitialized = true;
                    
                } catch (error) {
                    logInferenceEvent(`‚ùå Server connection failed: ${error.message}`, 'error');
                    logInferenceEvent('üí° Run: python bvh_server.py', 'info');
                    throw error;
                }
            }

            async processBVHFile(bvhContent, style = 'neutral', content = 'walking') {
                if (!this.isInitialized) {
                    await this.initialize();
                }

                try {
                    logInferenceEvent('üîÑ Processing BVH with actual process_dataset.py...', 'info');

                    const response = await fetch(`${this.serverUrl}/process_and_window`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            bvh_content: bvhContent,
                            style: style,
                            content: content,
                            window_size: 65,
                            overlap: 25
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    logInferenceEvent(`‚úÖ Server processing complete: ${result.processed_data.frame_count} frames`, 'success');
                    
                    return result;

                } catch (error) {
                    logInferenceEvent(`‚ùå Server BVH processing failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            async createWindowedData(processedData, windowSize = 65, overlap = 25) {
                try {
                    const response = await fetch(`${this.serverUrl}/create_windows`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            processed_data: processedData,
                            window_size: windowSize,
                            overlap: overlap
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`Server error: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    if (result.error) {
                        throw new Error(result.error);
                    }

                    return result;

                } catch (error) {
                    logInferenceEvent(`‚ùå Windowing failed: ${error.message}`, 'error');
                    throw error;
                }
            }
        }


        // === EXPOSE FUNCTIONS TO GLOBAL SCOPE FOR IFRAME ACCESS ===
        console.log('üåê Exposing visualization functions to global scope...');

        // Make key functions globally accessible for iframe
        window.applyBVHFrame = applyBVHFrame;
        window.skeletonGroup = skeletonGroup;
        window.jointMeshes = jointMeshes;
        window.bvhScale = bvhScale;
        window.scene = scene;
        window.camera = camera;
        window.renderer = renderer;

        // Also expose THREE.js objects for advanced iframe usage
        window.bvhData = bvhData;
        window.currentAnimation = currentAnimation;
        window.animationFrame = animationFrame;
        window.isPlaying = isPlaying;

        // Add a helper function for iframe visualization updates
        window.updateVisualizationFromPose = function(poseData) {
            if (poseData && poseData.length >= 6) {
                applyBVHFrame(poseData);
                console.log('üì° Applied pose from iframe:', poseData.slice(0, 6));
            }
        };

        // Add iframe-specific helpers
        window.getSkeletonState = function() {
            return {
                position: skeletonGroup ? skeletonGroup.position.toArray() : [0, 0, 0],
                rotation: skeletonGroup ? skeletonGroup.rotation.toArray() : [0, 0, 0],
                jointCount: Object.keys(jointMeshes).length,
                currentFrame: animationFrame,
                currentAnimation: currentAnimation,
                isPlaying: isPlaying
            };
        };

        console.log('‚úÖ Visualization functions exposed to global scope');
        console.log('üîç Available for iframe:', {
            applyBVHFrame: typeof window.applyBVHFrame,
            skeletonGroup: !!window.skeletonGroup,
            jointMeshes: !!window.jointMeshes,
            scene: !!window.scene
        });


        // === INITIALIZE SERVER CONNECTION ===
        let serverProcessor = new ServerBVHProcessor();
        let useServerProcessing = false;

        // Add function to process BVH through server
        async function processBVHWithServer(bvhContent) {
            if (!useServerProcessing) {
                logInferenceEvent('‚ö†Ô∏è Server processing not available', 'warning');
                return null;
            }
            
            try {
                logInferenceEvent('üîÑ Processing BVH through server...', 'info');
                const result = await serverProcessor.processBVHFile(bvhContent);
                logInferenceEvent('‚úÖ Server processing complete', 'success');
                return result;
            } catch (error) {
                logInferenceEvent(`‚ùå Server processing failed: ${error.message}`, 'error');
                return null;
            }
        }

        // BVH Transition Integration
        class TransitionIntegration {
            constructor() {
                this.transitionFrame = document.getElementById('transitionFrame');
                this.childIsReady = false; // Part 1 of the check
                this.parentIsReady = false; // Part 2 of the check
                this.isReady = !this.transitionFrame; // is ready if the frame was found.
                this.lastPoseSent = 0;
                
                this.logTransitionMessage('‚úÖ Start of TransitionIntegration class');
                this.setupMessageListener();
            }
            
            setupMessageListener() {
                // This is the only event listener we need.
                window.addEventListener('message', (event) => {
                    // Check if the message is from the source we expect.
                    // We don't need to check `this.transitionFrame` here yet.
                    if (event.data && event.data.source === 'bvh-transition-system') {
                        this.handleTransitionMessage(event);
                    }
                });
            }
           
            // NEW: Robust handshake method
            initiateHandshake() {
                this.logTransitionMessage('ü§ù Initiating handshake with transition system...');
                
                // Clear any previous interval to be safe
                if (this.handshakeInterval) {
                    clearInterval(this.handshakeInterval);
                }

                this.handshakeInterval = setInterval(() => {
                    if (this.isReady) {
                        // If we're ready, we don't need to ping anymore
                        clearInterval(this.handshakeInterval);
                        return;
                    }
                    // Ping the child, asking it to respond if it's ready
                    console.log('pinging child');
                    this.transitionFrame.contentWindow.postMessage({ type: 'ping' }, '*');
                }, 500); // Ping every 500ms

                // Set a timeout to stop trying after a while
                setTimeout(() => {
                    if (!this.isReady) {
                        clearInterval(this.handshakeInterval);
                        this.logTransitionMessage('‚ùå Handshake timed out. Child system did not respond.');
                    }
                }, 10000); // Stop after 10 seconds
            }

            // NEW: This function centralizes the final readiness check
            checkIfFullyReady() {
                if (this.parentIsReady && this.childIsReady && !this.isReady) {
                    this.isReady = true;
                    this.logTransitionMessage('ü§ù Handshake complete! Both parent and child are ready.');
                    this.logTransitionMessage('‚ÑπÔ∏è Use "Send BVH Data" to sync animations.');
                }
            }

            notifyChildSceneReady() {
                if (this.isReady) {
                    this.logTransitionMessage('üöÄ Notifying child that parent 3D scene is ready.');
                    this.sendToTransition('parent_scene_ready', { success: true });
                } else {
                    this.logTransitionMessage('‚ö†Ô∏è Tried to notify child, but handshake is not complete.');
                }
            }

            handleTransitionMessage(event) {
                const { type, data } = event.data;
              
                //this.logTransitionMessage(`Received message of type: ${event.data.type}`); // For debugging
                //this.logTransitionMessage('‚ÑπÔ∏è  Start of handleTransitionMessage().');
                
                // The *first* 'system_ready' message we get is the handshake.
                if ((type === 'system_ready' || type === 'ready') && (!this.isReady)) {
                    this.isReady = true;
                    clearInterval(this.handshakeInterval); // Stop pinging
                    this.logTransitionMessage('‚úÖ Handshake complete! Transition system is live.');
                    this.logTransitionMessage('‚ÑπÔ∏è Use "Send BVH Data" to sync animations.');
                    //return;
                }

                if (!this.isReady) {
                    this.logTransitionMessage('‚ö†Ô∏è Warning: Received message before handshake was complete. Ignoring.');
                    return; // Ignore all messages until handshake is complete
                }

                switch (type) {
                    case 'ready':
                        this.isReady = true;
                        this.transitionFrame = document.getElementById('transitionFrame');
                        this.logTransitionMessage('‚úÖ Transition system ready');
                        break;
                        
                    case 'system_ready':
                        this.logTransitionMessage(`üéØ System initialized: ${data.animations.length} animations, ${data.totalPoses} poses`);
                        break;
                       
                    case 'transition_start': // Child is starting a transition
                        this.logTransitionMessage(`üöÄ Child started transition. Pausing parent animation.`);
                        isParentAnimationPaused = true;
                        break;

                    case 'transition_complete':
                        this.logTransitionMessage(`‚úÖ Parent animation resumed on ${data.to}.`);
                        isParentAnimationPaused = false;
                        // Sync parent's state to match the child's new animation
                        currentAnimation = data.to;
                        animationFrame = 0; // Or use a specific frame if provided
                        break;
                        
                    case 'transition_found':
                        this.logTransitionMessage(`üéØ Match found: frame ${data.targetFrame}, distance ${data.distance.toFixed(4)}`);
                        break;
                        
                    case 'pose_update':
                        // Update our system with transition system pose data
                        this.handlePoseUpdate(data);
                        break;
                        
                    case 'transition_analysis':
                        this.handleTransitionAnalysis(data);
                        break;
                        
                    case 'test_message':
                        this.logTransitionMessage(`üì® Test: ${data.message}`);
                        break;
                        
                    case 'request_pose_data':
                        this.sendCurrentPoseData();
                        break;
                        
                    case 'export_data':
                        this.handleExportedData(data);
                        break;
                        
                    default:
                        this.logTransitionMessage(`üì® ${type}: ${JSON.stringify(data).substring(0, 50)}...`);
                }
            }
            
            logTransitionMessage(message) {
                const log = document.getElementById('transitionMessages');
                const timestamp = new Date().toLocaleTimeString();
                log.innerHTML += `<div style="color: #00ff88;">[${timestamp}] ${message}</div>`;
                log.scrollTop = log.scrollHeight;
                
                // Keep only last 20 messages
                const lines = log.querySelectorAll('div');
                if (lines.length > 21) { // Keep header + 20 messages
                    lines[1].remove(); // Remove oldest (keep header)
                }
            }
            
            sendToTransition(messageType, data) {
                if (!this.isReady) {
                    this.logTransitionMessage('‚ùå Transition system not ready');
                    return;
                }
                
                if (!this.transitionFrame) {
                    this.logTransitionMessage('‚ùå Transition frame not valid');
                    return;
                }
                
                this.transitionFrame.contentWindow.postMessage({
                    type: messageType,
                    data: data
                }, '*');
            }
            
            sendCurrentPoseData() {
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const frames = bvhData[currentAnimation].frames;
                    const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                    const frameData = frames[frameIndex];
                    
                    this.sendToTransition('pose_data', {
                        animation: currentAnimation,
                        frame: frameIndex,
                        pose: Array.from(frameData.slice(0, 69)), // First 69 values (23 joints * 3)
                        timestamp: Date.now()
                    });
                    
                    this.logTransitionMessage(`üì§ Sent pose data: frame ${frameIndex}`);
                }
            }
            
            sendBVHData() {
                const allBVHData = {};
                for (const [animId, data] of Object.entries(bvhData)) {
                    if (data.frames && data.frames.length > 0) { // Only send valid animations
                        // Take the first 69 channels (23 joints * 3 Euler angles)
                        const poses = data.frames.map(frame => Array.from(frame.slice(3, 72)));

                        // The child expects `poses`, `fps`, and `duration`.
                        allBVHData[animId] = {
                            poses: poses,
                            fps: 1 / (data.frameTime || 0.0333),
                            duration: poses.length * (data.frameTime || 0.0333)
                        };
                    }
                }
                
                // The message type is 'bvh_data' and the data is the `allBVHData` object itself.
                this.sendToTransition('bvh_data', allBVHData);
                this.logTransitionMessage(`üìä Sent BVH data for ${Object.keys(allBVHData).length} animations.`);
            }

            syncAnimations() {
                this.sendToTransition('animation_command', {
                    command: 'switch',
                    animation: currentAnimation,
                    frame: Math.floor(animationFrame),
                    speed: animationSpeed
                });
                
                this.logTransitionMessage(`üîÑ Synced to: ${currentAnimation} frame ${Math.floor(animationFrame)}`);
            }
            
            requestTransitionAnalysis() {
                this.sendToTransition('get_transitions', {
                    request: 'analyze_current_pose',
                    includeAllMatches: true
                });
                
                this.logTransitionMessage('üéØ Requested transition analysis');
            }
            
            handlePoseUpdate(data) {
                // Use pose data from transition system to influence main animation
                if (data.isTransitioning) {
                    this.logTransitionMessage(`üîÑ Transition progress: ${Math.round(data.transitionProgress * 100)}%`);
                }
        
                // When a pose_update is received from the child,
                // call the parent's master rendering function.
                if (isParentAnimationPaused && data && data.pose) {
                    applyBVHFrame(data.pose);
                }

                // Then, delegate the visual update to the dedicated function
                //applyTransitionPose(data.pose); 
            }
            
            handleTransitionAnalysis(data) {
                this.logTransitionMessage(`üéØ Analysis: ${data.transitions.length} potential transitions`);
                data.transitions.forEach(transition => {
                    if (transition.matches.length > 0) {
                        const best = transition.matches[0];
                        this.logTransitionMessage(`  ‚Üí ${transition.animation}: ${best.distance.toFixed(4)} (frame ${best.frameIndex})`);
                    }
                });
            }
            
            handleExportedData(data) {
                this.logTransitionMessage('üíæ Received exported data from transition system');
                
                // Could integrate this data with main system
                if (data.motionPath && data.motionPath.length > 0) {
                    this.logTransitionMessage(`üìà Motion path: ${data.motionPath.length} points`);
                }
            }
            
            // Auto-sync current pose every few seconds
            startAutoSync() {
                setInterval(() => {
                    if (this.isReady && isPlaying) {
                        const currentTime = Date.now();
                        if (currentTime - this.lastPoseSent > 2000) { // Every 2 seconds
                            this.sendCurrentPoseData();
                            this.lastPoseSent = currentTime;
                        }
                    }
                }, 1000);
            }
        }

        // Initialize transition integration
        const transitionIntegration = new TransitionIntegration();


        // === REAL AI MODEL MANAGER ===
        class RSMTModelManager {
            constructor() {
                this.models = {};
                this.isInitialized = false;
                this.webgpuSupported = false;
                this.currentStyle = new Float32Array(256); // Style vector
                this.currentPhase = 0.0;
                this.motionHistory = [];
                this.maxHistoryFrames = 60; // 1 second at 60fps
            }

            async initialize() {
                try {
                    logInferenceEvent('üîß Initializing WebGPU + ONNX Runtime...', 'info');


                    // Check cross-origin isolation first
                    if (!self.crossOriginIsolated) {
                        logInferenceEvent('‚ö†Ô∏è Cross-origin isolation not enabled - using single-threaded mode', 'warning');
                        // Force single-threaded mode
                        ort.env.wasm.numThreads = 1;
                    } else {
                        logInferenceEvent('‚úÖ Cross-origin isolation enabled - multi-threading available', 'success');
                        ort.env.wasm.numThreads = 4; // Enable multi-threading
                    }

                    // Check WebGPU support
                    if (!navigator.gpu) {
                        logInferenceEvent('‚ö†Ô∏è WebGPU not supported in this browser - using WASM backend', 'warning');
                        this.webgpuSupported = false;
                    } else {
                        try {
                            const adapter = await navigator.gpu.requestAdapter();
                            if (adapter) {
                                logInferenceEvent('‚úÖ WebGPU adapter found', 'success');
                                this.webgpuSupported = true;
                            } else {
                                logInferenceEvent('‚ö†Ô∏è WebGPU adapter not available - using WASM backend', 'warning');
                                this.webgpuSupported = false;
                            }
                        } catch (error) {
                            logInferenceEvent(`‚ö†Ô∏è WebGPU initialization failed: ${error.message}`, 'warning');
                            this.webgpuSupported = false;
                        }
                    }


                    // Call validation before loading models
                    if (this.webgpuSupported) {
                        await this.validateWebGPUForModels();
                        await this.validateModelFile('./stylevae.onnx');
                    }


                    // Load all three models
                    await this.loadModels();

                    // Initialize with neutral style
                    this.currentStyle.fill(0.1);

                    this.isInitialized = true;
                    logInferenceEvent('üéØ AI Model Manager initialized successfully!', 'success');

                } catch (error) {
                    logInferenceEvent(`‚ùå AI initialization failed: ${error.message}`, 'error');
                    throw error;
                }
            }


            async validateWebGPUForModels() {
                logInferenceEvent('üîç Validating WebGPU capabilities...', 'info');
                
                try {
                    // Check WebGPU adapter limits
                    const adapter = await navigator.gpu.requestAdapter();
                    const device = await adapter.requestDevice();
                    
                    const limits = adapter.limits;
                    logInferenceEvent(`üéÆ WebGPU Limits:`, 'info');
                    logInferenceEvent(`   Max buffer size: ${limits.maxBufferSize}`, 'info');
                    logInferenceEvent(`   Max texture dimension: ${limits.maxTextureDimension2D}`, 'info');
                    logInferenceEvent(`   Max compute workgroup size: ${limits.maxComputeWorkgroupSizeX}`, 'info');
                    
                    // Check ONNX Runtime WebGPU support
                    logInferenceEvent(`üîç ONNX Runtime version: ${ort.version || 'unknown'}`, 'info');
                    
                    // Test simple WebGPU tensor creation
                    const testTensor = new ort.Tensor('float32', [1, 2, 3, 4], [2, 2]);
                    logInferenceEvent(`‚úÖ Basic tensor creation works`, 'success');
                    
                    return true;
                    
                } catch (error) {
                    logInferenceEvent(`‚ùå WebGPU validation failed: ${error.message}`, 'error');
                    return false;
                }
            }


            async validateModelFile(modelPath) {
                try {
                    logInferenceEvent(`üîç Validating model file: ${modelPath}`, 'info');

                    const response = await fetch(modelPath);
                    if (!response.ok) {
                        throw new Error(`Model file not found: ${response.status} ${response.statusText}`);
                    }

                    const arrayBuffer = await response.arrayBuffer();
                    const fileSize = arrayBuffer.byteLength;

                    logInferenceEvent(`üìä Model file size: ${(fileSize / 1024 / 1024).toFixed(2)} MB`, 'info');

                    if (fileSize === 0) {
                        throw new Error('Model file is empty');
                    }

                    if (fileSize > 100 * 1024 * 1024) { // 100MB
                        logInferenceEvent(`‚ö†Ô∏è Large model file (${(fileSize / 1024 / 1024).toFixed(2)} MB) - may cause WebGPU issues`, 'warning');
                    }

                    // Check if it's a valid ONNX file (starts with specific bytes)
                    const uint8Array = new Uint8Array(arrayBuffer, 0, 8);
                    const header = Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join('');
                    logInferenceEvent(`üìä Model file header: ${header}`, 'info');

                    return true;

                } catch (error) {
                    logInferenceEvent(`‚ùå Model validation failed: ${error.message}`, 'error');
                    return false;
                }
            }


            async loadModels() {
                const modelConfigs = {
                    stylevae: {
                        path: './stylevae.onnx',
                        inputShape: [1, 66, 60], // [batch, channels, sequence_length]
                        outputShape: [1, 256]    // [batch, style_dim]
                    },
                    deepphase: {
                        path: './deepphase.onnx',
                        inputShape: [1, 92],      // [batch, channels]
                        outputShape: [1, 1]       // [batch, phase]
                    },
                    transitionnet: {
                        path: './transitionnet.onnx',
                        inputShape: [1, 1, 66 + 256], // [batch, motion + style]
                        outputShape: [1, 66]        // [batch, output_motion]
                    }
                };


                for (const [modelName, config] of Object.entries(modelConfigs)) {
                    try {
                        updateModelStatus(modelName, 'Loading...', 'Downloading ONNX model');
                        logInferenceEvent(`üì• Loading ${modelName} from ${config.path}...`, 'info');

                        // Determine execution providers based on capabilities
                        let executionProviders;
                        if (this.webgpuSupported) {
                            executionProviders = ['webgpu', 'wasm'];
                            logInferenceEvent(`üéØ ${modelName}: Trying WebGPU first`, 'info');
                        } else {
                            executionProviders = ['wasm'];
                            logInferenceEvent(`üîß ${modelName}: Using WASM backend only`, 'info');
                        }

                        let session;
                        try {
                            session = await ort.InferenceSession.create(config.path, {
                                executionProviders: executionProviders,
                                graphOptimizationLevel: 'all'
                            });

                            logInferenceEvent(`‚úÖ ${modelName} loaded on ${executionProviders[0]}`, 'success');

                        } catch (providerError) {
                            if (this.webgpuSupported && executionProviders.includes('webgpu')) {
                                logInferenceEvent(`‚ö†Ô∏è WebGPU failed for ${modelName}, trying WASM: ${providerError.message}`, 'warning');
                                // Fallback to WASM only
                                session = await ort.InferenceSession.create(config.path, {
                                    executionProviders: ['wasm'],
                                    graphOptimizationLevel: 'all'
                                });
                                logInferenceEvent(`‚úÖ ${modelName} loaded on WASM (fallback)`, 'success');
                            } else {
                                throw providerError;
                            }
                        }

                        this.models[modelName] = {
                            session: session,
                            config: config,
                            lastInferenceTime: 0
                        };

                        updateModelStatus(modelName, 'Ready', `Loaded successfully`);

                    } catch (error) {
                        updateModelStatus(modelName, 'Failed', error.message);
                        logInferenceEvent(`‚ùå Failed to load ${modelName}: ${error.message}`, 'error');
                        throw error;
                    }
                }
            }

            async encodeStyle(motionSequence) {
                if (!this.models.stylevae) {
                    throw new Error('StyleVAE model not loaded');
                }

                const startTime = performance.now();
                updateModelStatus('stylevae', 'Processing...', 'Encoding style from motion');

                try {
                    // Prepare input tensor
                    const inputTensor = new ort.Tensor('float32', motionSequence, [1, 66, 60]);

                    // Run inference
                    const feeds = { input_vector: inputTensor };
                    const results = await this.models.stylevae.session.run(feeds);

                    // Extract style vector
                    const styleVector = results.output.data;
                    this.currentStyle = new Float32Array(styleVector);

                    const processingTime = performance.now() - startTime;
                    this.models.stylevae.lastInferenceTime = processingTime;

                    updateModelStatus('stylevae', 'Active', `Style encoded in ${processingTime.toFixed(1)}ms`);
                    logInferenceEvent(`üé® Style encoded: ${styleVector.length}D vector in ${processingTime.toFixed(1)}ms`, 'success');

                    return this.currentStyle;

                } catch (error) {
                    updateModelStatus('stylevae', 'Error', error.message);
                    logInferenceEvent(`‚ùå StyleVAE inference failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            async predictPhase(motionFrame) {
                if (!this.models.deepphase) {
                    throw new Error('DeepPhase model not loaded');
                }

                const startTime = performance.now();

                try {
                    // Prepare input tensor
                    const inputTensor = new ort.Tensor('float32', motionFrame, [1, 66]);

                    // Run inference
                    const feeds = { motion_features: inputTensor };
                    const results = await this.models.deepphase.session.run(feeds);

                    // Extract phase
                    this.currentPhase = results.output.data[0];

                    const processingTime = performance.now() - startTime;
                    this.models.deepphase.lastInferenceTime = processingTime;

                    // Update UI every 30 frames to avoid spam
                    if (animationFrame % 30 === 0) {
                        updateModelStatus('deepphase', 'Active', `Phase: ${this.currentPhase.toFixed(3)}`);
                        logInferenceEvent(`üîÑ Phase predicted: ${this.currentPhase.toFixed(3)} (${processingTime.toFixed(1)}ms)`, 'info');
                    }

                    return this.currentPhase;

                } catch (error) {
                    updateModelStatus('deepphase', 'Error', error.message);
                    logInferenceEvent(`‚ùå DeepPhase inference failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            async generateTransition(currentMotion, targetStyle, transitionLength = 10) {
                if (!this.models.transitionnet) {
                    throw new Error('TransitionNet model not loaded');
                }

                const startTime = performance.now();
                updateModelStatus('transitionnet', 'Generating...', 'Creating motion transition');

                try {
                    // Combine motion and style
                    const combinedInput = new Float32Array(66 + 256);
                    combinedInput.set(currentMotion, 0);
                    combinedInput.set(targetStyle, 66);

                    // Prepare input tensor
                    const inputTensor = new ort.Tensor('float32', combinedInput, [1, 1, 66 + 256]);

                    // Run inference
                    const feeds = { sequence_input: inputTensor };
                    const results = await this.models.transitionnet.session.run(feeds);

                    // Extract generated motion
                    const generatedMotion = results.output.data;

                    const processingTime = performance.now() - startTime;
                    this.models.transitionnet.lastInferenceTime = processingTime;

                    updateModelStatus('transitionnet', 'Active', `Transition generated in ${processingTime.toFixed(1)}ms`);
                    logInferenceEvent(`üîÑ Transition generated: ${generatedMotion.length} values in ${processingTime.toFixed(1)}ms`, 'success');

                    return new Float32Array(generatedMotion);

                } catch (error) {
                    updateModelStatus('transitionnet', 'Error', error.message);
                    logInferenceEvent(`‚ùå TransitionNet inference failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            updateMotionHistory(motionFrame) {
                this.motionHistory.push(new Float32Array(motionFrame));

                // Keep only recent history
                if (this.motionHistory.length > this.maxHistoryFrames) {
                    this.motionHistory.shift();
                }
            }

            getMotionSequence() {
                // Return flattened motion sequence for StyleVAE
                if (this.motionHistory.length < 60) {
                    // Pad with zeros if not enough history
                    const sequence = new Float32Array(66 * 60);
                    for (let i = 0; i < this.motionHistory.length; i++) {
                        sequence.set(this.motionHistory[i], i * 66);
                    }
                    return sequence;
                } else {
                    // Use last 60 frames
                    const sequence = new Float32Array(66 * 60);
                    const recentFrames = this.motionHistory.slice(-60);
                    for (let i = 0; i < recentFrames.length; i++) {
                        sequence.set(recentFrames[i], i * 66);
                    }
                    return sequence;
                }
            }
        }

        // Global AI model manager
        let aiModelManager = new RSMTModelManager();



        try {
            updateLoadingStatus('Importing THREE.js module...');
            
            // Import THREE.js using ES modules
            const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js');
           
            // Expose THREE and its core components to the global window object
            // so the iframe can access them.
            window.THREE = THREE;

            updateLoadingStatus('THREE.js loaded successfully!');
            
            // Update version info
            document.getElementById('three-version').textContent = THREE.REVISION || 'ES Module';
            
            // Initialize 3D scene
            updateLoadingStatus('Creating 3D scene...');
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            const camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true 
            });

            window.scene = scene;
            window.camera = camera;
            window.renderer = renderer;


            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Add renderer to container (below UI)
            container.appendChild(renderer.domElement);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.zIndex = '1';
            
            updateLoadingStatus('Setting up enhanced lighting and environment...');
            
            // Enhanced lighting setup like legacy version
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add additional lighting for better visibility
            const pointLight1 = new THREE.PointLight(0x4444ff, 0.5, 100);
            pointLight1.position.set(-5, 5, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff4444, 0.5, 100);
            pointLight2.position.set(5, 5, -5);
            scene.add(pointLight2);
            
            // Add grid floor and axes helpers like legacy version
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            updateLoadingStatus('Creating demo skeleton...');
            
            // Create a simple stick figure skeleton for demo
            skeletonGroup = new THREE.Group();
            
            // Create joints with proper geometry and materials (matching legacy)
            const jointGeometry = new THREE.SphereGeometry(0.04, 12, 12);
            const jointMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x00ff00,
                emissive: 0x002200
            });
            
            // Create bone geometry and material (matching legacy style)
            const boneGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
            const boneMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0088ff,
                emissive: 0x001122
            });
            
            // ===== CORRECT BVH SKELETON FROM ACTUAL 100STYLE FILES =====
            // This matches the EXACT structure from Neutral_FW.bvh
            const bvhJoints = {
                // Root joint (world position) - 6 channels: pos + rot
                'Hips': { offset: [0.000000, 0.000000, 0.000000], parent: null },
                
                // Spine chain - exact offsets from BVH
                'Chest': { offset: [0.000000, 12.953391, -0.028419], parent: 'Hips' },
                'Chest2': { offset: [0.000000, 10.280254, 0.051622], parent: 'Chest' },
                'Chest3': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest2' },
                'Chest4': { offset: [0.000000, 9.287180, 0.000000], parent: 'Chest3' },
                'Neck': { offset: [0.000000, 13.296264, 0.000000], parent: 'Chest4' },
                'Head': { offset: [0.000000, 8.959264, 0.099003], parent: 'Neck' },
                
                // Right arm chain - exact offsets from BVH
                'RightCollar': { offset: [-3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'RightShoulder': { offset: [-15.792092, 0.000000, 0.000000], parent: 'RightCollar' },
                'RightElbow': { offset: [-31.151839, 0.000000, 0.000000], parent: 'RightShoulder' },
                'RightWrist': { offset: [-25.536298, 0.000000, 0.002321], parent: 'RightElbow' },
                
                // Left arm chain - will be mirrored
                'LeftCollar': { offset: [3.193511, 7.451388, 0.000000], parent: 'Chest4' },
                'LeftShoulder': { offset: [15.792092, 0.000000, 0.000000], parent: 'LeftCollar' },
                'LeftElbow': { offset: [31.151839, 0.000000, 0.000000], parent: 'LeftShoulder' },
                'LeftWrist': { offset: [25.536298, 0.000000, 0.002321], parent: 'LeftElbow' },
                
                // Right leg chain - exact offsets from BVH
                'RightHip': { offset: [-10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'RightKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'RightHip' },
                'RightAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'RightKnee' },
                'RightToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'RightAnkle' },
                
                // Left leg chain - mirrored from BVH
                'LeftHip': { offset: [10.745749, 0.139252, 0.014209], parent: 'Hips' },
                'LeftKnee': { offset: [0.000000, -43.743899, -0.006071], parent: 'LeftHip' },
                'LeftAnkle': { offset: [0.000000, -43.214199, 0.089931], parent: 'LeftKnee' },
                'LeftToe': { offset: [0.000000, -9.699830, 19.151588], parent: 'LeftAnkle' }
            };
            
            
            // Create hierarchical skeleton with proper parent-child relationships
            function createHierarchicalSkeleton(joints) {
                const jointMeshes = {};
                const processedJoints = new Set();
                
                function createJoint(jointName) {
                    if (processedJoints.has(jointName) || !joints[jointName]) {
                        return jointMeshes[jointName] || null;
                    }
                    
                    const jointData = joints[jointName];
                    
                    // Create joint mesh
                    const mesh = new THREE.Mesh(jointGeometry, jointMaterial);
                    mesh.userData.bvhJointName = jointName;
                    mesh.userData.isJoint = true;
                    
                    // Set local position relative to parent
                    mesh.position.set(
                        jointData.offset[0] * bvhScale,
                        jointData.offset[1] * bvhScale,
                        jointData.offset[2] * bvhScale
                    );
                    
                    jointMeshes[jointName] = mesh;
                    processedJoints.add(jointName);
                    
                    // Add to parent or root
                    if (jointData.parent && joints[jointData.parent]) {
                        // Ensure parent exists first
                        const parentMesh = createJoint(jointData.parent);
                        if (parentMesh) {
                            parentMesh.add(mesh);
                        } else {
                            skeletonGroup.add(mesh);
                        }
                    } else {
                        // Root joint
                        skeletonGroup.add(mesh);
                    }
                    
                    return mesh;
                }
                
                // Create all joints with proper hierarchy
                for (const jointName of Object.keys(joints)) {
                    createJoint(jointName);
                }
                
                return jointMeshes;
            }
            
            jointMeshes = createHierarchicalSkeleton(bvhJoints);
            
            // Create bones connecting parent-child joints
            boneCylinders = [];
            
            for (const [jointName, jointData] of Object.entries(bvhJoints)) {
                if (jointData.parent && jointMeshes[jointData.parent] && jointMeshes[jointName]) {
                    const parentMesh = jointMeshes[jointData.parent];
                    const childMesh = jointMeshes[jointName];
                    
                    // Calculate bone length from local position
                    const localPos = childMesh.position;
                    const length = localPos.length();
                    
                    if (length > 0.01) { // Only create visible bones
                        const cylinder = new THREE.Mesh(boneGeometry, boneMaterial);
                        
                        // Position bone at parent's origin, pointing toward child
                        cylinder.position.set(0, 0, 0);
                        cylinder.scale.set(1, length, 1);
                        
                        // Rotate to point toward child
                        const direction = localPos.clone().normalize();
                        const up = new THREE.Vector3(0, 1, 0);
                        cylinder.quaternion.setFromUnitVectors(up, direction);
                        
                        // Offset to start at parent center and extend to child
                        cylinder.position.copy(direction.multiplyScalar(length * 0.5));
                        
                        // Add bone to parent joint so it moves with the joint
                        parentMesh.add(cylinder);
                        
                        cylinder.userData = {
                            parentJoint: jointData.parent,
                            childJoint: jointName,
                            length: length
                        };
                        
                        boneCylinders.push(cylinder);
                    }
                }
            }
            
            // Function to update bone positions (simplified since bones are now parented to joints)
            function updateBones() {
                // Bones automatically follow their parent joints due to hierarchy
                // No manual updates needed - THREE.js handles this automatically
            }
            
            scene.add(skeletonGroup);
            
            // DEBUG: Add a larger test sphere at skeleton origin
            const originGeometry = new THREE.SphereGeometry(0.1, 12, 12);
            const originMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const originSphere = new THREE.Mesh(originGeometry, originMaterial);
            originSphere.position.set(0, 0, 0); // At origin where skeleton should be
            originSphere.name = 'originSphere';
            scene.add(originSphere);
            
            // Let BVH data control the orientation - no manual corrections
            skeletonGroup.position.y = 0; // Start at ground level
            skeletonGroup.rotation.set(0, 0, 0); // No base rotation
            skeletonGroup.rotation.order = 'YXZ'; // Match BVH rotation order
            
            // Update skeleton metrics
            document.getElementById('joint-count').textContent = Object.keys(jointMeshes).length;
            document.getElementById('bone-count').textContent = boneCylinders.length;
            
            // Position camera
            camera.position.set(3, 2, 3);
            camera.lookAt(0, 0.5, 0);
            
            updateLoadingStatus('Starting animation...');
            
            // Animation styles with different parameters
            const animationStyles = {
                neutral: { speed: 1.0, intensity: 1.0, bounce: 0.1, description: 'Natural walking' },
                happy: { speed: 1.3, intensity: 1.5, bounce: 0.3, description: 'Bouncy, energetic' },
                sad: { speed: 0.7, intensity: 0.5, bounce: 0.05, description: 'Slow, heavy steps' },
                angry: { speed: 1.2, intensity: 2.0, bounce: 0.1, description: 'Aggressive, forceful' },
                energetic: { speed: 1.8, intensity: 1.8, bounce: 0.4, description: 'High energy' },
                graceful: { speed: 0.9, intensity: 0.8, bounce: 0.2, description: 'Smooth, elegant' },
                robotic: { speed: 1.0, intensity: 1.0, bounce: 0.0, description: 'Mechanical, stiff' }
            };
            
            // Animation control functions
            function toggleAnimation() {
                isPlaying = !isPlaying;
                const btn = document.getElementById('play-pause-btn');
                btn.textContent = isPlaying ? 'Pause' : 'Play';
                btn.style.background = isPlaying ? '#4CAF50' : '#f44336';
            }
            
            function updateAnimationSpeed(value) {
                animationSpeed = parseFloat(value);
                document.getElementById('speed-value').textContent = value + 'x';
                document.getElementById('animation-speed').textContent = value + 'x';
                console.log('Animation speed changed to:', animationSpeed);
            }
            
            function resetAnimation() {
                animationFrame = 0;
                currentFrame = 0;
                console.log('Animation reset');
            }
            
            function debugFrame() {
                if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                    const frames = bvhData[currentAnimation].frames;
                    const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                    const frameData = frames[frameIndex];
                    
                    console.log('üîç Debug Frame Info:');
                    console.log('Current frame:', frameIndex);
                    console.log('Frame data length:', frameData.length);
                    console.log('First 12 values (root pos + rot):', frameData.slice(0, 12));
                    console.log('Animation speed:', animationSpeed);
                    console.log('Total frames:', frames.length);
                    console.log('Skeleton rotation:', skeletonGroup.rotation);
                    console.log('Skeleton position:', skeletonGroup.position);
                    
                    // Log some joint rotations
                    let channelIndex = 6; // Skip root pos and rot
                    console.log('Joint rotations:');
                    bvhJointOrder.slice(0, 3).forEach(jointName => {
                        if (channelIndex + 2 < frameData.length) {
                            const rotY = frameData[channelIndex++];
                            const rotX = frameData[channelIndex++];
                            const rotZ = frameData[channelIndex++];
                            console.log(`${jointName}: Y=${rotY.toFixed(2)}, X=${rotX.toFixed(2)}, Z=${rotZ.toFixed(2)}`);
                        }
                    });
                }
            }
            
            let orientationMode = 0;
            function fixOrientation() {
                // DISABLED: Let BVH data control all orientation
                console.log('‚ö†Ô∏è fixOrientation() disabled - using pure BVH data only');
            }
            
            let directionMultiplier = 1;
            function flipDirection() {
                // DISABLED: Let BVH data control all direction
                console.log('‚ö†Ô∏è flipDirection() disabled - using pure BVH data only');
            }
            
            // Make direction multiplier global
            window.directionMultiplier = directionMultiplier;
            
            let jointIntensity = 0.1;
            function updateJointIntensity(value) {
                jointIntensity = parseFloat(value);
                document.getElementById('intensity-value').textContent = value;
                console.log('Joint intensity changed to:', jointIntensity);
            }
            
            // Make intensity global
            window.jointIntensity = jointIntensity;
            
            // REMOVED: Root constraint functions - using pure BVH with no constraints
            
            let simpleMode = false;
            function toggleSimpleMode() {
                simpleMode = !simpleMode;
                const btn = document.getElementById('simple-mode-btn');
                btn.textContent = simpleMode ? 'Full Mode' : 'Simple Mode';
                btn.style.background = simpleMode ? '#4CAF50' : '#607D8B';
                console.log('Simple mode:', simpleMode);
            }
            
            function debugBVH() {
                console.log('üîç BVH Debug Information:');
                console.log('Current animation:', currentAnimation);
                console.log('BVH data loaded:', Object.keys(bvhData));
                
                if (bvhData[currentAnimation]) {
                    const data = bvhData[currentAnimation];
                    console.log('Frames:', data.frames?.length || 0);
                    console.log('Frame time:', data.frameTime);
                    console.log('Channel count:', data.channelCount);
                    
                    if (data.frames && data.frames.length > 0) {
                        console.log('First frame data:', data.frames[0].slice(0, 12));
                        console.log('Sample middle frame:', data.frames[Math.floor(data.frames.length/2)].slice(0, 12));
                    }
                } else {
                    console.log('‚ùå No BVH data loaded for:', currentAnimation);
                }
                
                console.log('Skeleton joints created:', Object.keys(jointMeshes));
                console.log('Skeleton group position:', skeletonGroup.position);
                console.log('Skeleton group rotation:', skeletonGroup.rotation);
                console.log('Animation frame:', animationFrame);
                console.log('Animation speed:', animationSpeed);
                console.log('Is playing:', isPlaying);
            }
            
            function resetCharacterDirection() {
                console.log('üîÑ Resetting character direction - PURE BVH MODE');
                window.characterHeading = 0;
                animationFrame = 0; // Reset animation to beginning
                
                // REMOVED: Do NOT manually set skeleton rotation/position
                // Let BVH data control everything when next frame is applied
                console.log('‚úÖ Animation reset to frame 0 - BVH will control all transforms');
            }
            
            // Make functions global for onclick handlers
            window.toggleAnimation = toggleAnimation;
            window.updateAnimationSpeed = updateAnimationSpeed;
            window.resetAnimation = resetAnimation;
            window.debugFrame = debugFrame;
            window.fixOrientation = fixOrientation;
            window.flipDirection = flipDirection;
            window.updateJointIntensity = updateJointIntensity;
            window.toggleSimpleMode = toggleSimpleMode;
            window.debugBVH = debugBVH;
            window.resetCharacterDirection = resetCharacterDirection;
            


            // === AI-POWERED ANIMATION LOOP ===
            let baseMotion = null;
            let generatedMotion = null;
            let styleUpdateCounter = 0;

            async function toggleAIMode() {
                window.aiMode = !window.aiMode;
                const aiModeBtn = document.getElementById('ai-mode-btn');
               
                // Add this to see what's calling the AI mode
                console.log('üîç Debug at toggleAIMode():');
                console.log('- aiMode:', window.aiMode);
                console.log('- aiModelManager.isInitialized:', aiModelManager.isInitialized);

                if (window.aiMode) {
                    if (!aiModelManager.isInitialized) {
                        try {
                            await aiModelManager.initialize();
                        } catch (error) {
                            logInferenceEvent(`‚ùå Cannot enable AI mode: ${error.message}`, 'error');
                            window.aiMode = false;
                            return;
                        }
                    }
                    
                    aiModeBtn.textContent = 'ü§ñ AI Mode: ON';
                    aiModeBtn.style.background = '#4CAF50';
                    statusDiv.textContent = 'AI Mode: Neural networks controlling motion';
                    logInferenceEvent('üß† AI Mode activated - neural networks now controlling motion', 'success');
                    
                    // Initialize with current BVH frame as seed
                    if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                        const currentFrame = bvhData[currentAnimation].frames[0];
                        baseMotion = new Float32Array(currentFrame.slice(0, 66));
                        aiModelManager.updateMotionHistory(baseMotion);
                    }
                    
                } else {
                    aiModeBtn.textContent = 'üé¨ BVH Mode: ON';
                    aiModeBtn.style.background = '#2196F3';
                    statusDiv.textContent = 'BVH Mode: Playing recorded motion capture';
                    logInferenceEvent('üé¨ BVH Mode activated - playing recorded motion', 'info');
                }
            }

            window.toggleAIMode = toggleAIMode;

            // Modified animation loop with AI integration
            function animate() {
                requestAnimationFrame(animate);
                
                if (isPlaying && !isParentAnimationPaused) {
                    animationFrame++;
                   
                    // Add this to see what's calling the AI mode
                    //console.log('üîç Debug at line 342:');
                    //console.log('- aiMode:', window.aiMode);
                    //console.log('- aiModelManager.isInitialized:', aiModelManager.isInitialized);
                    //console.log('- Stack trace:');
                    //console.trace();

                    if (window.aiMode == true  && aiModelManager.isInitialized) {
                        // === AI-POWERED MOTION GENERATION ===
                        console.log('ü§ñ Running AI mode');

                        try {
                            // Every 10 frames, update style encoding
                            if (styleUpdateCounter % 10 === 0 && aiModelManager.motionHistory.length >= 60) {
                                const motionSequence = aiModelManager.getMotionSequence();
                                aiModelManager.encodeStyle(motionSequence).catch(error => {
                                    logInferenceEvent(`Style encoding failed: ${error.message}`, 'error');
                                });
                            }
                            styleUpdateCounter++;
                            
                            if (baseMotion) {
                                // Predict phase for current motion
                                aiModelManager.predictPhase(baseMotion).then(phase => {
                                    document.getElementById('current-frame').textContent = `AI Phase: ${phase.toFixed(3)}`;
                                }).catch(error => {
                                    console.warn('Phase prediction failed:', error);
                                });
                                
                                // Generate next motion frame using TransitionNet
                                if (styleUpdateCounter % 5 === 0) { // Generate every 5 frames
                                    aiModelManager.generateTransition(
                                        baseMotion,
                                        aiModelManager.currentStyle
                                    ).then(newMotion => {
                                        generatedMotion = newMotion;
                                        baseMotion = newMotion; // Use generated motion as next base
                                        aiModelManager.updateMotionHistory(newMotion);
                                        
                                        // Apply AI-generated motion to skeleton
                                        applyAIMotionFrame(newMotion);
                                        
                                    }).catch(error => {
                                        console.warn('Transition generation failed:', error);
                                    });
                                }
                                
                                // Update UI metrics
                                document.getElementById('inference-rate').textContent = 
                                    `${(1000 / (aiModelManager.models.deepphase?.lastInferenceTime || 16)).toFixed(1)} FPS`;
                                document.getElementById('inference-latency').textContent = 
                                    `${(aiModelManager.models.deepphase?.lastInferenceTime || 16).toFixed(1)}ms`;
                            }
                            
                        } catch (error) {
                            logInferenceEvent(`‚ùå AI processing error: ${error.message}`, 'error');
                            // Fallback to BVH mode
                            aiMode = false;
                            toggleAIMode();
                        }
                        
                    } else {
                        // === ORIGINAL BVH PLAYBACK ===
                        console.log('üé¨ Running BVH mode');

                        if (bvhData[currentAnimation] && bvhData[currentAnimation].frames.length > 0) {
                            const frames = bvhData[currentAnimation].frames;
                            const frameIndex = Math.floor(animationFrame * animationSpeed) % frames.length;
                            const frameData = frames[frameIndex];
            
                            // ‚úÖ Only apply parent frames if child is NOT transitioning
                            if (!isParentAnimationPaused) {
                                // Apply BVH frame data to skeleton
                                applyBVHFrame(frameData);
                            }

                            // Update motion history for potential AI mode switch
                            if (frameData.length >= 66) {
                                aiModelManager.updateMotionHistory(frameData.slice(0, 66));
                            }
                            
                            // Update frame counter
                            document.getElementById('current-frame').textContent = `${frameIndex + 1}/${frames.length} (BVH)`;
                            
                        } else {
                            document.getElementById('current-frame').textContent = 'No BVH data';
                        }
                    }
                    
                    // Update UI displays
                    document.getElementById('animation-speed').textContent = `${animationSpeed.toFixed(1)}x`;
                }
                
                // Update bones and render
                updateBones();
                renderer.render(scene, camera);
            }

            // New function to apply AI-generated motion
            function applyAIMotionFrame(motionData) {
                if (!motionData || motionData.length < 66) return;
                
                let channelIndex = 0;
                
                // Root position (first 3 channels)
                const rootX = motionData[channelIndex++] || 0;
                const rootY = motionData[channelIndex++] || 0;
                const rootZ = motionData[channelIndex++] || 0;
                
                // Root rotation (next 3 channels)
                const rootRotY = (motionData[channelIndex++] || 0) * Math.PI / 180;
                const rootRotX = (motionData[channelIndex++] || 0) * Math.PI / 180;
                const rootRotZ = (motionData[channelIndex++] || 0) * Math.PI / 180;
                
                // Apply AI-generated root transformation
                if (skeletonGroup) {
                    skeletonGroup.position.set(
                        rootX * bvhScale,
                        rootY * bvhScale,
                        rootZ * bvhScale
                    );
                    
                    skeletonGroup.rotation.order = 'YXZ';
                    skeletonGroup.rotation.set(rootRotX, rootRotY, rootRotZ);
                    
                    // Log AI motion every 60 frames
                    if (animationFrame % 60 === 0) {
                        console.log('ü§ñ AI Motion:', {
                            rootPos: { x: rootX.toFixed(2), y: rootY.toFixed(2), z: rootZ.toFixed(2) },
                            rootRot: { x: (rootRotX*180/Math.PI).toFixed(1), y: (rootRotY*180/Math.PI).toFixed(1), z: (rootRotZ*180/Math.PI).toFixed(1) },
                            currentStyle: aiModelManager.currentStyle.slice(0, 5), // First 5 style dimensions
                            phase: aiModelManager.currentPhase.toFixed(3)
                        });
                    }
                }
                
                // Apply joint rotations (same logic as BVH but with AI data)
                const bvhJointOrder = [
                    'Chest', 'Chest2', 'Chest3', 'Chest4', 'Neck', 'Head',
                    'RightCollar', 'RightShoulder', 'RightElbow', 'RightWrist',
                    'LeftCollar', 'LeftShoulder', 'LeftElbow', 'LeftWrist',
                    'RightHip', 'RightKnee', 'RightAnkle', 'RightToe',
                    'LeftHip', 'LeftKnee', 'LeftAnkle', 'LeftToe'
                ];
                
                bvhJointOrder.forEach(jointName => {
                    if (jointMeshes[jointName] && channelIndex + 2 < motionData.length) {
                        const rotY = (motionData[channelIndex++] || 0) * Math.PI / 180;
                        const rotX = (motionData[channelIndex++] || 0) * Math.PI / 180;
                        const rotZ = (motionData[channelIndex++] || 0) * Math.PI / 180;
                        
                        jointMeshes[jointName].rotation.order = 'YXZ';
                        jointMeshes[jointName].rotation.set(rotX, rotY, rotZ);
                    }
                });
            }


            
            // Setup enhanced controls
            document.getElementById('play-pause').onclick = () => {
                isPlaying = !isPlaying;
                statusDiv.textContent = isPlaying ? 'Playing' : 'Paused';
            };
            
            document.getElementById('reset').onclick = () => {
                animationFrame = 0;
                // REMOVED: skeletonGroup.rotation.y = 0; // Let BVH control rotation!
                animationSpeed = 1.0;
                currentStyle = 'neutral';
                document.getElementById('current-style').textContent = currentStyle;
                statusDiv.textContent = 'Reset to neutral (BVH-controlled)';
            };
            
            document.getElementById('cycle-animations').onclick = () => {
                // Cycle through real BVH animations
                const animFiles = Object.keys(animations);
                const currentIndex = animFiles.indexOf(currentAnimation);
                const nextFile = animFiles[(currentIndex + 1) % animFiles.length];
                
                loadAnimation(nextFile);
                statusDiv.textContent = `Loading: ${animations[nextFile].name}`;
            };
            
            document.getElementById('random-style').onclick = () => {
                // Load random BVH animation
                const animFiles = Object.keys(animations);
                const randomFile = animFiles[Math.floor(Math.random() * animFiles.length)];
                
                loadAnimation(randomFile);
                statusDiv.textContent = `Random: ${animations[randomFile].name}`;
            };
            
            document.getElementById('speed-up').onclick = () => {
                animationSpeed = Math.min(3.0, animationSpeed * 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('slow-down').onclick = () => {
                animationSpeed = Math.max(0.2, animationSpeed / 1.2);
                statusDiv.textContent = `Speed: ${animationSpeed.toFixed(1)}x`;
            };
            
            document.getElementById('toggle-wireframe').onclick = () => {
                isWireframe = !isWireframe;
                // Toggle wireframe on joint materials
                Object.values(jointMeshes).forEach(joint => {
                    joint.material.wireframe = isWireframe;
                });
                statusDiv.textContent = isWireframe ? 'Wireframe ON' : 'Wireframe OFF';
            };
            
            document.getElementById('transition-demo').onclick = () => {
                statusDiv.textContent = 'Running animation transition demo...';
                document.getElementById('transition-state').textContent = 'Active';
                
                // Cycle through different BVH animations
                const animFiles = Object.keys(animations);
                let animIndex = 0;
                
                const transitionInterval = setInterval(() => {
                    const animFile = animFiles[animIndex];
                    loadAnimation(animFile);
                    const animData = animations[animFile];
                    document.getElementById('current-style').textContent = animData.name;
                    statusDiv.textContent = `Transition: ${animData.name} - ${animData.description}`;
                    animIndex = (animIndex + 1) % animFiles.length;
                    
                    if (animIndex === 0) {
                        clearInterval(transitionInterval);
                        document.getElementById('transition-state').textContent = 'Complete';
                        statusDiv.textContent = 'Animation transition demo completed';
                        loadAnimation('neutral_reference.bvh');
                        document.getElementById('current-style').textContent = 'Neutral Walking';
                    }
                }, 2000);
            };
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
                      

            // ‚úÖ Add this function to check ONNX Runtime setup
            window.checkONNXRuntimeSetup = function() {
                console.log('üîç === ONNX RUNTIME SETUP CHECK ===');
                
                // Check if ONNX Runtime is properly loaded
                console.log('Global ort object:', typeof ort);
                console.log('ort.version:', ort.version);
                console.log('ort.env:', ort.env);
                
                // Check WebGPU support in ONNX Runtime
                console.log('WebGPU support checks:');
                console.log('- ort.env.webgpu:', ort.env.webgpu);
                console.log('- ort.env.wasm:', ort.env.wasm);
                
                // Check execution providers
                console.log('Available execution providers:');
                try {
                    // This might not work in all versions, but worth checking
                    if (ort.env.webgpu) {
                        console.log('- WebGPU execution provider: Available');
                    } else {
                        console.log('- WebGPU execution provider: Not available');
                    }
                } catch (e) {
                    console.log('- Could not check execution providers:', e.message);
                }
                
                // Check browser WebGPU support
                console.log('Browser WebGPU support:');
                console.log('- navigator.gpu:', !!navigator.gpu);
                if (navigator.gpu) {
                    navigator.gpu.requestAdapter().then(adapter => {
                        console.log('- WebGPU adapter:', !!adapter);
                        if (adapter) {
                            console.log('- Adapter features:', Array.from(adapter.features || []));
                        }
                    });
                }
            };


            // Start animation loop and load first animation
            animate();
            
            // Load default animation
            //updateLoadingStatus('Loading default animation...');
            //loadAnimation('neutral_reference.bvh');
            
            // AFTER (loads all of them):
            await loadAllAnimations();

            // Hide loading screen
            updateLoadingStatus('Complete!');
            setTimeout(() => {
                loadingDiv.style.display = 'none';
                statusDiv.textContent = 'Modern RSMT Viewer Ready! Loading real BVH animations.';
            }, 1000);

            // Now that the parent's scene is fully loaded, notify the child iframe.
            transitionIntegration.notifyChildSceneReady();
            
        } catch (error) {
            console.error('‚ùå Error loading THREE.js:', error);
            updateLoadingStatus('Error: ' + error.message);
            statusDiv.textContent = 'Error loading 3D engine';
            statusDiv.className = 'error';
            
            // Hide loading screen even on error
            setTimeout(() => {
                loadingDiv.style.display = 'none';
            }, 3000);
        }
        

        // Load and parse BVH animation files
        async function loadAnimation(filename) {
            try {
                console.log('üé¨ Loading animation:', filename);
                statusDiv.textContent = `Loading ${filename}...`;
                
                // Try to load actual BVH data
                try {
                    console.log('üì° Fetching BVH file:', filename);
                    const response = await fetch(filename);
                    console.log('üîç Response status:', response.status, response.statusText);
                    
                    if (response.ok) {
                        const bvhText = await response.text();
                        console.log('üìÑ BVH text length:', bvhText.length, 'characters');
                       
                        // Try server processing first
                        if (useServerProcessing) {
                            try {
                                logInferenceEvent('üîÑ Processing BVH through server...', 'info');
                                const serverResult = await processBVHWithServer(bvhText);
                                
                                if (serverResult) {
                                    // Use server-processed data
                                    bvhData[filename] = {
                                        frames: serverResult.windowed_data.hip_pos.map((frame, i) => {
                                            // Convert server format back to BVH format
                                            return [
                                                ...serverResult.windowed_data.hip_pos[i].slice(0, 3),
                                                ...serverResult.windowed_data.quats[i].slice(0, 3),
                                                ...serverResult.windowed_data.quats[i].slice(3)
                                            ];
                                        }),
                                        frameTime: 1/30,
                                        frameCount: serverResult.windowed_data.window_count,
                                        processedByServer: true
                                    };
                                    
                                    logInferenceEvent('‚úÖ Using server-processed BVH data', 'success');
                                    statusDiv.textContent = `Loaded ${filename} (server-processed)`;
                                } else {
                                    throw new Error('Server processing failed');
                                }
                            } catch (serverError) {
                                logInferenceEvent(`‚ö†Ô∏è Server processing failed, using local: ${serverError.message}`, 'warning');
                                // Fall back to local processing
                                bvhData[filename] = parseBVHData(bvhText);
                                statusDiv.textContent = `Loaded ${filename} (local parsing)`;
                            }
                        } else {
                            // Local processing only
                            bvhData[filename] = parseBVHData(bvhText);
                            console.log('‚úÖ BVH data parsed for', filename, '- Frames:', bvhData[filename].frames?.length);
                        }

                        currentAnimation = filename;
                        animationFrame = 0;
                        statusDiv.textContent = `Loaded ${animations[filename]?.name || filename}`;
                        
                    } else {
                        throw new Error(`BVH file not found: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Could not load BVH file:', error);
                    statusDiv.textContent = `BVH load failed, using fallback animation`;
                }
                
            } catch (error) {
                console.error('‚ùå Failed to load animation:', error);
                statusDiv.textContent = 'Animation load failed';
            }
        }
       
        // Enhanced BVH parser that also extracts joint order
        function parseBVHData(bvhText) {
            const lines = bvhText.split('\n');
            
            // --- NEW: Parse the HIERARCHY section ---
            const jointOrder = [];
            let inHierarchy = false;
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('HIERARCHY')) {
                    inHierarchy = true;
                }
                if (trimmedLine.startsWith('MOTION')) {
                    inHierarchy = false;
                    break; // Stop when we reach the motion section
                }
                
                if (inHierarchy) {
                    // Find lines that define a joint, but ignore the root
                    if (trimmedLine.startsWith('JOINT')) {
                        const jointName = trimmedLine.split(/\s+/)[1];
                        jointOrder.push(jointName);
                    }
                }
            }
            console.log('üìä Dynamically parsed joint order:', jointOrder);
            
            // --- Existing MOTION parsing logic ---
            let motionIndex = lines.findIndex(line => line.trim().startsWith('MOTION'));
            if (motionIndex === -1) throw new Error('No MOTION section found in BVH');
            
            let frameCountLine = lines.find(line => line.trim().startsWith('Frames:'));
            let frameTimeLine = lines.find(line => line.trim().startsWith('Frame Time:'));

            const frameCount = frameCountLine ? parseInt(frameCountLine.split(':')[1]) : 0;
            const frameTime = frameTimeLine ? parseFloat(frameTimeLine.split(':')[1]) : 0.016667;
            
            const frames = [];
            const motionDataStartIndex = lines.indexOf(frameTimeLine) + 1;

            for (let i = motionDataStartIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const values = line.split(/\s+/).map(parseFloat);
                    if (values.length > 0 && !isNaN(values[0])) {
                        frames.push(values);
                    }
                }
            }
            
            console.log(`üìä Parsed ${frames.length} frames with ${frames[0]?.length || 0} channels each.`);
            
            // Return a comprehensive object with all parsed data
            return {
                frames,
                frameTime,
                frameCount: frames.length,
                channelCount: frames[0]?.length || 0,
                jointOrder // Include the newly parsed joint order
            };
        }

        
        // Apply BVH frame data to skeleton
        function applyBVHFrame(frameData) {
            if (!frameData || frameData.length < 6) return;
            
            let channelIndex = 0;
            
            // Root position (first 3 channels)
            const rootX = frameData[channelIndex++] || 0;
            const rootY = frameData[channelIndex++] || 0;
            const rootZ = frameData[channelIndex++] || 0;
            
            // Root rotation (next 3 channels) - Try Y-first order (common in many BVH files)
            const rootRotY = (frameData[channelIndex++] || 0) * Math.PI / 180; // Y first (turning)
            const rootRotX = (frameData[channelIndex++] || 0) * Math.PI / 180; // X second (pitch)
            const rootRotZ = (frameData[channelIndex++] || 0) * Math.PI / 180; // Z third (roll)
            
            // Apply root transformation to skeleton - use BVH data naturally
            if (skeletonGroup) {
                // DEBUG: Log the values we're getting (more detailed)
                if (animationFrame % 60 === 0) { // Log every 60 frames
                    console.log('üé¨ BVH Animation Debug (TESTING Y-AXIS TURNING):', {
                        frame: animationFrame,
                        rootPos: { x: rootX.toFixed(2), y: rootY.toFixed(2), z: rootZ.toFixed(2) },
                        rootRotDeg: { 
                            x: (rootRotX*180/Math.PI).toFixed(1) + '¬∞ (pitch/lean)', 
                            y: (rootRotY*180/Math.PI).toFixed(1) + '¬∞ (YAW/TURN - main direction)', 
                            z: (rootRotZ*180/Math.PI).toFixed(1) + '¬∞ (roll/side)' 
                        },
                        rootRotRad: { x: rootRotX.toFixed(3), y: rootRotY.toFixed(3), z: rootRotZ.toFixed(3) },
                        skeletonPos: {
                            x: skeletonGroup.position.x.toFixed(3),
                            y: skeletonGroup.position.y.toFixed(3), 
                            z: skeletonGroup.position.z.toFixed(3)
                        },
                        bvhScale: bvhScale,
                        jointCount: Object.keys(jointMeshes).length
                    });
                }
                
                // Position: scale BVH units to display size
                skeletonGroup.position.set(
                    rootX * bvhScale,      // X: as-is from BVH
                    rootY * bvhScale,      // Y: as-is from BVH (let it control height)
                    rootZ * bvhScale       // Z: as-is from BVH  
                );
                
                // Apply BVH root transformation - PURE BVH MODE (NO CONSTRAINTS)
                skeletonGroup.rotation.order = 'YXZ'; // Try Y-first order
                
                // Apply BVH rotations DIRECTLY - testing Y-axis for turning
                // Y: Turning left/right (heading/yaw) - THIS should control direction!
                // X: Leaning forward/back (pitch)  
                // Z: Rolling side to side (roll)
                skeletonGroup.rotation.set(
                    rootRotX,  // X: Forward/back lean (pitch)
                    rootRotY,  // Y: Left/right turning (yaw) - PRIMARY DIRECTION CONTROL
                    rootRotZ   // Z: Side roll
                );
            }
            
            // Apply joint rotations using correct BVH joint order
            const bvhJointOrder = [
                'Chest',          // 3 rotation channels
                'Chest2',         // 3 rotation channels  
                'Chest3',         // 3 rotation channels
                'Chest4',         // 3 rotation channels
                'Neck',           // 3 rotation channels
                'Head',           // 3 rotation channels
                'RightCollar',    // 3 rotation channels
                'RightShoulder',  // 3 rotation channels
                'RightElbow',     // 3 rotation channels
                'RightWrist',     // 3 rotation channels
                'LeftCollar',     // 3 rotation channels
                'LeftShoulder',   // 3 rotation channels
                'LeftElbow',      // 3 rotation channels
                'LeftWrist',      // 3 rotation channels
                'RightHip',       // 3 rotation channels
                'RightKnee',      // 3 rotation channels
                'RightAnkle',     // 3 rotation channels
                'RightToe',       // 3 rotation channels
                'LeftHip',        // 3 rotation channels
                'LeftKnee',       // 3 rotation channels
                'LeftAnkle',      // 3 rotation channels
                'LeftToe'         // 3 rotation channels
            ];
            
            bvhJointOrder.forEach(jointName => {
                if (jointMeshes[jointName] && channelIndex + 2 < frameData.length) {
                    // Try Y-first joint rotation order to match root
                    const rotY = (frameData[channelIndex++] || 0) * Math.PI / 180; // Y first
                    const rotX = (frameData[channelIndex++] || 0) * Math.PI / 180; // X second
                    const rotZ = (frameData[channelIndex++] || 0) * Math.PI / 180; // Z third
                    
                    // Set rotation order to match root (Y, X, Z)
                    jointMeshes[jointName].rotation.order = 'YXZ';
                    
                    // Apply rotations in Y-first order
                    jointMeshes[jointName].rotation.set(
                        rotX,   // X: pitch
                        rotY,   // Y: yaw (primary rotation)
                        rotZ    // Z: roll
                    );
                }
            });
        }
       


        // Style control functions
        async function randomizeStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('üé≤ Randomizing motion style...', 'info');
            
            // Generate random style vector
            for (let i = 0; i < aiModelManager.currentStyle.length; i++) {
                aiModelManager.currentStyle[i] = (Math.random() - 0.5) * 2; // [-1, 1]
            }
            
            logInferenceEvent('‚úÖ Style randomized - motion will adapt over next few frames', 'success');
        }

        async function smoothStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('‚ú® Applying smooth/graceful style...', 'info');
            
            // Smooth, graceful style pattern
            aiModelManager.currentStyle.fill(0);
            for (let i = 0; i < 64; i++) {
                aiModelManager.currentStyle[i] = Math.sin(i * 0.1) * 0.5; // Smooth sinusoidal
            }
            
            logInferenceEvent('‚úÖ Smooth style applied', 'success');
        }

        async function aggressiveStyle() {
            if (!aiModelManager.isInitialized) return;
            
            logInferenceEvent('üî• Applying aggressive style...', 'info');
            
            // Aggressive, sharp style pattern
            aiModelManager.currentStyle.fill(0);
            for (let i = 0; i < 64; i++) {
                aiModelManager.currentStyle[i] = Math.sign(Math.sin(i * 0.3)) * 0.8; // Sharp square wave
            }
            
            logInferenceEvent('‚úÖ Aggressive style applied', 'success');
        }

        async function analyzeCurrentMotion() {
            if (!aiModelManager.isInitialized || aiModelManager.motionHistory.length < 10) {
                logInferenceEvent('‚ö†Ô∏è Need more motion history for analysis', 'warning');
                return;
            }
            
            logInferenceEvent('üîç Analyzing current motion patterns...', 'info');
            
            // Analyze recent motion
            const recentMotion = aiModelManager.motionHistory.slice(-10);
            const avgVelocity = recentMotion.reduce((sum, frame) => {
                return sum + Math.abs(frame[0]) + Math.abs(frame[2]); // X and Z velocity
            }, 0) / recentMotion.length;
            
            const avgRotation = recentMotion.reduce((sum, frame) => {
                return sum + Math.abs(frame[4]); // Y rotation
            }, 0) / recentMotion.length;
            
            logInferenceEvent(`üìä Motion Analysis:`, 'info');
            logInferenceEvent(`  - Average velocity: ${avgVelocity.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Average rotation: ${avgRotation.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Current phase: ${aiModelManager.currentPhase.toFixed(3)}`, 'info');
            logInferenceEvent(`  - Style vector norm: ${Math.sqrt(aiModelManager.currentStyle.reduce((sum, x) => sum + x*x, 0)).toFixed(3)}`, 'info');
        }


        // Initialize AI system on page load
        updateLoadingStatus('Initializing AI-powered motion system...');

        // Initialize AI model manager
        setTimeout(async () => {
            try {
                logInferenceEvent('üß† Pure WebGPU AI system ready for initialization...', 'info');
                logInferenceEvent('üí° Click "üî• Warm Up All" to load ONNX models on WebGPU', 'info');
                logInferenceEvent('üéØ Then switch to AI mode to use neural networks!', 'success');

                // Enable AI mode button
                const aiModeBtn = document.getElementById('ai-mode-btn');
                if (aiModeBtn) {
                    aiModeBtn.disabled = false;
                    aiModeBtn.title = 'Switch between BVH playback and AI-generated motion';
                }
                
            } catch (error) {
                logInferenceEvent(`‚ùå AI initialization failed: ${error.message}`, 'error');
                logInferenceEvent('üí° Falling back to BVH-only mode', 'warning');
            }
        }, 2000);



        // Toggle function for inference details (from legacy)
        function toggleInferenceDetails() {
            const details = document.getElementById('inference-details');
            const button = document.getElementById('toggle-inference-details');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                button.textContent = 'Hide Details';
            } else {
                details.style.display = 'none';
                button.textContent = 'Show Details';
            }
        }
        
        // Add event listener for the toggle button
        document.getElementById('toggle-inference-details').onclick = toggleInferenceDetails;
        
        // === SERVER WARMUP FUNCTIONALITY ===
        
        // Server configuration
        const SERVER_BASE_URL = 'http://localhost:8000';
        const WEBSOCKET_URL = 'ws://localhost:8765';
        let modelStatus = {
            deephase: 'ready',
            stylevae: 'standby', 
            transitionnet: 'idle'
        };
        
        // WebSocket connection
        let websocket = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        
        // Update model status displays
        function updateModelStatus(model, status, message = '') {
            const statusElement = document.getElementById(`${model}-status`);
            if (statusElement) {
                const statusDiv = statusElement.querySelector('div:last-child');
                if (statusDiv) {
                    statusDiv.textContent = status;
                    if (message) {
                        statusDiv.title = message;
                    }
                }
                
                // Update color based on status
                const titleDiv = statusElement.querySelector('div:first-child');
                if (titleDiv) {
                    if (status.toLowerCase().includes('ready') || status.toLowerCase().includes('active')) {
                        titleDiv.style.color = '#00ff88';
                    } else if (status.toLowerCase().includes('loading') || status.toLowerCase().includes('warming')) {
                        titleDiv.style.color = '#ffaa00';
                    } else {
                        titleDiv.style.color = '#ff6666';
                    }
                }
            }
            
            modelStatus[model] = status.toLowerCase();
        }
        
        // Log inference events
        function logInferenceEvent(message, type = 'info') {
            const inferenceLog = document.getElementById('inference-log');
            if (inferenceLog) {
                const timestamp = new Date().toLocaleTimeString();
                const color = type === 'error' ? '#ff6666' : 
                             type === 'warning' ? '#ffaa00' : 
                             type === 'success' ? '#00ff88' : '#00d4ff';
                
                const logEntry = document.createElement('div');
                logEntry.style.color = color;
                logEntry.textContent = `[${timestamp}] ${message}`;
                
                inferenceLog.appendChild(logEntry);
                inferenceLog.scrollTop = inferenceLog.scrollHeight;
                
                // Keep only last 20 log entries
                while (inferenceLog.children.length > 25) {
                    inferenceLog.removeChild(inferenceLog.children[5]); // Keep first 5 header lines
                }
            }
        }
        
        // === WEBSOCKET COMMUNICATION ===
        
        function connectWebSocket() {
            try {
                logInferenceEvent('üîó Connecting to WebSocket server...', 'info');
                websocket = new WebSocket(WEBSOCKET_URL);
                
                websocket.onopen = function(event) {
                    logInferenceEvent('‚úÖ WebSocket connected - real-time mode active!', 'success');
                    reconnectAttempts = 0;
                };
                
                websocket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        logInferenceEvent(`‚ùå Error parsing WebSocket message: ${error}`, 'error');
                    }
                };
                
                websocket.onclose = function(event) {
                    logInferenceEvent('üîå WebSocket disconnected', 'warning');
                    
                    // Attempt to reconnect
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        logInferenceEvent(`üîÑ Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`, 'info');
                        setTimeout(connectWebSocket, 2000 * reconnectAttempts);
                    } else {
                        logInferenceEvent('‚ùå Max reconnection attempts reached. Using fallback mode.', 'error');
                    }
                };
                
                websocket.onerror = function(error) {
                    logInferenceEvent('‚ùå WebSocket error - falling back to HTTP mode', 'error');
                };
                
            } catch (error) {
                logInferenceEvent(`‚ùå WebSocket connection failed: ${error.message}`, 'error');
            }
        }
        
        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'initial_status':
                    logInferenceEvent('üìä Received initial server status', 'info');
                    updateModelsFromServerData(data.models);
                    break;
                    
                case 'status_update':
                    const model = data.model;
                    const status = data.status;
                    const details = data.details || {};
                    
                    updateModelStatus(model, status, `${data.model_type || ''} - ${details.stage || ''}`);
                    
                    if (details.progress !== undefined) {
                        logInferenceEvent(`${model}: ${status} (${details.progress}%)`, 'info');
                    } else {
                        logInferenceEvent(`${model}: ${status}`, 'info');
                    }
                    
                    if (details.processing_time) {
                        logInferenceEvent(`${model} processing time: ${details.processing_time.toFixed(3)}s`, 'success');
                    }
                    break;
                    
                case 'command_ack':
                    logInferenceEvent(`‚úÖ Command acknowledged: ${data.command} for ${data.model}`, 'success');
                    break;
                    
                case 'pong':
                    logInferenceEvent('üèì Server responsive', 'info');
                    break;
                    
                default:
                    logInferenceEvent(`üì® Received: ${data.type}`, 'info');
            }
        }
        
        function sendWebSocketCommand(command, model = null) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const message = {
                    type: command,
                    model: model,
                    timestamp: Date.now()
                };
                
                websocket.send(JSON.stringify(message));
                logInferenceEvent(`üì§ Sent command: ${command}${model ? ' for ' + model : ''}`, 'info');
                return true;
            } else {
                logInferenceEvent('‚ö†Ô∏è WebSocket not connected, using fallback mode', 'warning');
                return false;
            }
        }
        
        function updateModelsFromServerData(modelsData) {
            for (const [modelName, modelInfo] of Object.entries(modelsData)) {
                if (modelName !== 'skeleton') {
                    updateModelStatus(modelName, modelInfo.status, modelInfo.type);
                }
            }
        }
        
        // Test server connection
        async function testServerConnection() {
            logInferenceEvent('Testing server connection...', 'info');
            updateModelStatus('deephase', 'Testing...', 'Checking server connectivity');
            
            try {
                const response = await fetch(`${SERVER_BASE_URL}/api/status`);
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì Server connected: ${data.server || 'RSMT Server'}`, 'success');
                    
                    // Update model statuses from server response
                    if (data.models) {
                        for (const [modelName, modelInfo] of Object.entries(data.models)) {
                            if (modelName !== 'skeleton') {
                                const status = modelInfo.status || 'Unknown';
                                updateModelStatus(modelName, status, `Type: ${modelInfo.type || 'Unknown'}`);
                            }
                        }
                    }
                    
                    logInferenceEvent(`AI Status: ${data.ai_status || 'Unknown'}`, 'info');
                    logInferenceEvent(`Models using AI: ${data.models_using_ai || '0/3'}`, 'info');
                    
                } else {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå Server connection failed: ${error.message}`, 'error');
                
                // Try simple HTTP server test
                try {
                    const simpleResponse = await fetch(`${SERVER_BASE_URL}/`);
                    if (simpleResponse.ok) {
                        logInferenceEvent('‚ö† Simple HTTP server detected, need FastAPI server', 'warning');
                        logInferenceEvent('üí° To start proper server: python3 simple_warmup_server.py', 'info');
                        updateModelStatus('deephase', 'No API', 'Simple HTTP server only');
                        updateModelStatus('stylevae', 'No API', 'Need API server');
                        updateModelStatus('transitionnet', 'No API', 'Need API server');
                    }
                } catch (simpleError) {
                    logInferenceEvent('üîÑ Server not running - simulating warmup locally', 'warning');
                    simulateLocalWarmup();
                }
            }
        }
        
        // Simulate warmup when server is not available
        function simulateLocalWarmup() {
            updateModelStatus('deephase', 'Simulated', 'Local simulation mode');
            updateModelStatus('stylevae', 'Standby', 'Ready for simulation');
            updateModelStatus('transitionnet', 'Idle', 'Ready for simulation');
            logInferenceEvent('üé≠ Running in simulation mode - no real neural networks', 'warning');
            logInferenceEvent('üí° Start server on port 8000 for real AI processing', 'info');
        }
        
        // Warm up StyleVAE model
        async function warmupStyleVAE() {
            logInferenceEvent('üé® Initiating StyleVAE warmup...', 'info');
            updateModelStatus('stylevae', 'Initiating...', 'Sending warmup command');
            
            // Try WebSocket first
            if (sendWebSocketCommand('warmup', 'stylevae')) {
                return; // WebSocket will handle the rest
            }
            
            // Fallback to HTTP/simulation
            try {
                const dummyMotion = {
                    frames: [
                        [0, 0, 0, 0, 0, 0, ...Array(60).fill(0)]
                    ],
                    frame_time: 0.016667
                };
                
                const response = await fetch(`${SERVER_BASE_URL}/api/encode_style`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        motion_data: dummyMotion
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì StyleVAE activated! Processing time: ${data.processing_time?.toFixed(3) || 'unknown'}s`, 'success');
                    updateModelStatus('stylevae', 'Active', `Ready for style encoding. Time: ${data.processing_time?.toFixed(3)}s`);
                    
                    if (data.style_code && data.style_code.length > 0) {
                        logInferenceEvent(`Style vector dimension: ${data.style_code.length}`, 'info');
                    }
                } else {
                    throw new Error(`StyleVAE warmup failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå HTTP warmup failed: ${error.message}`, 'error');
                // Simulate StyleVAE activation
                logInferenceEvent('üé® Simulating StyleVAE warmup...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 800));
                updateModelStatus('stylevae', 'Simulated', 'Local simulation active');
                logInferenceEvent('‚úì StyleVAE simulation active (256-dim style vectors)', 'success');
            }
        }
        
        // Warm up TransitionNet model
        async function warmupTransitionNet() {
            logInferenceEvent('üîÑ Initiating TransitionNet warmup...', 'info');
            updateModelStatus('transitionnet', 'Initiating...', 'Sending warmup command');
            
            // Try WebSocket first
            if (sendWebSocketCommand('warmup', 'transitionnet')) {
                return; // WebSocket will handle the rest
            }
            
            // Fallback to HTTP/simulation
            try {
                const dummyMotion = {
                    frames: [
                        [0, 0, 0, 0, 0, 0, ...Array(60).fill(0)]
                    ],
                    frame_time: 0.016667
                };
                
                const dummyStyleCode = Array(256).fill(0.1);
                
                const response = await fetch(`${SERVER_BASE_URL}/api/generate_transition`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        start_motion: dummyMotion,
                        target_motion: dummyMotion,
                        style_code: dummyStyleCode,
                        transition_length: 10
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    logInferenceEvent(`‚úì TransitionNet activated! Processing time: ${data.processing_time?.toFixed(3) || 'unknown'}s`, 'success');
                    updateModelStatus('transitionnet', 'Active', `Ready for motion transitions. Time: ${data.processing_time?.toFixed(3)}s`);
                    
                    if (data.transition_frames && data.transition_frames.length > 0) {
                        logInferenceEvent(`Generated ${data.transition_frames.length} transition frames`, 'info');
                    }
                } else {
                    throw new Error(`TransitionNet warmup failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                logInferenceEvent(`‚ùå HTTP warmup failed: ${error.message}`, 'error');
                // Simulate TransitionNet activation
                logInferenceEvent('üîÑ Simulating TransitionNet warmup...', 'warning');
                await new Promise(resolve => setTimeout(resolve, 600));
                updateModelStatus('transitionnet', 'Simulated', 'Local simulation active');
                logInferenceEvent('‚úì TransitionNet simulation active (motion blending)', 'success');
            }
        }
        
        // Warm up all models
        async function warmupAllModels() {
            logInferenceEvent('üî• Starting full model warmup sequence...', 'info');
            
            // Try WebSocket command for all models
            if (sendWebSocketCommand('warmup', 'all')) {
                updateModelStatus('stylevae', 'Queued...', 'Waiting for server');
                updateModelStatus('transitionnet', 'Queued...', 'Waiting for server');
                return; // WebSocket will handle the rest
            }
            
            // Fallback to individual warmups
            updateModelStatus('deephase', 'Ready', 'Already active');
            updateModelStatus('stylevae', 'Initializing...', 'Starting StyleVAE warmup');
            updateModelStatus('transitionnet', 'Initializing...', 'Starting TransitionNet warmup');
            
            try {
                await testServerConnection();
                await new Promise(resolve => setTimeout(resolve, 1000));
                await warmupStyleVAE();
                await new Promise(resolve => setTimeout(resolve, 500));
                await warmupTransitionNet();
                
                logInferenceEvent('üéØ All models warmed up successfully!', 'success');
                document.getElementById('inference-rate').textContent = 'Variable';
                document.getElementById('inference-latency').textContent = 'Active';
            } catch (error) {
                logInferenceEvent(`‚ùå Warmup sequence failed: ${error.message}`, 'error');
            }
        }



        // === PURE WEBGPU WARMUP FUNCTIONS (No Server Dependencies) ===
        async function testServerConnectionReal() {
            logInferenceEvent('üåê Pure WebGPU mode - no server connection needed!', 'success');
            updateModelStatus('deephase', 'WebGPU Ready', 'Client-side inference');
            updateModelStatus('stylevae', 'WebGPU Ready', 'Client-side inference');
            updateModelStatus('transitionnet', 'WebGPU Ready', 'Client-side inference');
        }

        async function warmupStyleVAEReal() {
            if (!aiModelManager.isInitialized) {
                logInferenceEvent('üé® Initializing StyleVAE on WebGPU...', 'info');
                try {
                    await aiModelManager.initialize();
                    updateModelStatus('stylevae', 'Ready', 'WebGPU loaded successfully');
                    logInferenceEvent('‚úÖ StyleVAE ready on WebGPU!', 'success');
                } catch (error) {
                    updateModelStatus('stylevae', 'Failed', error.message);
                    logInferenceEvent(`‚ùå StyleVAE initialization failed: ${error.message}`, 'error');
                }
            } else {
                updateModelStatus('stylevae', 'Active', 'WebGPU inference ready');
                logInferenceEvent('‚úÖ StyleVAE already active on WebGPU', 'success');
            }
        }

        async function warmupTransitionNetReal() {
            if (!aiModelManager.isInitialized) {
                logInferenceEvent('üîÑ Initializing TransitionNet on WebGPU...', 'info');
                try {
                    await aiModelManager.initialize();
                    updateModelStatus('transitionnet', 'Ready', 'WebGPU loaded successfully');
                    logInferenceEvent('‚úÖ TransitionNet ready on WebGPU!', 'success');
                } catch (error) {
                    updateModelStatus('transitionnet', 'Failed', error.message);
                    logInferenceEvent(`‚ùå TransitionNet initialization failed: ${error.message}`, 'error');
                }
            } else {
                updateModelStatus('transitionnet', 'Active', 'WebGPU inference ready');
                logInferenceEvent('‚úÖ TransitionNet already active on WebGPU', 'success');
            }
        }

        async function warmupAllModelsReal() {
            logInferenceEvent('üî• Starting WebGPU model initialization...', 'info');
            updateModelStatus('deephase', 'Initializing...', 'Loading on WebGPU');
            updateModelStatus('stylevae', 'Initializing...', 'Loading on WebGPU');
            updateModelStatus('transitionnet', 'Initializing...', 'Loading on WebGPU');

            try {
                await aiModelManager.initialize();
                updateModelStatus('deephase', 'Ready', 'WebGPU inference ready');
                updateModelStatus('stylevae', 'Ready', 'WebGPU inference ready');
                updateModelStatus('transitionnet', 'Ready', 'WebGPU inference ready');

                logInferenceEvent('üéØ All models ready on WebGPU!', 'success');
                document.getElementById('inference-rate').textContent = 'WebGPU Ready';
                document.getElementById('inference-latency').textContent = 'Sub-ms';

            } catch (error) {
                logInferenceEvent(`‚ùå Model initialization failed: ${error.message}`, 'error');
                updateModelStatus('deephase', 'Failed', error.message);
                updateModelStatus('stylevae', 'Failed', error.message);
                updateModelStatus('transitionnet', 'Failed', error.message);
            }
        }


        
        // Make warmup functions globally accessible
        window.testServerConnection = testServerConnectionReal;
        window.warmupStyleVAE = warmupStyleVAEReal;
        window.warmupTransitionNet = warmupTransitionNetReal;
        window.warmupAllModels = warmupAllModelsReal;



        // Add this new function to apply the child's simple pose to the 3D skeleton
        function applyTransitionPose(pose) {
            if (!skeletonGroup || !pose || pose.length < 2) return;

            // Use a much smaller scale because the child's coordinate system is large
            const visScale = 0.005;

            // Center the motion around the origin (0,0) of the 3D scene
            const x = (pose[0] - 200) * visScale;
            const y_offset = (pose[1] - 200) * visScale; // This will be the "bounce"

            if (jointMeshes['Hips']) {
                skeletonGroup.position.x = x;
                // Add the bounce to the base height of the skeleton
                skeletonGroup.position.y = 1.0 + y_offset;
            }
        }

       
        async function loadAllAnimations() {
            updateLoadingStatus('Loading all BVH animations...');
            const animationFiles = Object.keys(animations);
            const promises = animationFiles.map(filename => loadAnimation(filename));
            
            // Promise.all allows us to load all files concurrently for speed.
            await Promise.all(promises);
            
            logInferenceEvent(`‚úÖ All ${animationFiles.length} BVH animations loaded successfully.`, 'success');
            statusDiv.textContent = 'Ready';
        
            // Automatically send the loaded data to the transition system.
            transitionIntegration.sendBVHData();
        }
        
        // Global functions for UI buttons
        window.sendCurrentPoseToTransition = () => {
            transitionIntegration.sendCurrentPoseData();
        };
        
        window.sendBVHDataToTransition = () => {
            transitionIntegration.sendBVHData();
        };
        
        window.syncAnimations = () => {
            transitionIntegration.syncAnimations();
        };
        
        window.requestTransitionAnalysis = () => {
            transitionIntegration.requestTransitionAnalysis();
        };


        // Toggle transition system visibility
        window.toggleTransitionSystem = function() {
            const transitionSystem = document.getElementById('transition-system');
            const toggleBtn = document.getElementById('transition-toggle-btn');
            
            if (transitionSystem.style.display === 'none') {
                transitionSystem.style.display = 'block';
                toggleBtn.textContent = 'üîÑ Hide BVH Transition System';
                toggleBtn.style.background = '#f44336';
            } else {
                transitionSystem.style.display = 'none';
                toggleBtn.textContent = 'üîÑ Show BVH Transition System';
                toggleBtn.style.background = '#9C27B0';
            }
        };


    </script>

    <!-- // Initialize WebSocket connection -->
    <!-- setTimeout(() => { -->
    <!--     logInferenceEvent('üåê Initializing real-time server connection...', 'info'); -->
    <!--     connectWebSocket(); -->
    <!-- }, 1000); -->
    
    <!-- // Auto-test server connection on page load -->
    <!-- setTimeout(() => { -->
    <!--     logInferenceEvent('Auto-testing server connection...', 'info'); -->
    <!--     testServerConnection(); -->
    <!-- }, 2000); -->
    
    <!-- // Periodic WebSocket ping and status updates -->
    <!-- setInterval(() => { -->
    <!--     if (websocket && websocket.readyState === WebSocket.OPEN) { -->
    <!--         sendWebSocketCommand('ping'); -->
    <!--     } else { -->
    <!--         // Try to reconnect if connection is lost -->
    <!--         if (!websocket || websocket.readyState === WebSocket.CLOSED) { -->
    <!--             connectWebSocket(); -->
    <!--         } -->
    <!--     } -->
    <!-- }, 30000); // Every 30 seconds -->

</body>
</html>
